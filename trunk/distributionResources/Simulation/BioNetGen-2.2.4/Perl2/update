BNGAction.pm:21:    $params->{method} = 'cvode';
BNGAction.pm:22:    my $err = $model->simulate( $params );
BNGAction.pm:32:    $params->{method} = 'ssa';
BNGAction.pm:33:    my $err = $model->simulate( $params );
BNGAction.pm:43:    $params->{method} = 'pla';
BNGAction.pm:44:    my $err = $model->simulate( $params );
BNGAction.pm:81:    my $argfile = defined $params->{argfile} ? $params->{argfile} : undef;
BNGAction.pm:102:            if ( !(defined $params->{$args[0]}) )
BNGAction.pm:105:                    $params->{$args[0]} = $args[1];
BNGAction.pm:114:                    {    return "Problem parsing 'sample_times': Sample times must be comma-separated (no spaces) ints or floats "
BNGAction.pm:115:                             . "(exponential format ok) enclosed in square brackets, e.g., [5e-1,1,5.0,1E1].";
BNGAction.pm:121:                        {    return "Problem parsing 'sample_times': Sample times must be comma-separated (no spaces) ints or floats "
BNGAction.pm:122:                             . "(exponential format ok) enclosed in square brackets, e.g., [5e-1,1,5.0,1E1].";
BNGAction.pm:131:                           (looks_like_number($params->{$args[0]}) ? "$params->{$args[0]}" : "'$params->{$args[0]}'");
BNGAction.pm:142:    my $prefix       = defined $params->{prefix}     ? $params->{prefix}     : $model->getOutputPrefix();
BNGAction.pm:143:    my $netfile      = defined $params->{netfile}    ? $params->{netfile}    : undef;
BNGAction.pm:144:    my $verbose      = defined $params->{verbose}    ? $params->{verbose}    : 0;
BNGAction.pm:145:    my $print_end    = defined $params->{print_end}  ? $params->{print_end}  : 0;
BNGAction.pm:146:    my $print_net    = defined $params->{print_net}  ? $params->{print_net}  : 0;
BNGAction.pm:147:    my $save_progress = defined $params->{save_progress} ? $params->{save_progress} : 0; # Same as 'print_net'
BNGAction.pm:148:    my $continue     = defined $params->{'continue'} ? $params->{'continue'} : 0;    
BNGAction.pm:149:    my $method       = defined $params->{method}     ? $params->{method}     : undef;
BNGAction.pm:150:    my $print_active = defined $params->{print_n_species_active} ? $params->{print_n_species_active} : 0;
BNGAction.pm:151:    my $print_cdat   = defined $params->{print_CDAT} ? $params->{print_CDAT} : 1; # Default is to print .cdat
BNGAction.pm:152:    my $print_fdat   = defined $params->{print_functions} ? $params->{print_functions} : 0; # Default is to NOT print .fdat
BNGAction.pm:155:    my $atol         = defined $params->{atol}         ? $params->{atol}         : 1e-8;
BNGAction.pm:156:    my $rtol         = defined $params->{rtol}         ? $params->{rtol}         : 1e-8;
BNGAction.pm:157:    my $sparse       = defined $params->{sparse}       ? $params->{sparse}       : 0;
BNGAction.pm:158:    my $steady_state = defined $params->{steady_state} ? $params->{steady_state} : 0;
BNGAction.pm:161:    my $seed         = defined $params->{seed} ? $params->{seed} : floor(rand 2**31);
BNGAction.pm:168:    unless ( exists $METHODS->{$method} )
BNGAction.pm:173:    if ( $params->{suffix} )
BNGAction.pm:174:    {  $prefix .= "_" . $params->{suffix};  }
BNGAction.pm:193:        if ( !(-e $netfile) or $model->UpdateNet or (defined $params->{prefix}) or (defined $params->{suffix}) )
BNGAction.pm:195:            $err = $model->writeNET( {prefix=>"$netpre"} );
BNGAction.pm:196:#            $err = $model->writeNetwork( {prefix=>"$netpre"} );
BNGAction.pm:203:    my $binary = $METHODS->{$method}->{binary}; 
BNGAction.pm:204:    printf "%s simulation using %s\n", $METHODS->{$method}->{type}, $method;
BNGAction.pm:214:    push @command, "-o", "$prefix";
BNGAction.pm:217:    push @command, "-p", "$method";
BNGAction.pm:219:    # pla-specific arguments
BNGAction.pm:222:        if (exists $params->{pla_config})
BNGAction.pm:223:        {   push @command, split(' ', $params->{pla_config});  }
BNGAction.pm:224:        if (defined $params->{pla_output})
BNGAction.pm:225:    	{   push @command, "--pla_output", $params->{pla_output};  }
BNGAction.pm:230:        my $opts = $METHODS->{$method}->{options};
BNGAction.pm:231:        if ( exists $opts->{seed} )
BNGAction.pm:233:            push @command, "-h", $seed;
BNGAction.pm:235:        if ( exists $opts->{atol} )
BNGAction.pm:237:            push @command, "-a", $atol;
BNGAction.pm:239:        if ( exists $opts->{rtol} )
BNGAction.pm:241:            push @command, "-r",  $rtol;
BNGAction.pm:243:        if ( exists $opts->{sparse} )
BNGAction.pm:245:            if ($sparse) { push @command, "-b"; }
BNGAction.pm:247:        if ( exists $opts->{steady_state} )
BNGAction.pm:249:            if ($steady_state) { push @command, "-c"; }
BNGAction.pm:254:    my $update_interval = defined $params->{update_interval} ? $params->{update_interval} : 1.0;
BNGAction.pm:257:    my $expand =  defined $params->{expand} ? $params->{expand} : 'lazy';
BNGAction.pm:263:    if (defined $params->{max_sim_steps})
BNGAction.pm:264:    {   push @command, "-M", $params->{max_sim_steps};  }
BNGAction.pm:267:    if (defined $params->{output_step_interval})
BNGAction.pm:268:    {   push @command, "-I", $params->{output_step_interval};  }
BNGAction.pm:271:    if (defined $params->{stop_if}){   
BNGAction.pm:272:    	push @command, "--stop_cond", $params->{stop_if};
BNGAction.pm:273:    	if (defined $params->{print_on_stop}){
BNGAction.pm:274:    		push @command, $params->{print_on_stop};
BNGAction.pm:282:    push @command, "--cdat", $print_cdat;
BNGAction.pm:284:    push @command, "--fdat", $print_fdat;
BNGAction.pm:287:    if (defined $params->{print_net} && defined $params->{save_progress}){ # Don't let them both be defined
BNGAction.pm:291:    if ($print_net || $save_progress) { push @command, "-n"; }
BNGAction.pm:293:    if ($print_end) { push @command, "-e"; }
BNGAction.pm:295:    if ($verbose)   { push @command, "-v"; }
BNGAction.pm:297:    if ($continue)  { push @command, "-x"; }    
BNGAction.pm:299:    if ($print_active) { push @command, "-j"; }
BNGAction.pm:304:    if ( defined $params->{t_start} )
BNGAction.pm:306:        $t_start = $params->{t_start};        
BNGAction.pm:310:            unless ( defined($model->Time)  and  ($model->Time == $t_start) )
BNGAction.pm:316:        if ( $continue   and   defined($model->Time) )
BNGAction.pm:317:        {  $t_start = $model->Time; }
BNGAction.pm:323:    $model->Time($t_start);
BNGAction.pm:327:    {  push @command, "-i", "$t_start";  }
BNGAction.pm:330:    push @command, "-g", $netfile;
BNGAction.pm:337:    if ( (defined $params->{n_steps} || defined $params->{n_output_steps}) && 
BNGAction.pm:338:         (defined $params->{sample_times} || @sample_times) ){
BNGAction.pm:340:        my $x = ( defined $params->{n_steps} ) ? "n_steps" : "n_output_steps";
BNGAction.pm:343:    if ( defined $params->{n_steps} || defined $params->{n_output_steps} || 
BNGAction.pm:344:       ( !defined $params->{sample_times} && !@sample_times) )
BNGAction.pm:346:        if ( defined $params->{n_steps} && defined $params->{n_output_steps} ){ # Don't let them both be defined
BNGAction.pm:351:        if ( defined $params->{t_end} ){
BNGAction.pm:352:            $t_end = $params->{t_end};
BNGAction.pm:358:        if ( ($t_end - $t_start) <= 0.0 )
BNGAction.pm:366:        if (defined $params->{n_steps}){
BNGAction.pm:367:            $n_steps = $params->{n_steps};
BNGAction.pm:369:        elsif (defined $params->{n_output_steps}){
BNGAction.pm:370:            $n_steps = $params->{n_output_steps};
BNGAction.pm:376:        my $step_size = ($t_end - $t_start) / $n_steps;
BNGAction.pm:379:#    elsif ( defined $params->{sample_times} || @sample_times )
BNGAction.pm:382:        if (defined $params->{sample_times})
BNGAction.pm:383:        { @sample_times = @{$params->{sample_times}}; }
BNGAction.pm:386:        	# remove all sample times <= t_start --Do this in run_network (LAH)
BNGAction.pm:390:            if ( defined $params->{t_end} ){
BNGAction.pm:391:                $t_end = $params->{t_end};
BNGAction.pm:392:                # remove all sample times >= t_end --Do this in run_network (LAH)
BNGAction.pm:411:    if ( $model->SpeciesList )
BNGAction.pm:413:        foreach my $spec ( @{$model->SpeciesList->Array} )
BNGAction.pm:415:            my $iter = $spec->RulesApplied;
BNGAction.pm:448:        # If network generation is on-the-fly, look for signal that
BNGAction.pm:456:            # remember that we've attempted On-the-fly!
BNGAction.pm:459:            unless ( $model->SpeciesList )
BNGAction.pm:462:                #  It's possible that it exists but the Network generation infrastructure is missing --Justin
BNGAction.pm:478:                    unless ( $spec = $model->SpeciesList->lookup_bystring($sname) )
BNGAction.pm:488:                $species = $model->SpeciesList->Array;
BNGAction.pm:492:            my $nspec = scalar @{$model->SpeciesList->Array};
BNGAction.pm:493:            my $nrxn  = scalar @{$model->RxnList->Array};
BNGAction.pm:496:            foreach my $rset ( @{$model->RxnRules} )
BNGAction.pm:503:                    my ($err, $nr) = $rr->expand_rule( $species, $model, $params );
BNGAction.pm:513:                      $n_new, cpu_time(0) - $t_off;
BNGAction.pm:521:                $spec->RulesApplied($n_iter) unless ($spec->RulesApplied);
BNGAction.pm:524:            foreach my $obs (@{$model->Observables})
BNGAction.pm:526:                $obs->update( $model->SpeciesList->Array, $nspec );
BNGAction.pm:530:            foreach my $spec ( @{$model->SpeciesList->Array} )
BNGAction.pm:532:                unless ( $spec->ObservablesApplied )
BNGAction.pm:534:                    push @$new_species, $spec  unless ( $spec->RulesApplied );
BNGAction.pm:535:                    $spec->ObservablesApplied(1);
BNGAction.pm:540:            if ( scalar @{$model->RxnList->Array} > $nrxn )
BNGAction.pm:543:                $model->SpeciesList->print( *Writer, $nspec );
BNGAction.pm:544:                $model->RxnList->print( *Writer, $nrxn );
BNGAction.pm:547:                foreach my $obs ( @{$model->Observables} )
BNGAction.pm:550:                    $obs->printGroup( *Writer, $model->SpeciesList->Array, $nspec );
BNGAction.pm:595:    if ( $otf  and  $model->SpeciesList )
BNGAction.pm:597:        #  It's possible that it exists but the Network generation infrastructure is missing --Justin
BNGAction.pm:598:        $err = $model->writeNET( {prefix => "$netpre"} );
BNGAction.pm:599:#        $err = $model->writeNetwork( {prefix => "$netpre"} );
BNGAction.pm:619:    if ( !($model->RxnList) )
BNGAction.pm:620:    {   # TODO: what does this accomplish? --Justin
BNGAction.pm:623:    elsif ( -e "$prefix.cdat" )
BNGAction.pm:634:        my $species = $model->SpeciesList->Array;
BNGAction.pm:640:        $model->Concentrations( $conc );
BNGAction.pm:641:        $model->UpdateNet(1);
BNGAction.pm:647:    $model->Time($t_end);
BNGAction.pm:670:    my $prefix  = defined $params->{prefix} ? $params->{prefix} : $model->getOutputPrefix();
BNGAction.pm:671:    my $suffix  = defined $params->{suffix} ? $params->{suffix} : "";
BNGAction.pm:681:        verbose         => { flag => "-v",    user_args => 0, default_arg => undef },
BNGAction.pm:682:        complex         => { flag => "-cb",   user_args => 0, default_arg => undef },
BNGAction.pm:683:        nocslf          => { flag => "-nocslf", user_args => 0, default_arg => undef },
BNGAction.pm:684:        notf            => { flag => "-notf", user_args => 0, default_arg => undef },
BNGAction.pm:685:        print_functions => { flag => "-ogf",  user_args => 0, default_arg => undef },
BNGAction.pm:686:        binary_output   => { flag => "-b",    user_args => 0, default_arg => undef },
BNGAction.pm:687:        get_final_state => { flag => "-ss",   user_args => 0, default_arg => "${prefix}.species" },
BNGAction.pm:688:        utl             => { flag => "-utl",  user_args => 1, default_arg => undef },
BNGAction.pm:689:        gml             => { flag => "-gml",  user_args => 1, default_arg => undef },
BNGAction.pm:690:        seed            => { flag => "-seed", user_args => 1, default_arg => undef },
BNGAction.pm:691:        equil           => { flag => "-eq",   user_args => 1, default_arg => undef },
BNGAction.pm:700:        if (defined $params->{$option})
BNGAction.pm:702:            if ($option_hash->{user_args})
BNGAction.pm:705:                push @args, $option_hash->{flag}, $params->{$option};
BNGAction.pm:707:            elsif ($params->{$option})
BNGAction.pm:709:                push @args, $option_hash->{flag};
BNGAction.pm:710:                if (defined $option_hash->{default_arg})
BNGAction.pm:711:                {  push @args, $option_hash->{default_arg};  }
BNGAction.pm:717:    if ( defined $params->{param} )
BNGAction.pm:718:    {  push @args, split " ", $params->{param};  }
BNGAction.pm:724:    if ( $model->Params->{no_nfsim} )
BNGAction.pm:726:        send_warning( "simulate_nf(): skipping simulation, 'no-nfsim' flag is true.");
BNGAction.pm:739:    $model->writeXML( {'prefix'=>$prefix} );
BNGAction.pm:742:    push @command, "-xml", "${prefix}.xml", "-o", "${prefix}.gdat";
BNGAction.pm:746:    if (defined $params->{t_start})
BNGAction.pm:748:        $t_start = $params->{t_start};
BNGAction.pm:749:        $model->Time($t_start);
BNGAction.pm:753:        $t_start = defined $model->Time ? $model->Time : 0;
BNGAction.pm:762:    if ($params->{continue})
BNGAction.pm:768:    if ( defined $params->{n_steps} )
BNGAction.pm:771:        $n_steps = $params->{n_steps};
BNGAction.pm:775:        if ( defined $params->{t_end} )
BNGAction.pm:776:        {   $t_end = $params->{t_end};   }
BNGAction.pm:783:        push @command, "-sim", ($t_end-$t_start), "-oSteps", $n_steps;
BNGAction.pm:785:    elsif ( defined $params->{sample_times} )
BNGAction.pm:834:    if ( $params->{get_final_state} )
BNGAction.pm:836:        if (my $err = $model->readNFspecies("${prefix}.species"))
BNGAction.pm:838:        if ( $params->{verbose} )
BNGAction.pm:839:        {  print $model->SpeciesList->writeBNGL( $model->Concentrations, $model->ParamList );  }
BNGAction.pm:847:    $model->Time($t_end);
BNGAction.pm:868:    if ($model->SpeciesList)
BNGAction.pm:870:        $conc_vec = [ (0) x scalar @{$model->SpeciesList->Array} ];
BNGAction.pm:876:        $model->SpeciesList( SpeciesList->new );
BNGAction.pm:878:    my $slist = $model->SpeciesList;
BNGAction.pm:898:        my $sg = SpeciesGraph->new();
BNGAction.pm:899:        my $err = $sg->readString( \$string, $model->CompartmentList, 1, '^\s+', 
BNGAction.pm:900:                                    $model->MoleculeTypesList );
BNGAction.pm:903:        # Read species concentration - may only be integer value
BNGAction.pm:911:        my $existing_sg = $model->SpeciesList->lookup( $sg );
BNGAction.pm:915:            $conc_vec->[$existing_sg->Index - 1] += $conc;
BNGAction.pm:920:            my $newspec = $model->SpeciesList->add( $sg, 0 );
BNGAction.pm:921:            $conc_vec->[ $newspec->Index - 1 ] = $conc;
BNGAction.pm:928:    $model->Concentrations( $conc_vec );
BNGAction.pm:942:#  --Justin, 21mar2001
BNGAction.pm:951:    printf "ACTION: generate_hybrid_model( %s )\n", $model->Name;
BNGAction.pm:967:        unless ( exists $options->{$opt} )
BNGAction.pm:971:        $options->{$opt} = $val;
BNGAction.pm:979:        {   printf( "%12s => %-60s\n", $par, "[array]" );   }
BNGAction.pm:981:        {   printf( "%12s => %-60s\n", $par, "{hash}" );   }
BNGAction.pm:983:        {   printf( "%12s => %-60s\n", $par, $val );   }
BNGAction.pm:990:    my $prefix = ( defined $options->{prefix} ) ? $options->{prefix} : $model->getOutputPrefix() .'_'. $options->{suffix};
BNGAction.pm:991:    my $modelname = $model->Name .'_'. $options->{suffix};
BNGAction.pm:994:    if ( -e $modelfile )
BNGAction.pm:996:        if ($options->{overwrite})
BNGAction.pm:1010:    unless ( defined $model->ParamList )
BNGAction.pm:1011:    {   return sprintf "Cannot continue! Model %s does not have a parameter list.", $model->Name;   }
BNGAction.pm:1014:    unless ( defined $model->MoleculeTypesList  and  %{$model->MoleculeTypesList->MolTypes} )
BNGAction.pm:1015:    {   return sprintf "Nothing to do! Model %s has zero molecule type definitions.", $model->Name;   }     
BNGAction.pm:1018:    unless ( defined $model->SpeciesList  and  @{$model->SpeciesList->Array} )
BNGAction.pm:1019:    {   return sprintf "Nothing to do! Model %s has zero seed species definitions.", $model->Name;   }
BNGAction.pm:1022:    unless ( defined $model->RxnRules  and  @{$model->RxnRules} )
BNGAction.pm:1023:    {   return sprintf "Nothing to do! Model %s has zero reaction rule definitions.", $model->Name;   } 
BNGAction.pm:1026:    unless ( defined $model->PopulationTypesList  and  %{$model->PopulationTypesList->MolTypes} )
BNGAction.pm:1027:    {   return sprintf "Nothing to do! Model %s has zero population type definitions.", $model->Name;   }
BNGAction.pm:1030:    unless ( defined $model->PopulationList  and  @{$model->PopulationList->List} )
BNGAction.pm:1031:    {   return sprintf "Nothing to do! Model %s has zero population map definitions.", $model->Name;   }
BNGAction.pm:1037:    $hybrid_model->Name( $modelname );
BNGAction.pm:1038:    $hybrid_model->Version( $model->Version );
BNGAction.pm:1039:    $hybrid_model->SubstanceUnits( $model->SubstanceUnits );
BNGAction.pm:1042:    %{$hybrid_model->Options} = %{$model->Options};
BNGAction.pm:1044:    $hybrid_model->Options->{prefix} = $prefix;
BNGAction.pm:1049:    my $plist_new = $model->ParamList->copyConstant();
BNGAction.pm:1050:    $hybrid_model->ParamList( $plist_new );
BNGAction.pm:1051:    print sprintf "found %d constants and expressions.\n", scalar @{$plist_new->Array};
BNGAction.pm:1056:    if ( defined $model->CompartmentList )
BNGAction.pm:1059:        $clist_new = $model->CompartmentList->copy( $plist_new );
BNGAction.pm:1060:        $hybrid_model->CompartmentList( $clist_new );
BNGAction.pm:1061:        print $indent . sprintf "found %d compartments.\n", scalar @{$clist_new->Array};
BNGAction.pm:1062:        send_warning( "generate_hybrid_model() does not support compartments at this time" ) if (@{$clist_new->Array});  
BNGAction.pm:1069:    my $mtlist_new =  $model->MoleculeTypesList->copy();
BNGAction.pm:1070:    $hybrid_model->MoleculeTypesList( $mtlist_new );
BNGAction.pm:1071:    print sprintf "found %d molecule types.\n", scalar keys %{$mtlist_new->MolTypes};
BNGAction.pm:1075:        while ( my ($name,$mt) = each %{$model->PopulationTypesList->MolTypes} )
BNGAction.pm:1077:            my $mt_copy = $mt->copy();
BNGAction.pm:1078:            $mt_copy->PopulationType(1);
BNGAction.pm:1079:            unless ( $mtlist_new->add($mt_copy) )
BNGAction.pm:1082:        print sprintf "found %d population types.\n", scalar keys %{$model->PopulationTypesList->MolTypes};
BNGAction.pm:1088:    $hybrid_model->SpeciesList( $slist_new );   
BNGAction.pm:1093:        foreach my $species ( @{$model->SpeciesList->Array} )
BNGAction.pm:1095:            my $sg   = $species->SpeciesGraph;
BNGAction.pm:1096:            my $conc = $species->Concentration;
BNGAction.pm:1100:            foreach my $pop ( @{$model->PopulationList->List} )
BNGAction.pm:1102:                if ( SpeciesGraph::isomorphicTo($species->SpeciesGraph, $pop->SpeciesGraph) )
BNGAction.pm:1104:                    my $sg_copy = $pop->Population->copy();
BNGAction.pm:1105:                    $sg_copy->relinkCompartments( $hybrid_model->CompartmentList );
BNGAction.pm:1106:                    $slist_new->add( $sg_copy, $species->Concentration );
BNGAction.pm:1108:                    if ( $options->{verbose} )
BNGAction.pm:1111:                            . sprintf "replaced species %s with population %s.\n", $sg->toString(), $sg_copy->toString();
BNGAction.pm:1118:                my $sg_copy = $species->SpeciesGraph->copy();
BNGAction.pm:1119:                $sg_copy->relinkCompartments( $hybrid_model->CompartmentList );
BNGAction.pm:1120:                $slist_new->add( $sg_copy, $species->Concentration );
BNGAction.pm:1123:        print $indent . sprintf "  ..found %d seed species.\n", scalar @{$slist_new->Array};    
BNGAction.pm:1131:        foreach my $pop ( @{$model->PopulationList->List} )
BNGAction.pm:1133:            my ($sp) = $slist_new->lookup( $pop->Population );
BNGAction.pm:1136:                my $sg_copy = $pop->Population->copy();
BNGAction.pm:1137:                $sg_copy->relinkCompartments( $hybrid_model->CompartmentList );  
BNGAction.pm:1138:                $slist_new->add( $sg_copy, 0 );
BNGAction.pm:1148:    $hybrid_model->Observables( $obslist_new );
BNGAction.pm:1152:        foreach my $obs ( @{$model->Observables} )
BNGAction.pm:1154:            my $obs_copy = $obs->copy();
BNGAction.pm:1155:            $obs_copy->relinkCompartments( $hybrid_model->CompartmentList );
BNGAction.pm:1159:            if ( $plist_new->set( $obs_copy->Name, '0', 1, "Observable", $obs_copy) )
BNGAction.pm:1161:                  my $name = $obs_copy->Name;
BNGAction.pm:1167:            foreach my $pop ( @{$model->PopulationList->List} )
BNGAction.pm:1169:                my $matches = $obs_copy->match( $pop->SpeciesGraph );
BNGAction.pm:1176:                        push @add_patterns, $pop->Population->copy()->relinkCompartments( $hybrid_model->CompartmentList );
BNGAction.pm:1179:                    if ( $options->{verbose} )
BNGAction.pm:1182:                                                        $obs_copy->Name, $matches, ($matches>1 ? 'es' : ''), $pop->Population->toString();
BNGAction.pm:1186:            push @{$obs_copy->Patterns}, @add_patterns;      
BNGAction.pm:1195:        my $fcn_copies = $model->ParamList->copyFunctions();
BNGAction.pm:1198:            $hybrid_model->ParamList->set( $fcn->Name, $fcn->Expr, 0, 'Function', $fcn );
BNGAction.pm:1206:    $hybrid_model->RxnRules( $rxnrules_new );
BNGAction.pm:1212:        foreach my $pop ( @{$model->PopulationList->List} )
BNGAction.pm:1213:        {   push @$pop_species, $pop->SpeciesGraph;   }
BNGAction.pm:1218:        foreach my $rset ( @{$model->RxnRules} )
BNGAction.pm:1226:                my $rr_copy = $rr->copy();
BNGAction.pm:1227:                $rr_copy->resetLabels();
BNGAction.pm:1230:                my $child_rule_list = $rr_copy->expandRule(  $pop_species, $model, $hybrid_model, $options );
BNGAction.pm:1235:                if ( $options->{verbose} )
BNGAction.pm:1238:                                                    $rr_copy->Name, scalar @$child_rule_list, ((scalar @$child_rule_list > 1)?'s':'');
BNGAction.pm:1250:        foreach my $pop ( @{$model->PopulationList->List} )
BNGAction.pm:1253:            my $rr_string = $pop->MappingRule->toString();
BNGAction.pm:1260:        print sprintf "found %d maps.\n", scalar @{$model->PopulationList->List};
BNGAction.pm:1267:    $hybrid_model->RxnList( $rxnlist_new );
BNGAction.pm:1274:    print $FH $hybrid_model->writeBNGL( {'format'=>'bngl', 'include_model'=>1,'include_network'=>0,
BNGAction.pm:1277:    if ( @{$options->{actions}} )
BNGAction.pm:1280:        foreach my $action ( @{$options->{actions}} )
BNGAction.pm:1293:    if ( $options->{execute} )
BNGAction.pm:1297:        foreach my $action ( @{$options->{actions}} )
BNGAction.pm:1299:            my $action_string = "\$hybrid_model->$action";
BNGAction.pm:1325:    my $default_params = {  'prefix'   => $model->getOutputPrefix(),
BNGAction.pm:1332:        unless ( defined $params->{$key} )
BNGAction.pm:1333:        {   $params->{$key} = $val;   }
BNGAction.pm:1337:    unless ( defined $params->{parameter} )
BNGAction.pm:1340:    unless ( defined $params->{par_min} )
BNGAction.pm:1343:    unless ( defined $params->{par_max} )
BNGAction.pm:1346:    unless ( defined $params->{n_scan_pts} )
BNGAction.pm:1352:           $params->{parameter}, $params->{par_min}, $params->{par_max}, $params->{n_scan_pts}, $params->{log_scale};
BNGAction.pm:1356:    my $basename = $params->{prefix};
BNGAction.pm:1357:    if ( $params->{suffix} )
BNGAction.pm:1358:    {   $basename .= "_" . $params->{suffix};   }
BNGAction.pm:1360:    {   $basename .= "_" . $params->{parameter};      }
BNGAction.pm:1369:    if (-d $workdir)
BNGAction.pm:1371:        my $all_files = File::Spec->catfile( ($workdir), '*' );
BNGAction.pm:1373:        #system "rm -r $workdir";
BNGAction.pm:1380:    my $par_min = $params->{log_scale} ? log $params->{par_min} : $params->{par_min};
BNGAction.pm:1381:    my $par_max = $params->{log_scale} ? log $params->{par_max} : $params->{par_max};
BNGAction.pm:1384:    	if ($params->{n_scan_pts} < 1){
BNGAction.pm:1389:    elsif ($params->{n_scan_pts} <= 1){
BNGAction.pm:1393:    	$delta = ($par_max - $par_min) / ($params->{n_scan_pts} - 1); # note that this may be negative if par_max < par_min (not a problem)
BNGAction.pm:1398:    $model->saveConcentrations();
BNGAction.pm:1401:    for ( my $k = 0;  $k < $params->{n_scan_pts};  ++$k )
BNGAction.pm:1405:        if ( $params->{log_scale} )
BNGAction.pm:1409:        $model->setParameter( $params->{parameter}, $par_value );
BNGAction.pm:1412:        my $local_prefix = File::Spec->catfile( ($workdir), sprintf("par_%s_%05d", $params->{parameter}, $k+1) );
BNGAction.pm:1415:        $model->resetConcentrations();
BNGAction.pm:1420:        $local_params->{prefix} = $local_prefix;
BNGAction.pm:1421:        delete $local_params->{suffix};
BNGAction.pm:1424:        my $err = $model->simulate( $local_params );
BNGAction.pm:1433:    $model->resetConcentrations();
BNGAction.pm:1441:    for ( my $k = 0;  $k < $params->{n_scan_pts};  ++$k )
BNGAction.pm:1444:        if ( $params->{log_scale} )
BNGAction.pm:1448:        my $data_file = File::Spec->catfile( ($workdir), sprintf("par_%s_%05d.gdat", $params->{parameter}, $k+1) );
BNGAction.pm:1461:            printf $ofh "# %+14s", $params->{parameter};
BNGAction.pm:1535:    #atol:  absolute tolerance for simulate_ode; real; 1e-8
BNGAction.pm:1536:    #rtol:  relative tolerance for simulate_ode; real; 1e-8
BNGAction.pm:1553:    my $basemodel = BNGModel->new();
BNGAction.pm:1564:    my $newbumpmodel = BNGModel->new();
BNGAction.pm:1574:    if ( defined( $params->{net_file} ) ) {
BNGAction.pm:1575:        $net_file = $params->{net_file};
BNGAction.pm:1578:        $net_file = $model->getOutputPrefix();
BNGAction.pm:1580:    if ( defined( $params->{t_end} ) ) {
BNGAction.pm:1581:        $t_end = $params->{t_end};
BNGAction.pm:1588:    my $bump     = ( defined( $params->{bump} ) )     ? $params->{bump}     : 5;
BNGAction.pm:1589:    my $stochast = ( defined( $params->{stochast} ) ) ? $params->{stochast} : 0;
BNGAction.pm:1590:    my $sparse   = ( defined( $params->{sparse} ) )   ? $params->{sparse}   : 1;
BNGAction.pm:1591:    my $atol = ( defined( $params->{atol} ) ) ? $params->{atol} : 1e-8;
BNGAction.pm:1592:    my $rtol = ( defined( $params->{rtol} ) ) ? $params->{rtol} : 1e-8;
BNGAction.pm:1594:      ( defined( $params->{init_equil} ) ) ? $params->{init_equil} : 1;
BNGAction.pm:1595:    my $t_equil = ( defined( $params->{t_equil} ) ) ? $params->{t_equil} : 1e6;
BNGAction.pm:1596:    my $re_equil = ( defined( $params->{re_equil} ) ) ? $params->{re_equil} : 1;
BNGAction.pm:1597:    my $n_steps = ( defined( $params->{n_steps} ) ) ? $params->{n_steps} : 50;
BNGAction.pm:1598:    my $suffix  = ( defined( $params->{suffix} ) )  ? $params->{suffix}  : "";
BNGAction.pm:1602:    $basemodel->readFile( \%readFileinputs );
BNGAction.pm:1616:        $basemodel->simulate_ode( \%simodeinputs );
BNGAction.pm:1630:    if ( defined( $params->{inp_ppert} ) ) {
BNGAction.pm:1631:        $pperts      = $params->{inp_ppert};
BNGAction.pm:1632:        $pert_names  = $pperts->{pnames};
BNGAction.pm:1633:        $pert_values = $pperts->{pvalues};
BNGAction.pm:1635:        while ( $pert_names->[$i] ) {
BNGAction.pm:1636:            $param_name  = $pert_names->[$i];
BNGAction.pm:1637:            $param_value = $pert_values->[$i];
BNGAction.pm:1638:            $basemodel->setParameter( $param_name, $param_value );
BNGAction.pm:1642:    if ( defined( $params->{inp_cpert} ) ) {
BNGAction.pm:1643:        $cperts      = $params->{inp_cpert};
BNGAction.pm:1644:        $pert_names  = $cperts->{cnames};
BNGAction.pm:1645:        $pert_values = $cperts->{cvalues};
BNGAction.pm:1647:        while ( $pert_names->[$i] ) {
BNGAction.pm:1648:            $param_name  = $pert_names->[$i];
BNGAction.pm:1649:            $param_value = $pert_values->[$i];
BNGAction.pm:1650:            $basemodel->setConcentration( $param_name, $param_value );
BNGAction.pm:1654:    $basemodel->simulate_ode( \%simodeinputs );
BNGAction.pm:1656:    $plist = $basemodel->ParamList;
BNGAction.pm:1659:    foreach my $model_param ( @{ $plist->Array } )
BNGAction.pm:1661:        $param_name      = $model_param->Name;
BNGAction.pm:1662:        $param_value     = $model_param->evaluate();
BNGAction.pm:1666:        $newbumpmodel->readFile( \%readFileinputs );
BNGAction.pm:1667:        $newbumpmodel->setParameter( $param_name, $new_param_value );
BNGAction.pm:1680:            $newbumpmodel->simulate_ode( \%simodeinputs );
BNGAction.pm:1694:        if ( defined( $params->{inp_ppert} ) ) {
BNGAction.pm:1695:            $pperts      = $params->{inp_ppert};
BNGAction.pm:1696:            $pert_names  = $pperts->{pnames};
BNGAction.pm:1697:            $pert_values = $pperts->{pvalues};
BNGAction.pm:1699:            while ( $pert_names->[$i] ) {
BNGAction.pm:1700:                $param_name  = $pert_names->[$i];
BNGAction.pm:1701:                $param_value = $pert_values->[$i];
BNGAction.pm:1702:                $newbumpmodel->setParameter( $param_name, $param_value );
BNGAction.pm:1706:        if ( defined( $params->{inp_cpert} ) ) {
BNGAction.pm:1707:            $cperts      = $params->{inp_cpert};
BNGAction.pm:1708:            $pert_names  = $cperts->{cnames};
BNGAction.pm:1709:            $pert_values = $cperts->{cvalues};
BNGAction.pm:1711:            while ( $pert_names->[$i] ) {
BNGAction.pm:1712:                $param_name  = $pert_names->[$i];
BNGAction.pm:1713:                $param_value = $pert_values->[$i];
BNGAction.pm:1714:                $newbumpmodel->setConcentration( $param_name, $param_value );
BNGAction.pm:1718:        $newbumpmodel->simulate_ode( \%simodeinputs );
BNGAction.pm:1723:        $newbumpmodel = BNGModel->new();
BNGMessages.pm:42:	print STDOUT $msg unless ($main::options->config->{silent});
BNGModel.pm:3:#    BioNetGen : rule-based modeling language and simulation platform
BNGModel.pm:42:# BNGOutput contains BNGModel methods related to third-party output
BNGModel.pm:73:my $HAVE_PS = 0;  # Set to 0 for MS Windows systems with no ps command - disables
BNGModel.pm:89:    EnergyPatterns      => '@',  # energyBNG: Holds a list of energy patterns  --Justin
BNGModel.pm:95:    Version             => '@',  # Indicates set of version requirements- output to BNGL and NET files
BNGModel.pm:97:    Params              => '%',  # run-time parameters (not to be saved)
BNGModel.pm:115:    $model->ParamList( ParamList->new() );
BNGModel.pm:116:    $model->MoleculeTypesList( MoleculeTypesList->new('StrictTyping'=>0) );
BNGModel.pm:117:    $model->PopulationTypesList( MoleculeTypesList->new('StrictTyping'=>0) );
BNGModel.pm:118:    $model->PopulationList( PopulationList->new() );
BNGModel.pm:119:    $model->CompartmentList( CompartmentList->new('Used'=>0) );
BNGModel.pm:120:    $model->SpeciesList( SpeciesList->new() );
BNGModel.pm:121:    $model->RxnList( RxnList->new('SpeciesList'=>$model->SpeciesList) );
BNGModel.pm:122:    $model->SubstanceUnits("Number");
BNGModel.pm:123:    $model->ConcentrationCache( Cache->new() );
BNGModel.pm:124:    $model->ParameterCache( Cache->new() );
BNGModel.pm:141:# $err = $model->readModel({file=>FILENAME}) 
BNGModel.pm:158:    return $model->readFile( \%params );
BNGModel.pm:163:# $err = $model->readModel({file=>FILENAME}) 
BNGModel.pm:180:    return $model->readFile( \%params );
BNGModel.pm:191:# 2.  Check syntax of lines- this is currently done when parameter is
BNGModel.pm:200:    my $level = -1;
BNGModel.pm:232:        my $filename = defined $params->{file} ? $params->{file} : undef;
BNGModel.pm:247:            $model->initialize();
BNGModel.pm:250:            $model->UpdateNet(1);
BNGModel.pm:253:            if ( $params->{basename} )
BNGModel.pm:255:                $model->Name( $params->{basename} );
BNGModel.pm:259:                my ($vol, $dir, $fn) = File::Spec->splitpath( $filename );  
BNGModel.pm:272:                $model->Name( $basename );  
BNGModel.pm:276:            $model->Params( $params );
BNGModel.pm:279:            unless ( defined $model->Params->{output_dir} )
BNGModel.pm:281:                $model->setOutputDir();
BNGModel.pm:285:            if ( $model->Params->{logging} )
BNGModel.pm:288:                my $logfilename = $model->getOutputPrefix() . ".log" ;
BNGModel.pm:349:            # Process multi-line block
BNGModel.pm:378:                    my $plast = $model->ParamList->getNumParams();
BNGModel.pm:383:                        $err = $model->ParamList->readString($entry);
BNGModel.pm:387:                    if ( $err = $model->ParamList->check() )
BNGModel.pm:393:                    if ( $err = $model->ParamList->sort() )    
BNGModel.pm:399:                    printf "Read %d $name.\n", $model->ParamList->getNumParams() - $plast;
BNGModel.pm:412:                        my $fun = Function->new();
BNGModel.pm:413:                        $err = $fun->readString( $entry, $model );
BNGModel.pm:420:                    if ( $err = $model->ParamList->check() )
BNGModel.pm:436:                    $model->MoleculeTypesList->StrictTyping(1);
BNGModel.pm:440:                        $err = $model->MoleculeTypesList->readString($entry);
BNGModel.pm:444:                    printf "Read %d molecule types.\n", $model->MoleculeTypesList->getNumMolTypes();
BNGModel.pm:452:                    $model->PopulationTypesList->StrictTyping(1);
BNGModel.pm:456:                        $err = $model->PopulationTypesList->readString($entry);
BNGModel.pm:460:                    printf "Read %d population types.\n", $model->PopulationTypesList->getNumMolTypes();
BNGModel.pm:467:                    unless ( $model->MoleculeTypesList->StrictTyping )
BNGModel.pm:476:                        $err = $model->PopulationList->readString($entry,$model);
BNGModel.pm:480:                    printf "Read %d population maps.\n", $model->PopulationList->getNumPopulations;
BNGModel.pm:488:                    $model->CompartmentList->Used(1);
BNGModel.pm:495:                        $err = $model->CompartmentList->readString( $entry, $model->ParamList );
BNGModel.pm:499:                    if ( $err = $model->CompartmentList->validate() )
BNGModel.pm:505:                    printf "Read %d compartments.\n", $model->CompartmentList->getNumCompartments;
BNGModel.pm:516:                        $err = $model->SpeciesList->readString( $entry, $model->ParamList,
BNGModel.pm:517:                                                                $model->CompartmentList,
BNGModel.pm:518:                                                                $model->MoleculeTypesList );
BNGModel.pm:522:                    printf "Read %d species.\n", $model->SpeciesList->getNumSpecies();
BNGModel.pm:532:                    $model->RxnRules( $rrules );
BNGModel.pm:547:                            unless ( $rrs->[0]->Name )
BNGModel.pm:548:                            {   $rrs->[0]->Name( 'Rule' . scalar @$rrules );   }
BNGModel.pm:551:                                unless ($rrs->[1]->Name)
BNGModel.pm:552:                                {   $rrs->[1]->Name( 'Rule' . scalar @$rrules . 'r' );   }
BNGModel.pm:562:                    printf "Read %d reaction rule(s).\n", scalar @{$model->RxnRules};
BNGModel.pm:570:                    my $rlist = RxnList->new;
BNGModel.pm:574:                        $err = $rlist->readString( $entry,
BNGModel.pm:575:                                                   $model->SpeciesList,
BNGModel.pm:576:                                                   $model->ParamList    );
BNGModel.pm:580:                    $model->RxnList($rlist);
BNGModel.pm:588:                    if ( @{$model->Observables} )
BNGModel.pm:601:                            if ( $iobs >= @{$model->Observables} )
BNGModel.pm:608:                            my $obs = $model->Observables->[$iobs];
BNGModel.pm:612:                            unless ( $group_name eq $obs->Name )
BNGModel.pm:622:                            @{$obs->Weights} = (0) x scalar @{$obs->Weights};
BNGModel.pm:641:                                $obs->Weights->[$species_idx] += $weight;
BNGModel.pm:651:                        my $n_species = $model->SpeciesList->getNumSpecies();
BNGModel.pm:673:                            my $obs = Observable->new( Name=>$group_name, Patterns=>[], Weights=>[], Type=>"Molecule", Output=>1 );
BNGModel.pm:674:                            push @{$model->Observables}, $obs;
BNGModel.pm:677:                            if ( $model->ParamList->set( $obs->Name, "0", 1, "Observable", $obs) )
BNGModel.pm:679:                          	    my $name = $obs->Name;
BNGModel.pm:688:                            @{$obs->Weights} = (0) x ($n_species+1);
BNGModel.pm:707:                                $obs->Weights->[$species_idx] += $weight;
BNGModel.pm:725:                        my $obs = Observable->new();
BNGModel.pm:726:                        $err = $obs->readString($entry, $model);
BNGModel.pm:732:                        push @{$model->Observables}, $obs;
BNGModel.pm:737:                    if ( $err = $model->ParamList->check() )
BNGModel.pm:745:                    printf "Read %d observable(s).\n", scalar @{$model->Observables};
BNGModel.pm:753:                    unless ( $model->Options->{energyBNG}  )
BNGModel.pm:762:                        my $epatt = EnergyPattern->new();
BNGModel.pm:763:                        $err = $epatt->readString( $entry, $model );
BNGModel.pm:765:                        push @{$model->EnergyPatterns}, $epatt;
BNGModel.pm:768:                    printf "Read %d energy patterns(s).\n", scalar @{$model->EnergyPatterns};  
BNGModel.pm:776:                    unless ($model->Params->{allow_actions})
BNGModel.pm:778:                        unless ($model->Params->{action_skip_warn})
BNGModel.pm:804:                        # Perform self-consistency checks before operations are performed on model
BNGModel.pm:805:                        if ( $err = $model->ParamList->check() )
BNGModel.pm:812:                        my $command = '$model->' . $action . '(' . $options . ');';
BNGModel.pm:820:                        my $t_interval = cpu_time(0) - $t_start;
BNGModel.pm:841:                # Perform self-consistency checks before operations are performed on model
BNGModel.pm:842:                if ( $err = $model->ParamList->check() )
BNGModel.pm:846:                my $command = '$model->' . $action . '(' . $options . ');';
BNGModel.pm:860:                $err = $model->ParamList->readString($string);
BNGModel.pm:869:                unless ($model->Params->{allow_actions})
BNGModel.pm:871:                    unless ($model->Params->{action_skip_warn})
BNGModel.pm:876:                # Perform self-consistency checks before operations are performed on model
BNGModel.pm:877:                if ( $err = $model->ParamList->check() )
BNGModel.pm:884:                my $command = '$model->' . $action . '(' . $options . ');';
BNGModel.pm:889:                my $t_interval = cpu_time(0) - $t_start;
BNGModel.pm:897:                if ( $model->Params->{allow_perl} )
BNGModel.pm:918:                if ( $model->Params->{write_xml} )
BNGModel.pm:919:                {  $model->writeXML();   }
BNGModel.pm:921:                if ( $model->Params->{generate_network} )
BNGModel.pm:922:                {  $model->generate_network( {overwrite=>1} );  }
BNGModel.pm:924:                if ( $model->Params->{write_mfile} )
BNGModel.pm:925:                {  $model->writeMfile();  }
BNGModel.pm:927:                if ( $model->Params->{write_sbml} )
BNGModel.pm:928:                {  $model->writeSBML();   }
BNGModel.pm:935:                printf "CPU TIME: total %.1f s.\n", cpu_time(0) - $t_start;
BNGModel.pm:937:                if ($params->{logging})
BNGModel.pm:955:        --$level;
BNGModel.pm:1057:# $err = $model->writeModel({opt=>val,..}) 
BNGModel.pm:1080:    return $model->writeFile( \%params );
BNGModel.pm:1085:# $err = $model->writeNetwork({opt=>val,..}) 
BNGModel.pm:1108:    return $model->writeFile( \%params );
BNGModel.pm:1136:    return $model->writeFile( \%params );
BNGModel.pm:1143:# $err = $model->writeFile({OPT=>VAL,..})
BNGModel.pm:1173:        'prefix'               => $model->getOutputPrefix(),
BNGModel.pm:1207:        if ( @{$model->RxnList->Array} == 0 )
BNGModel.pm:1225:    if ( -e $file )
BNGModel.pm:1248:        $file_string = $model->writeBNGL( \%params );
BNGModel.pm:1252:        $file_string = $model->writeBNGL( \%params );
BNGModel.pm:1256:        $file_string = $model->toXML( \%params );
BNGModel.pm:1310:    foreach my $vstring ( @{$model->Version} )
BNGModel.pm:1314:    while ( my ($opt,$val) = each %{$model->Options} )
BNGModel.pm:1322:    $out .= sprintf "substanceUnits(\"%s\")\n", $model->SubstanceUnits;
BNGModel.pm:1328:    $out .= $model->ParamList->writeBNGL( \%params );
BNGModel.pm:1334:        if ( defined $model->CompartmentList  and  @{$model->CompartmentList->Array} )
BNGModel.pm:1335:        {   $out .= $model->CompartmentList->toString( $model->ParamList );   }
BNGModel.pm:1338:        if ( $model->MoleculeTypesList->StrictTyping )
BNGModel.pm:1339:        {   $out .= $model->MoleculeTypesList->writeBNGL( \%params );   }
BNGModel.pm:1342:        if ( @{$model->Observables} )
BNGModel.pm:1346:            foreach my $obs ( @{$model->Observables} )
BNGModel.pm:1348:                $max_length = ( length $obs->Name > $max_length ) ? length $obs->Name : $max_length;
BNGModel.pm:1353:            foreach my $obs ( @{$model->Observables} )
BNGModel.pm:1357:                    $out .= sprintf "  %s\n", $obs->toString($max_length);
BNGModel.pm:1361:                    $out .= sprintf "%5d %s\n", $io, $obs->toString();
BNGModel.pm:1369:        if ( @{$model->EnergyPatterns} )
BNGModel.pm:1373:            foreach my $epatt ( @{ $model->EnergyPatterns } )
BNGModel.pm:1377:                    $out .=  sprintf "  %s\n", $epatt->toString($model->ParamList);
BNGModel.pm:1381:                    $out .=  sprintf "%5d %s\n", $io, $epatt->toString($model->ParamList);
BNGModel.pm:1391:    $out .= $model->ParamList->writeFunctions( \%params );
BNGModel.pm:1394:    $out .= $model->SpeciesList->writeBNGL( $model->Concentrations, $model->ParamList, \%params );
BNGModel.pm:1404:            foreach my $rset ( @{$model->RxnRules} )
BNGModel.pm:1406:                my $rreverse = ( @$rset > 1 ) ? $rset->[1] : undef;
BNGModel.pm:1409:                $out .= sprintf "  %s\n", $rset->[0]->toString($rreverse);
BNGModel.pm:1418:                    $out .= $rset->[0]->listActions();
BNGModel.pm:1422:                        $out .= $rset->[1]->listActions();
BNGModel.pm:1437:        $out .= $model->RxnList->writeBNGL( \%params, $model->ParamList );
BNGModel.pm:1440:        if ( @{$model->Observables} )
BNGModel.pm:1444:            foreach my $obs ( @{$model->Observables} )
BNGModel.pm:1446:                $out .= sprintf "%5d %s\n", $io, $obs->toGroupString( $model->SpeciesList );
BNGModel.pm:1487:            if ( $model->SeedSpeciesList ) {
BNGModel.pm:1491:            $model->Options->{$arg} = $val;
BNGModel.pm:1495:            if ( scalar @{$model->RxnRules} )
BNGModel.pm:1497:            $model->Options->{$arg} = $val;
BNGModel.pm:1525:    $model->SubstanceUnits($ucommand);
BNGModel.pm:1536:    my $err = $model->CompartmentList->setVolume( $compartment_name, $value );
BNGModel.pm:1556:    my $plist = $model->ParamList;
BNGModel.pm:1560:    ( $param, $err ) = $plist->lookup($pname);
BNGModel.pm:1564:    my $expr    = Expression->new();
BNGModel.pm:1566:    if ( $err = $expr->readString( \$estring, $plist ) ) { return $err; }
BNGModel.pm:1569:    $model->UpdateNet(1);
BNGModel.pm:1571:    printf "Set parameter %s to value %s\n", $pname, $expr->evaluate($plist);
BNGModel.pm:1585:    # copy paramList (exclude non-constant types)
BNGModel.pm:1586:    my $paramlist = $model->ParamList->copyConstant();
BNGModel.pm:1589:    $model->ParameterCache->cache($paramlist,$label);
BNGModel.pm:1605:    my $saved_paramlist = $model->ParameterCache->browse($label);
BNGModel.pm:1615:    foreach my $param ( @{$saved_paramlist->Array} )
BNGModel.pm:1617:        $err = $model->ParamList->add( $param );
BNGModel.pm:1622:    $model->UpdateNet(1);
BNGModel.pm:1648:    my $plist = $model->ParamList;
BNGModel.pm:1652:    my $sg = SpeciesGraph->new;
BNGModel.pm:1653:    $err = $sg->readString( \$sname, $model->CompartmentList, 1, '', $model->MoleculeTypesList );
BNGModel.pm:1661:    unless ( $spec = $model->SpeciesList->lookup($sg) )
BNGModel.pm:1663:        $err = sprintf "Species %s not found in SpeciesList", $sg->toString();
BNGModel.pm:1668:    my $expr    = Expression->new();
BNGModel.pm:1670:    if ( my $err = $expr->readString( \$estring, $plist ) )
BNGModel.pm:1674:    my $conc = $expr->evaluate($plist);
BNGModel.pm:1677:    $model->SpeciesList->checkOrInitConcentrations( $model->Concentrations );
BNGModel.pm:1680:    $model->Concentrations->[$spec->Index - 1] = $conc;
BNGModel.pm:1683:    $model->UpdateNet(1);
BNGModel.pm:1685:    printf "Set concentration of species %s to value %s\n", $spec->SpeciesGraph->StringExact, $conc;
BNGModel.pm:1700:    my $plist = $model->ParamList;
BNGModel.pm:1704:    my $sg = SpeciesGraph->new;
BNGModel.pm:1705:    $err = $sg->readString( \$sname, $model->CompartmentList, 1, '', $model->MoleculeTypesList );
BNGModel.pm:1713:    unless ( $spec = $model->SpeciesList->lookup($sg) )
BNGModel.pm:1715:        $err = sprintf "Species %s not found in SpeciesList", $sg->toString();
BNGModel.pm:1720:    my $expr    = Expression->new();
BNGModel.pm:1722:    if ( my $err = $expr->readString( \$estring, $plist ) )
BNGModel.pm:1726:    my $add_conc = $expr->evaluate($plist);
BNGModel.pm:1729:    $model->SpeciesList->checkOrInitConcentrations( $model->Concentrations );
BNGModel.pm:1732:    my $orig_conc = $model->Concentrations->[$spec->Index - 1];
BNGModel.pm:1735:        $orig_conc = $plist->evaluate($spec->Concentration);
BNGModel.pm:1740:    $model->Concentrations->[$spec->Index - 1] = $conc;
BNGModel.pm:1743:    $model->UpdateNet(1);
BNGModel.pm:1746:         $add_conc, $spec->SpeciesGraph->StringExact, $conc;
BNGModel.pm:1762:    if (@{$model->Concentrations})
BNGModel.pm:1764:        @$conc = @{$model->Concentrations};
BNGModel.pm:1768:        @$conc = map {$_->Concentration} @{$model->SpeciesList->Array};
BNGModel.pm:1771:    $model->ConcentrationCache->cache($conc,$label);
BNGModel.pm:1787:    my $saved_conc = $model->ConcentrationCache->browse($label);
BNGModel.pm:1798:            @$conc = map {$_->Concentration} @{$model->SpeciesList->Array};
BNGModel.pm:1810:    if ( @$conc > @{$model->SpeciesList->Array} )
BNGModel.pm:1811:    {   # this case is not well-defined
BNGModel.pm:1814:    elsif ( @$conc < @{$model->SpeciesList->Array} )
BNGModel.pm:1816:        my $n_zeros = @{$model->SpeciesList->Array} - @$conc;
BNGModel.pm:1821:    $model->Concentrations($conc);
BNGModel.pm:1823:    $model->UpdateNet(1);
BNGModel.pm:1842:    $model->Name($name);
BNGModel.pm:1855:# string = major[.minor][.dist][+-]
BNGModel.pm:1860:# - indicates version should be the specified version or earlier
BNGModel.pm:1874:    my ($version, $relation, $codename) = ( $vstring =~ /^(\d+\.\d+\.\d+)([+-]?)\s*(\w*)/ );
BNGModel.pm:1892:    # compare versions (returns -1 if version < bng_version)
BNGModel.pm:1900:    elsif ( $relation eq '-'  and  $comp == -1 )
BNGModel.pm:1918:    push @{$model->Version}, $vstring;
BNGModel.pm:1955:    push @{$model->Codename}, $codename;
BNGModel.pm:1990:# re-commence after equilibration is performed if spec_nonequil has
BNGModel.pm:2005:        'prefix'       => $model->getOutputPrefix(),
BNGModel.pm:2043:    if ( -e "$prefix.net"  and  -e "$prefix.bngl" )
BNGModel.pm:2050:        elsif ( -M "$prefix.net" < -M "$prefix.bngl" )
BNGModel.pm:2053:            my $err = $model->readFile( {file => "$prefix.net"} );
BNGModel.pm:2064:    if ( $model->SpeciesList->size() == 0 )
BNGModel.pm:2069:    if ( @{$model->RxnRules} == 0 )
BNGModel.pm:2074:    if ( $model->RxnList->size()==0 or $params{continue}==0 )
BNGModel.pm:2077:        foreach my $rset ( @{$model->RxnRules} )
BNGModel.pm:2080:            {   $rr->initializeRule();   }
BNGModel.pm:2084:        foreach my $obs ( @{$model->Observables} )
BNGModel.pm:2086:            $obs->reset_weights( $model->SpeciesList->size() );
BNGModel.pm:2087:            $obs->update( $model->SpeciesList->Array );
BNGModel.pm:2091:        foreach my $spec ( @{$model->SpeciesList->Array} )
BNGModel.pm:2092:        {   $spec->ObservablesApplied(1);   }
BNGModel.pm:2095:        if ( $model->Options->{energyBNG} )
BNGModel.pm:2097:            foreach my $epatt ( @{$model->EnergyPatterns} )
BNGModel.pm:2099:                $epatt->reset_weights($model->SpeciesList->size());
BNGModel.pm:2100:                $epatt->update($model->SpeciesList->Array);
BNGModel.pm:2114:    report_iter( 0, $model->SpeciesList->size(), $model->RxnList->size() );
BNGModel.pm:2120:        my @species = @{$model->SpeciesList->Array};
BNGModel.pm:2126:        # NOTE: each element of @{$model->RxnRules} is an array of reactions.
BNGModel.pm:2129:        foreach my $rset ( @{$model->RxnRules} )
BNGModel.pm:2145:                my ($err, $nr) = $rr->expand_rule( \@species, $model, $params_expand_rule );
BNGModel.pm:2152:            my $time = cpu_time(0) - $t_off;
BNGModel.pm:2165:        {   $spec->RulesApplied($niter) unless ( $spec->RulesApplied );   }
BNGModel.pm:2168:        report_iter( $niter, $model->SpeciesList->size(), $model->RxnList->size(), $t_start_iter );
BNGModel.pm:2171:        $model->RxnList->resetHash;
BNGModel.pm:2174:        last if ( $model->SpeciesList->size() == scalar @species );
BNGModel.pm:2179:            $params_writeNET->{prefix} = "${prefix}_${niter}";
BNGModel.pm:2180:            $err = $model->writeNET($params_writeNET);
BNGModel.pm:2182:            $params_writeNET->{prefix} = $prefix;
BNGModel.pm:2191:    foreach my $irule ( 0 .. $#{$model->RxnRules} )
BNGModel.pm:2203:    $err = $model->writeNET($params_writeNET);
BNGModel.pm:2221:        my $t_cpu = defined $t_start_iter ? cpu_time(0) - $t_start_iter : 0;
BNGModel.pm:2224:            my ( $rhead, $vhead, $rmem, $vmem ) = split ' ', `ps -o rss,vsz -p $$`;
BNGModel.pm:2250:    # i686-linux, ppc-darwin, MSWin32
BNGModel.pm:2257:    if (-x $exec) { return $exec; }
BNGModel.pm:2263:    if (-x $exec) { return $exec; }
BNGModel.pm:2284:    my $file_prefix = $model->Name;
BNGModel.pm:2285:    if ( $model->Params->{suffix} )
BNGModel.pm:2286:    {   $file_prefix .= '_' . $model->Params->{output_suffix};   }
BNGModel.pm:2288:    return File::Spec->catfile( ($model->getOutputDir()), $file_prefix );
BNGModel.pm:2302:        $dir = File::Spec->curdir();
BNGModel.pm:2306:    $model->Params->{output_dir} = $dir;
BNGModel.pm:2316:    unless ( defined $model->Params->{output_dir} )
BNGModel.pm:2318:        $model->setOutputDir();
BNGModel.pm:2320:    return $model->Params->{output_dir};
BNGOptions.pm:19:$self->config->{macro}='';         #default value (false) - enable macromodel
BNGOptions.pm:20:$self->config->{silent}='';        #default value (false) - disable all (my only) messages
BNGOptions.pm:21:$self->config->{debug}= 1;         #default value (false) - enable debug mode (debug output files)
BNGOptions.pm:22:$self->config->{bnglfile}='';
BNGOptions.pm:23:$self->config->{filetype}='';
BNGOptions.pm:24:$self->config->{prefix}='';
BNGOptions.pm:25:$self->config->{ModelID}='';
BNGOptions.pm:26:$self->config->{MAX_LEVEL}=5;       #sets maximum level of allowed recursion
BNGOptions.pm:29:GetOptions ('silent' => \$self->config->{silent},
BNGOptions.pm:30:            'macro' => \$self->config->{macro},
BNGOptions.pm:31:            'debug' => \$self->config->{debug},
BNGOptions.pm:32:            'nored=s'=> \@{$self->nored});
BNGOptions.pm:34:	if ($self->config->{macro})
BNGOptions.pm:36:	$self->config->{ModelID}="BNGModels::MacroBNGModel";
BNGOptions.pm:40:	$self->config->{ModelID}="BNGModels::MicroBNGModel";
BNGOptions.pm:45:	eval 'use '.$self->config->{ModelID};
BNGOptions.pm:49:        error("Module $self->config->{ModelID} not loaded because: \n\t$_");
BNGOptions.pm:53:	eval 'use '.$self->config->{ModelID};
BNGOptions.pm:59:  $self->config->{bnglfile}=$file;
BNGOptions.pm:60:  $self->config->{prefix}=$file;
BNGOptions.pm:61:  $self->config->{prefix}=~ s/[.]([^.]+)$//;
BNGOptions.pm:62:  $self->config->{filetype}=uc("bngl");
BNGOutput.pm:18:# $err = $model->writeXML({opt=>val,..}) 
BNGOutput.pm:40:    return $model->writeFile( \%params );
BNGOutput.pm:65:	my $model_name = $model->Name;
BNGOutput.pm:75:	my $xml =  "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
BNGOutput.pm:76:              ."<!-- Created by BioNetGen $version  -->\n"
BNGOutput.pm:84:	my $plist   = $model->ParamList;
BNGOutput.pm:85:	foreach my $param ( @{$plist->Array} )
BNGOutput.pm:90:		if ( $param->Type =~ /^Constant/ )
BNGOutput.pm:92:			$value = ($evaluate_expressions) ? sprintf "%.8g", $param->evaluate([], $plist) : $param->toString($plist);
BNGOutput.pm:93:			$type  = ($evaluate_expressions) ? "Constant" : $param->Type;
BNGOutput.pm:97:		$xml .= sprintf( "$indent2<Parameter id=\"%s\"", $param->Name );
BNGOutput.pm:105:	$xml .= $model->MoleculeTypesList->toXML($indent);
BNGOutput.pm:108:	$xml .= $model->CompartmentList->toXML($indent);
BNGOutput.pm:111:	if (@{$model->Concentrations}){
BNGOutput.pm:112:	    $xml .= $model->SpeciesList->toXML($indent,$model->Concentrations);
BNGOutput.pm:114:	    $xml .= $model->SpeciesList->toXML($indent);
BNGOutput.pm:121:	foreach my $rset ( @{$model->RxnRules} )
BNGOutput.pm:125:			$string .= $rr->toXML( $indent2, $rindex, $plist );
BNGOutput.pm:136:	foreach my $obs ( @{$model->Observables} )
BNGOutput.pm:138:		$string .= $obs->toXML( $indent2, $oindex );
BNGOutput.pm:147:	foreach my $param ( @{$plist->Array} )
BNGOutput.pm:149:		next unless ( $param->Type eq "Function" );
BNGOutput.pm:150:		$xml .= $param->Ref->toXML( $plist, $indent2 );
BNGOutput.pm:178:	unless ( defined $model->RxnList  and  @{$model->RxnList->Array} )
BNGOutput.pm:179:	{   return "writeSBML(): No reactions in current model--nothing to do.";   }
BNGOutput.pm:182:	my $plist = $model->ParamList;
BNGOutput.pm:185:	my $model_name = $model->Name;
BNGOutput.pm:188:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:189:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : '';
BNGOutput.pm:206:<?xml version="1.0" encoding="UTF-8"?>
BNGOutput.pm:207:<!-- Created by BioNetGen $version  -->
BNGOutput.pm:224:	my $use_array = @{$model->Concentrations} ? 1 : 0;
BNGOutput.pm:225:	foreach my $spec ( @{$model->SpeciesList->Array} )
BNGOutput.pm:229:        {   $conc = $model->Concentrations->[ $spec->Index - 1 ];   }
BNGOutput.pm:231:        {   $conc = $spec->Concentration;   }
BNGOutput.pm:235:        {   $conc = $plist->evaluate($conc, []);   }
BNGOutput.pm:238:		                                                                $spec->Index, "cell", $conc;
BNGOutput.pm:240:		if ( $spec->SpeciesGraph->Fixed )
BNGOutput.pm:243:		printf $SBML " name=\"%s\"", $spec->SpeciesGraph->StringExact;
BNGOutput.pm:252:	print $SBML "      <!-- Independent variables -->\n";
BNGOutput.pm:253:	foreach my $param ( @{$plist->Array} )
BNGOutput.pm:255:	    next unless ( $param->Type eq 'Constant' );
BNGOutput.pm:256:		printf $SBML "      <parameter id=\"%s\" value=\"%.8g\"/>\n", $param->Name, $param->evaluate([], $plist);
BNGOutput.pm:258:	print $SBML "      <!-- Dependent variables -->\n";
BNGOutput.pm:259:	foreach my $param ( @{$plist->Array} )
BNGOutput.pm:261:	    next unless ( $param->Type eq 'ConstantExpression' );	
BNGOutput.pm:262:		printf $SBML "      <parameter id=\"%s\" constant=\"false\"/>\n", $param->Name;
BNGOutput.pm:266:	if ( @{$model->Observables} )
BNGOutput.pm:268:		print $SBML "      <!-- Observables -->\n";
BNGOutput.pm:270:	foreach my $obs ( @{$model->Observables} )
BNGOutput.pm:272:		printf $SBML "      <parameter id=\"%s\" constant=\"false\"/>\n", "Group_" . $obs->Name;
BNGOutput.pm:279:	print $SBML "      <!-- Dependent variables -->\n";
BNGOutput.pm:280:	foreach my $param ( @{$plist->Array} )
BNGOutput.pm:282:		next if ( $param->Expr->Type eq 'NUM' );
BNGOutput.pm:283:		printf $SBML "      <assignmentRule variable=\"%s\">\n", $param->Name;
BNGOutput.pm:286:        #printf $SBML "            %s=%s\n", $param->Name,$param->toString($plist);
BNGOutput.pm:289:		printf $SBML $param->toMathMLString( $plist, "        " );
BNGOutput.pm:292:	if ( @{$model->Observables} )
BNGOutput.pm:294:		print $SBML "      <!-- Observables -->\n";
BNGOutput.pm:295:		foreach my $obs ( @{$model->Observables} )
BNGOutput.pm:298:			  "Group_" . $obs->Name;
BNGOutput.pm:299:			my ( $ostring, $err ) = $obs->toMathMLString();
BNGOutput.pm:314:	foreach my $rxn ( @{$model->RxnList->Array} )
BNGOutput.pm:321:		foreach my $spec ( @{$rxn->Reactants} )
BNGOutput.pm:323:			push @rindices, $spec->Index;
BNGOutput.pm:329:		foreach my $spec ( @{$rxn->Products} )
BNGOutput.pm:331:			push @pindices, $spec->Index;
BNGOutput.pm:350:		my ( $rstring, $err ) = $rxn->RateLaw->toMathMLString( \@rindices, \@pindices, $rxn->StatFactor );
BNGOutput.pm:389:	my $model_name = $model->Name;
BNGOutput.pm:391:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:392:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : undef;
BNGOutput.pm:400:	  "--# SSC-file for model $model_name created by BioNetGen $version\n";
BNGOutput.pm:403:	#-- Compartment default for SSC ---- look more into it
BNGOutput.pm:407:	# --This part correspond to seed specie
BNGOutput.pm:409:	print SSCfile "--# Initial molecules and their concentrations\n";
BNGOutput.pm:410:	my $sp_string = $model->SpeciesList->writeSSC( $model->Concentrations,
BNGOutput.pm:411:                                                   $model->ParamList       );
BNGOutput.pm:414:	# --This part in SSC corrsponds to Observables
BNGOutput.pm:415:	if ( @{$model->Observables })
BNGOutput.pm:417:		print SSCfile"\n\n--# reads observables";
BNGOutput.pm:419:		foreach my $obs ( @{$model->Observables} )
BNGOutput.pm:421:			my $ob_string = $obs->toStringSSC();
BNGOutput.pm:425:				print STDOUT "\n See Observable\n", $obs->toString();
BNGOutput.pm:426:				$ob_string = "\n" . "--#" . "record " . $ob_string;
BNGOutput.pm:436:	# --Reaction rules
BNGOutput.pm:437:	print SSCfile" \n\n--# reaction rules\n";
BNGOutput.pm:438:	foreach my $rset ( @{$model->RxnRules} )
BNGOutput.pm:441:		my $rreverse = ( $#$rset > 0 ) ? $rset->[1] : "";
BNGOutput.pm:442:		( my $reac1, my $errorSSC ) = $rset->[0]->toStringSSC($rreverse);
BNGOutput.pm:446:			  $rset->[0]->toString($rreverse);
BNGOutput.pm:447:			$reac1 = "--#" . $reac1;
BNGOutput.pm:453:			( my $reac2, my $errorSSC ) = $rset->[1]->toStringSSC($rreverse);
BNGOutput.pm:454:			if ( $errorSSC == 1 ) { $reac2 = "--#" . $reac2; }
BNGOutput.pm:473:	my $model_name = $model->Name;
BNGOutput.pm:476:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:477:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : '';
BNGOutput.pm:489:	print SSCcfgfile $model->ParamList->writeSSCcfg();
BNGOutput.pm:502:# Write model to a MATLAB M-file
BNGOutput.pm:515:	unless ( $model->RxnList )
BNGOutput.pm:523:	my $plist = $model->ParamList;
BNGOutput.pm:527:	my $model_name = $model->Name;
BNGOutput.pm:531:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:533:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : undef;
BNGOutput.pm:538:    my ($vol, $path, $filebase) = File::Spec->splitpath($prefix);
BNGOutput.pm:540:	# define m-script file name
BNGOutput.pm:543:	my $mscript_path     = File::Spec->catpath($vol,$path,$mscript_filename);
BNGOutput.pm:547:    my $odeset_abstol = 1e-4;
BNGOutput.pm:548:    if ( exists $params->{'atol'} )
BNGOutput.pm:549:    {   $odeset_abstol = $params->{'atol'};  }
BNGOutput.pm:551:    my $odeset_reltol = 1e-8;
BNGOutput.pm:552:    if ( exists $params->{'rtol'} )
BNGOutput.pm:553:    {   $odeset_reltol = $params->{'rtol'};  } 
BNGOutput.pm:556:    if ( exists $params->{'stats'} )
BNGOutput.pm:557:    {   $odeset_stats = $params->{'stats'};  } 
BNGOutput.pm:560:    if ( exists $params->{'bdf'} )
BNGOutput.pm:561:    {   $odeset_bdf = $params->{'bdf'};  }
BNGOutput.pm:564:    if ( exists $params->{'maxOrder'} )
BNGOutput.pm:565:    {   $odeset_maxorder = $params->{'maxOrder'};  } 
BNGOutput.pm:569:    if ( exists $params->{'t_start'} )
BNGOutput.pm:570:    {   $t_start = $params->{'t_start'};  }  
BNGOutput.pm:573:    if ( exists $params->{'t_end'} )
BNGOutput.pm:574:    {   $t_end = $params->{'t_end'};  } 
BNGOutput.pm:577:    if ( exists $params->{'n_steps'} )
BNGOutput.pm:578:    {   $n_steps = $params->{'n_steps'};  } 
BNGOutput.pm:582:    if ( exists $params->{'max_step'} )
BNGOutput.pm:583:    {   $odeset_maxstep = $params->{'max_step'};  }     
BNGOutput.pm:606:    ($err) = $plist->indexParams();
BNGOutput.pm:610:    my $n_parameters = $plist->countType( 'Constant' );
BNGOutput.pm:611:    my $n_expressions = $plist->countType( 'ConstantExpression' ) + $n_parameters;
BNGOutput.pm:612:    (my $calc_expressions_string, $err) = $plist->getMatlabExpressionDefs();    
BNGOutput.pm:618:	($mscript_param_names, $mscript_param_values, $err) = $plist->getMatlabConstantNames();
BNGOutput.pm:622:    my $n_species = scalar @{$model->SpeciesList->Array};
BNGOutput.pm:625:    my $n_observables = scalar @{$model->Observables};
BNGOutput.pm:627:    ($calc_observables_string, $err) = $plist->getMatlabObservableDefs();
BNGOutput.pm:632:	($mscript_observable_names, $err) = $plist->getMatlabObservableNames();
BNGOutput.pm:635:    # Construct user-defined functions
BNGOutput.pm:638:	foreach my $param ( @{ $model->ParamList->Array } )
BNGOutput.pm:640:		if ( $param->Type eq 'Function' )
BNGOutput.pm:643:		    my $fcn = $param->Ref;
BNGOutput.pm:647:		    next if ( $fcn->checkLocalDependency($plist) );
BNGOutput.pm:650:		    my $fcn_defn = $fcn->toMatlabString( $plist, {fcn_mode=>'define', indent=>''} );
BNGOutput.pm:658:    ($err) = $model->RxnList->updateIndex( $plist );
BNGOutput.pm:662:	my $n_reactions = scalar @{$model->RxnList->Array};
BNGOutput.pm:664:    ($calc_ratelaws_string, $err) = $model->RxnList->getMatlabRateDefs( $plist );
BNGOutput.pm:670:	($err) = $model->RxnList->calcStoichMatrix( $stoich_hash );
BNGOutput.pm:674:    ($calc_derivs_string, $err) = $model->SpeciesList->toMatlabString( $model->RxnList, $stoich_hash, $plist );
BNGOutput.pm:681:	($mscript_species_names, $mscript_species_init, $err) = $model->SpeciesList->getMatlabSpeciesNames( $model );
BNGOutput.pm:697:    if ( $model->SubstanceUnits eq 'Number' )
BNGOutput.pm:699:    elsif ( $model->SubstanceUnits eq 'Concentration' )
BNGOutput.pm:705:    if ( @{$model->Observables} )
BNGOutput.pm:739:%   generated using either default or user-defined parameters and initial
BNGOutput.pm:748:%   -------
BNGOutput.pm:757:%   --------
BNGOutput.pm:758:%   err             : 0 if the integrator exits without error, non-zero otherwise.
BNGOutput.pm:895:% user-defined functions
BNGOutput.pm:944:	print "Wrote M-file script $mscript_path.\n";
BNGOutput.pm:971:	unless ( $model->RxnList )
BNGOutput.pm:979:	my $plist = $model->ParamList;
BNGOutput.pm:982:	my $model_name = $model->Name;
BNGOutput.pm:985:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:986:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : undef;
BNGOutput.pm:991:    my ($vol, $path, $filebase) = File::Spec->splitpath($prefix);
BNGOutput.pm:996:    my $mex_path     = File::Spec->catpath($vol,$path,$mex_filename);
BNGOutput.pm:998:	# define m-script files name
BNGOutput.pm:1001:	my $mscript_path     = File::Spec->catpath($vol,$path,$mscript_filename);
BNGOutput.pm:1005:    my $cvode_abstol = 1e-6;
BNGOutput.pm:1006:    if ( exists $params->{'atol'} )
BNGOutput.pm:1007:    {   $cvode_abstol = $params->{'atol'};  }
BNGOutput.pm:1009:    my $cvode_reltol = 1e-8;
BNGOutput.pm:1010:    if ( exists $params->{'rtol'} )
BNGOutput.pm:1011:    {   $cvode_reltol = $params->{'rtol'};  }    
BNGOutput.pm:1014:    if ( exists $params->{'max_num_steps'} )
BNGOutput.pm:1015:    {   $cvode_max_num_steps = $params->{'max_num_steps'};  }  
BNGOutput.pm:1018:    if ( exists $params->{'max_err_test_fails'} )
BNGOutput.pm:1019:    {   $cvode_max_err_test_fails = $params->{'max_err_test_fails'};  }  
BNGOutput.pm:1022:    if ( exists $params->{'max_conv_fails'} )
BNGOutput.pm:1023:    {   $cvode_max_conv_fails = $params->{'max_conv_fails'};  }  
BNGOutput.pm:1026:    if ( exists $params->{'max_step'} )
BNGOutput.pm:1027:    {   $cvode_max_step = $params->{'max_step'};  }
BNGOutput.pm:1029:    # Stiff = CV_BDF,CV_NEWTON (Default); Non-stiff = CV_ADAMS,CV_FUNCTIONAL
BNGOutput.pm:1032:    if ( exists $params->{'stiff'} )
BNGOutput.pm:1035:        unless ( $params->{'stiff'} )
BNGOutput.pm:1044:    if ( ($cvode_nonlinear_solver eq 'CV_NEWTON')  and  ($params->{'sparse'}) )
BNGOutput.pm:1057:    if ( exists $params->{'t_start'} )
BNGOutput.pm:1058:    {   $t_start = $params->{'t_start'};  }  
BNGOutput.pm:1061:    if ( exists $params->{'t_end'} )
BNGOutput.pm:1062:    {   $t_end = $params->{'t_end'};  } 
BNGOutput.pm:1065:    if ( exists $params->{'n_steps'} )
BNGOutput.pm:1066:    {   $n_steps = $params->{'n_steps'};  } 
BNGOutput.pm:1068:    # code snippet for cleaning up dynamic memory before exiting CVODE-MEX
BNGOutput.pm:1080:    ($err) = $plist->indexParams();
BNGOutput.pm:1084:    my $n_parameters = $plist->countType( 'Constant' );
BNGOutput.pm:1085:    my $n_expressions = $plist->countType( 'ConstantExpression' ) + $n_parameters;
BNGOutput.pm:1086:    (my $calc_expressions_string, $err) = $plist->getCVodeExpressionDefs();    
BNGOutput.pm:1092:	($mscript_param_names, $mscript_param_values, $err) = $plist->getMatlabConstantNames();
BNGOutput.pm:1098:    my $n_species = scalar @{$model->SpeciesList->Array};
BNGOutput.pm:1102:    my $n_observables = scalar @{$model->Observables};
BNGOutput.pm:1104:    ($calc_observables_string, $err) = $plist->getCVodeObservableDefs();
BNGOutput.pm:1109:	($mscript_observable_names, $err) = $plist->getMatlabObservableNames();
BNGOutput.pm:1112:    # Construct user-defined functions
BNGOutput.pm:1115:	foreach my $param ( @{ $model->ParamList->Array } )
BNGOutput.pm:1117:		if ( $param->Type eq 'Function' )
BNGOutput.pm:1120:		    my $fcn = $param->Ref;
BNGOutput.pm:1124:		    next if ( $fcn->checkLocalDependency($plist) );
BNGOutput.pm:1127:		    $user_fcn_declarations .= $fcn->toCVodeString( $plist, {fcn_mode=>'declare',indent=>''} );
BNGOutput.pm:1130:		    my $fcn_defn = $fcn->toCVodeString( $plist, {fcn_mode=>'define', indent=>''} );
BNGOutput.pm:1138:    ($err) = $model->RxnList->updateIndex( $plist );
BNGOutput.pm:1142:	my $n_reactions = scalar @{$model->RxnList->Array};
BNGOutput.pm:1144:    ($calc_ratelaws_string, $err) = $model->RxnList->getCVodeRateDefs( $plist );
BNGOutput.pm:1150:	($err) = $model->RxnList->calcStoichMatrix( $stoich_hash );
BNGOutput.pm:1154:    ($calc_derivs_string, $err) = $model->SpeciesList->toCVodeString( $model->RxnList, $stoich_hash, $plist );
BNGOutput.pm:1162:	($mscript_species_names, $mscript_species_init, $err) = $model->SpeciesList->getMatlabSpeciesNames( $model );
BNGOutput.pm:1178:    if ( $model->SubstanceUnits eq 'Number' )
BNGOutput.pm:1180:    elsif ( $model->SubstanceUnits eq 'Concentration' )
BNGOutput.pm:1186:    if ( @{$model->Observables} )
BNGOutput.pm:1217:**   Cvode-Mex implementation of BioNetGen model '$model_name'.
BNGOutput.pm:1225:**-----------------------------------------------------------------------------
BNGOutput.pm:1228:**   mex -L<path_to_cvode_libraries> -I<path_to_cvode_includes>  ...
BNGOutput.pm:1229:**          -lsundials_nvecserial -lsundials_cvode -lm ${mex_filename}
BNGOutput.pm:1233:**   note2: if linker complains about lib stdc++, try removing "-lstdc++"
BNGOutput.pm:1237:**-----------------------------------------------------------------------------
BNGOutput.pm:1247:**   error_status    : 0 if the integrator exits without error, non-zero otherwise.
BNGOutput.pm:1279:/* user-defined function declarations */
BNGOutput.pm:1282:/* user-defined function definitions  */
BNGOutput.pm:1578:    /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
BNGOutput.pm:1581:        mexPrintf( "\\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\\n", funcname );    
BNGOutput.pm:1596:    /* Check if function returned NULL pointer - no memory allocated */
BNGOutput.pm:1599:        mexPrintf( "\\nMEMORY_ERROR: %s() failed - returned NULL pointer\\n", funcname );
BNGOutput.pm:1618:%   generated using either default or user-defined parameters and initial
BNGOutput.pm:1629:%   -------
BNGOutput.pm:1638:%   --------
BNGOutput.pm:1639:%   err             : 0 if the integrator exits without error, non-zero otherwise.
BNGOutput.pm:1766:	print "Wrote Mexfile $mex_path and M-file script $mscript_path.\n";
BNGOutput.pm:1781:	my $plist = $model->ParamList;
BNGOutput.pm:1782:	my $slist = $model->SpeciesList;
BNGOutput.pm:1787:	($mscript_param_names, $mscript_param_values, $err) = $plist->getMatlabConstantNames();
BNGOutput.pm:1791:	($mscript_observable_names, $err) = $plist->getMatlabObservableNames();
BNGOutput.pm:1795:	($mscript_species_names, $err) = $slist->getMatlabSpeciesNamesOnly();
BNGOutput.pm:1815:	print "Wrote M-file script $q_mscript.\n";
BNGOutput.pm:1837:	my $plist = $model->ParamList;
BNGOutput.pm:1839:	#Names of M-file
BNGOutput.pm:1846:	($mscript_param_names, $mscript_param_values, $err) = $plist->getMatlabConstantNames();
BNGOutput.pm:1851:	($mscript_observable_names, $err) = $plist->getMatlabObservableNames();
BNGOutput.pm:1905:	print "Wrote M-file script $par_mscript.\n";
BNGOutput.pm:1945:	print "Wrote M-file script $obs_mscript.\n";
BNGOutput.pm:1964:	unless ( $model->RxnList )
BNGOutput.pm:1965:    {   return "writeLatex(): No reactions in current model--nothing to do.";   }
BNGOutput.pm:1968:	my $plist = $model->ParamList;
BNGOutput.pm:1971:	my $model_name = $model->Name;
BNGOutput.pm:1974:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:1975:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : undef;
BNGOutput.pm:1995:	my $Nspecies   = scalar @{$model->SpeciesList->Array};
BNGOutput.pm:1996:	my $Nreactions = scalar @{$model->RxnList->Array};
BNGOutput.pm:2006:	foreach my $rxn ( @{$model->RxnList->Array} )
BNGOutput.pm:2008:		# Each reactant contributes a -1
BNGOutput.pm:2009:		foreach my $r ( @{$rxn->Reactants} )
BNGOutput.pm:2011:			--$S{ $r->Index }{$irxn};
BNGOutput.pm:2015:		foreach my $p ( @{$rxn->Products} )
BNGOutput.pm:2017:			++$S{ $p->Index }{$irxn};
BNGOutput.pm:2019:		my ($flux, $err) = $rxn->RateLaw->toLatexString( $rxn->Reactants, $rxn->StatFactor,
BNGOutput.pm:2020:			                                               $model->ParamList );
BNGOutput.pm:2039:			elsif ( $s == -1 ) {
BNGOutput.pm:2040:				$mod = "-";
BNGOutput.pm:2051:				printf $Lfile " %s %s", $mod, $fluxes[ $irxn - 1 ];
BNGOutput.pm:2089:	unless ( $model->RxnList )
BNGOutput.pm:2097:	my $plist = $model->ParamList;
BNGOutput.pm:2101:	my $model_name = $model->Name;
BNGOutput.pm:2105:	my $prefix = ( defined $params->{prefix} ) ? $params->{prefix} : $model->getOutputPrefix();
BNGOutput.pm:2107:	my $suffix = ( defined $params->{suffix} ) ? $params->{suffix} : undef;
BNGOutput.pm:2112:    my ($vol, $path, $filebase) = File::Spec->splitpath($prefix);
BNGOutput.pm:2114:	# define m-script file name
BNGOutput.pm:2117:	my $mscript_path     = File::Spec->catpath($vol,$path,$mscript_filename);
BNGOutput.pm:2121:    my $odeset_abstol = 1e-4;
BNGOutput.pm:2122:    if ( exists $params->{'atol'} )
BNGOutput.pm:2123:    {   $odeset_abstol = $params->{'atol'};  }
BNGOutput.pm:2125:    my $odeset_reltol = 1e-8;
BNGOutput.pm:2126:    if ( exists $params->{'rtol'} )
BNGOutput.pm:2127:    {   $odeset_reltol = $params->{'rtol'};  } 
BNGOutput.pm:2130:    if ( exists $params->{'stats'} )
BNGOutput.pm:2131:    {   $odeset_stats = $params->{'stats'};  } 
BNGOutput.pm:2134:    if ( exists $params->{'bdf'} )
BNGOutput.pm:2135:    {   $odeset_bdf = $params->{'bdf'};  }
BNGOutput.pm:2138:    if ( exists $params->{'maxOrder'} )
BNGOutput.pm:2139:    {   $odeset_maxorder = $params->{'maxOrder'};  } 
BNGOutput.pm:2143:    if ( exists $params->{'t_start'} )
BNGOutput.pm:2144:    {   $t_start = $params->{'t_start'};  }  
BNGOutput.pm:2147:    if ( exists $params->{'t_end'} )
BNGOutput.pm:2148:    {   $t_end = $params->{'t_end'};  } 
BNGOutput.pm:2151:    if ( exists $params->{'n_steps'} )
BNGOutput.pm:2152:    {   $n_steps = $params->{'n_steps'};  } 
BNGOutput.pm:2156:    if ( exists $params->{'max_step'} )
BNGOutput.pm:2157:    {   $odeset_maxstep = $params->{'max_step'};  }     
BNGOutput.pm:2180:    ($err) = $plist->indexParams();
BNGOutput.pm:2184:    my $n_parameters = $plist->countType( 'Constant' );
BNGOutput.pm:2185:    my $n_expressions = $plist->countType( 'ConstantExpression' ) + $n_parameters;
BNGOutput.pm:2186:    (my $calc_expressions_string, $err) = $plist->getMatlabExpressionDefs();    
BNGOutput.pm:2192:	($mscript_param_names, $mscript_param_values, $err) = $plist->getMatlabConstantNames();
BNGOutput.pm:2196:    my $n_species = scalar @{$model->SpeciesList->Array};
BNGOutput.pm:2199:    my $n_observables = scalar @{$model->Observables};
BNGOutput.pm:2201:    ($calc_observables_string, $err) = $plist->getMatlabObservableDefs();
BNGOutput.pm:2206:	($mscript_observable_names, $err) = $plist->getMatlabObservableNames();
BNGOutput.pm:2209:    # Construct user-defined functions
BNGOutput.pm:2212:	foreach my $param ( @{ $model->ParamList->Array } )
BNGOutput.pm:2214:		if ( $param->Type eq 'Function' )
BNGOutput.pm:2217:		    my $fcn = $param->Ref;
BNGOutput.pm:2221:		    next if ( $fcn->checkLocalDependency($plist) );
BNGOutput.pm:2224:		    my $fcn_defn = $fcn->toMatlabString( $plist, {fcn_mode=>'define', indent=>''} );
BNGOutput.pm:2232:    ($err) = $model->RxnList->updateIndex( $plist );
BNGOutput.pm:2236:	my $n_reactions = scalar @{$model->RxnList->Array};
BNGOutput.pm:2238:    ($calc_ratelaws_string, $err) = $model->RxnList->getMatlabRateDefs( $plist );
BNGOutput.pm:2244:	($err) = $model->RxnList->calcStoichMatrix( $stoich_hash );
BNGOutput.pm:2248:    ($calc_derivs_string, $err) = $model->SpeciesList->toMatlabString( $model->RxnList, $stoich_hash, $plist );
BNGOutput.pm:2255:	($mscript_species_names, $mscript_species_init, $err) = $model->SpeciesList->getMatlabSpeciesNames( $model );
BNGOutput.pm:2271:    if ( $model->SubstanceUnits eq 'Number' )
BNGOutput.pm:2273:    elsif ( $model->SubstanceUnits eq 'Concentration' )
BNGOutput.pm:2279:    if ( @{$model->Observables} )
BNGOutput.pm:2313:%   generated using either default or user-defined parameters and initial
BNGOutput.pm:2322:%   -------
BNGOutput.pm:2331:%   --------
BNGOutput.pm:2332:%   err             : 0 if the integrator exits without error, non-zero otherwise.
BNGOutput.pm:2469:% user-defined functions
BNGOutput.pm:2518:	print "Wrote M-file script $mscript_path.\n";
BNGOutput.pm:2520:# define m-script file name
BNGOutput.pm:2523:	 $mscript_path     = File::Spec->catpath($vol,$path,$mscript_filename);
BNGOutput.pm:2537:	print "Wrote M-file script $mscript_path.\n";
BNGOutput.pm:2541:	 $mscript_path     = File::Spec->catpath($vol,$path,$mscript_filename);
BNGOutput.pm:2577:	print "Wrote M-file script $mscript_path.\n";
BNGUtils.pm:36:	            my $bin_dir = File::Spec->catdir( ($ENV{BNGPATH}) );
BNGUtils.pm:37:                if ( -d $bin_dir )
BNGUtils.pm:45:	            my $bin_dir = File::Spec->catdir( ($ENV{BioNetGenRoot}) );
BNGUtils.pm:46:                if ( -d $bin_dir )
BNGUtils.pm:56:                if (-d $FindBin::RealBin)
BNGUtils.pm:78:        return File::Spec->catdir( ($BNG_ROOT, @_) );
BNGUtils.pm:94:            if ( open my $fh, '<', File::Spec->catfile($BNG_ROOT, VERSION_FILENAME) )
BNGUtils.pm:142:    # compare versions: returns -1 if version1  < version2,
BNGUtils.pm:162:        return ( @version1 ? 1 : (@version2 ? -1 : 0) );
BNGUtils.pm:173:  if ($string=~ s/^[+-]?\d+[.]?\d*//){
BNGUtils.pm:176:  elsif ($string=~ s/^[+-]?[.]\d+//){
BNGUtils.pm:183:  if ($string=~ s/^[DEFGdefg][+-]?\d+$//){
BNGUtils.pm:204:# Convert boolean to integer False=0 True=1 notBoolean=-1
BNGUtils.pm:220:    $intval=-1;
BNGUtils.pm:225:##---------------------------------------------------------------------------
BNGUtils.pm:259:	if ($comp=~/[^0-9\*]/){
BNGUtils.pm:262:#	if ($comp=~/[^A-Za-z0-9_\-\*]/){
BNGUtils.pm:263:#	  return(1, "Invalid component state $comp in pattern $pattern: May only use alphanumeric characters, '-','_', or '*'.");
BNGUtils.pm:275:##---------------------------------------------------------------------------
BNGUtils.pm:301:    if ($val=~/^[a-zA-Z]/){
BNGUtils.pm:306:      # Make sure value is non-negative
BNGUtils.pm:307:      if ($$parameters{$val}{val}<0){exit_error("Parameter value must be non-negative.",$entry);}
BNGUtils.pm:312:      # Make sure value is non-negative
BNGUtils.pm:313:      if ($value<0){&exit_error("Parameter value must be non-negative",$entry);}
BNGUtils.pm:362:##------------------------------------------------------------------------
BNGUtils.pm:363:# Used to create list of all multi-state objects from a list of
BNGUtils.pm:382:	    for $j (0..$i-1){
BNGUtils.pm:386:	for $state (0..($lengths[$i]-1)){
BNGUtils.pm:411:##---------------------------------------------------------------------------
BNGUtils.pm:417:##---------------------------------------------------------------------------
BNGUtils.pm:458:	    --$idepth;
BNGUtils.pm:472:##------------------------------------------------------------------------
BNGUtils.pm:489:    $t_ret= $t_tot - $t_last;
BNGUtils.pm:548:    return -1 unless $#_>=0;
BNGUtils.pm:557:    return -1 unless $#_>=0;
BNGUtils.pm:561:        $sum+=SQR($val-$average);
BNGUtils.pm:564:                                       # variance---denom contains (n-1)
Cache.pm:37:    $cache->{$label} = $item;
Cache.pm:48:    return (exists $cache->{$label} ? $cache->{$label} : undef);
Cache.pm:60:    if (exists $cache->{$label})
Cache.pm:62:        $item = $cache->{$label};
Cache.pm:63:        delete $cache->{$label};
Cache.pm:76:    return exists $cache->{$label};
CartesianProduct.pm:30:###   $cp_copy = $cp->copy();
CartesianProduct.pm:31:###   bool = $cp->initialize( \@lists );
CartesianProduct.pm:32:###   bool = $cp->getNext( \@elem );
CartesianProduct.pm:33:###   bool = $cp->update( \@new_items, $list_idx );
CartesianProduct.pm:34:###   bool = $cp->validate( );
CartesianProduct.pm:37:###   void = $cp->advance( );
CartesianProduct.pm:48:    $cp_copy->Lists( [@{$cp->Lists}] );
CartesianProduct.pm:49:    $cp_copy->NumLists( $cp->NumLists );
CartesianProduct.pm:50:    $cp_copy->ListPosition( $cp->ListPosition );
CartesianProduct.pm:51:    $cp_copy->FirstIdx( [@{$cp->FirstIdx}] );
CartesianProduct.pm:52:    $cp_copy->CurrentIdx( [@{$cp->CurrentIdx}] );
CartesianProduct.pm:53:    $cp_copy->LastIdx( [@{$cp->LastIdx}] );
CartesianProduct.pm:54:    $cp_copy->MoreElements( $cp->MoreElements );
CartesianProduct.pm:79:    $cp->Lists( $lists );
CartesianProduct.pm:80:    $cp->NumLists( scalar @$lists );
CartesianProduct.pm:90:    while ( $ii < $cp->NumLists )
CartesianProduct.pm:94:        push @$last_idx, scalar @{$cp->Lists->[$ii]};       
CartesianProduct.pm:95:        $elem_exist *= scalar @{$cp->Lists->[$ii]};
CartesianProduct.pm:99:    $cp->ListPosition( 0 );
CartesianProduct.pm:100:    $cp->FirstIdx( $first_idx );
CartesianProduct.pm:101:    $cp->CurrentIdx( $current_idx );
CartesianProduct.pm:102:    $cp->LastIdx( $last_idx );      
CartesianProduct.pm:103:    $cp->MoreElements( $elem_exist );
CartesianProduct.pm:125:    if ( $cp->MoreElements )
CartesianProduct.pm:127:        my $ii = $cp->ListPosition;
CartesianProduct.pm:128:        while ( $ii < $cp->NumLists )
CartesianProduct.pm:130:            $elem->[$ii] = $cp->Lists->[$ii]->[ $cp->CurrentIdx->[$ii] ];
CartesianProduct.pm:133:        $cp->advance();
CartesianProduct.pm:159:    if (     $cp->MoreElements
CartesianProduct.pm:160:         or  $cp->NumLists != scalar @{$cp->Lists}
CartesianProduct.pm:162:         or  $list_idx >= $cp->NumLists 
CartesianProduct.pm:171:        $cp->FirstIdx( [(0) x $cp->NumLists] );
CartesianProduct.pm:172:        $cp->FirstIdx->[$list_idx] = @{$cp->Lists->[$list_idx]};
CartesianProduct.pm:175:        $cp->CurrentIdx( [@{$cp->FirstIdx}] );
CartesianProduct.pm:178:        push @{$cp->Lists->[$list_idx]}, @$new_items;
CartesianProduct.pm:182:        my $elem_exist = $cp->NumLists ? 1 : 0;
CartesianProduct.pm:183:        while ( $ii < $cp->NumLists )
CartesianProduct.pm:185:            $cp->LastIdx->[$ii] = scalar @{$cp->Lists->[$ii]};
CartesianProduct.pm:186:            $elem_exist *= scalar @{$cp->Lists->[$ii]};
CartesianProduct.pm:190:        $cp->ListPosition( 0 );
CartesianProduct.pm:193:        {   $cp->MoreElements(1);   }
CartesianProduct.pm:212:    if ( $cp->MoreElements )
CartesianProduct.pm:214:        my $ii = $cp->NumLists - 1;
CartesianProduct.pm:217:            ++($cp->CurrentIdx->[$ii]);
CartesianProduct.pm:218:            last if ( $cp->CurrentIdx->[$ii] < $cp->LastIdx->[$ii] );
CartesianProduct.pm:219:            $cp->CurrentIdx->[$ii] = $cp->FirstIdx->[$ii];
CartesianProduct.pm:220:            --$ii;
CartesianProduct.pm:223:        $cp->ListPosition($ii);
CartesianProduct.pm:224:        if ( $ii < 0 ) {  $cp->MoreElements(0);  }
CartesianProduct.pm:247:    unless (      defined $cp->NumLists 
CartesianProduct.pm:248:             and  @{$cp->Lists} == $cp->NumLists )
CartesianProduct.pm:252:    unless (      defined $cp->ListPosition
CartesianProduct.pm:253:             and  $cp->ListPosition >= 0
CartesianProduct.pm:254:             and  $cp->ListPosition < $cp->NumLists )
CartesianProduct.pm:258:    unless ( defined $cp->CurrentIdx )
CartesianProduct.pm:262:    unless ( defined $cp->LastIdx )
CartesianProduct.pm:268:        unless ( @$elem == @{$cp->Lists} ) {  return 0;  }
CartesianProduct.pm:273:    while ( $ii < $cp->NumLists )
CartesianProduct.pm:276:        unless (      defined $cp->Lists->[$ii]
CartesianProduct.pm:277:                 and  defined $cp->CurrentIdx->[$ii] 
CartesianProduct.pm:278:                 and  defined $cp->LastIdx->[$ii]    )
CartesianProduct.pm:282:        unless ( $cp->LastIdx->[$ii] == @{$cp->Lists->[$ii]} )
CartesianProduct.pm:286:        unless (      $cp->CurrentIdx->[$ii] >= 0
CartesianProduct.pm:287:                 and  $cp->CurrentIdx->[$ii] < @{$cp->Lists->[$ii]} )  
CartesianProduct.pm:291:        if ( defined $elem  and  $ii < $cp->ListPosition )
CartesianProduct.pm:293:            unless ( $elem->[$ii] == $cp->Lists->[$ii]->[ $cp->CurrentIdx->[$ii] ] )
CompartmentList.pm:36:    my $clist_copy = CompartmentList->new();
CompartmentList.pm:37:    foreach my $comp ( @{$clist->Array} )
CompartmentList.pm:39:        my $comp_copy = $comp->copy( $plist );
CompartmentList.pm:40:        push @{$clist_copy->Array}, $comp_copy;
CompartmentList.pm:41:        $clist_copy->Hash->{$comp_copy->Name} = $comp_copy;
CompartmentList.pm:43:    $clist_copy->Used($clist->Used);  # TODO: is this the best assumption?
CompartmentList.pm:46:    foreach my $comp ( @{$clist_copy->Array} )
CompartmentList.pm:48:        $comp->relinkNeighbors( $clist_copy );
CompartmentList.pm:64:    return scalar @{$clist->Array};
CompartmentList.pm:79:    if ( exists $clist->Hash->{$name} )
CompartmentList.pm:81:        return $clist->Hash->{$name};
CompartmentList.pm:96:# '' = @clist->add( cref1, cref2, ... crefN )
CompartmentList.pm:106:         || return "CompartmentList: Attempt to add non-compartment object $comp to CompartmentList.";   
CompartmentList.pm:108:    if ( exists $clist->Hash->{ $comp->Name } )
CompartmentList.pm:111:        my $cref = $clist->Hash->{ $comp->Name };
CompartmentList.pm:116:        $clist->Hash->{ $comp->Name } = $comp;
CompartmentList.pm:117:        push @{$clist->Array}, $comp;
CompartmentList.pm:122:    {  return $clist->add(@_);  }
CompartmentList.pm:136:    foreach my $comp (@{$clist->Array}){
CompartmentList.pm:137:        $string .= '  ' . $comp->toString($plist) . "\n";
CompartmentList.pm:148:# $err = $clist->readString(compartment_string,param_list)
CompartmentList.pm:158:    $string =~ s/^\s*([A-Za-z_0-9]+)//   or return "Invalid compartment name in $string";
CompartmentList.pm:167:    my $size = Expression->new();
CompartmentList.pm:168:    $size->setAllowForward(1);
CompartmentList.pm:169:    $size->readString(\$string, $plist)  and return $_;
CompartmentList.pm:173:    if ( $string =~ s/^([A-Za-z_0-9]+)\s*// )
CompartmentList.pm:177:        $outside = $clist->Hash->{$cname}
CompartmentList.pm:186:    my ($comp, $err) = Compartment->newCompartment($name, $spatialDimensions, $size, $outside);
CompartmentList.pm:190:    return $clist->add($comp);
CompartmentList.pm:203:    foreach my $comp (@{$clist->Array}){
CompartmentList.pm:204:        $string .= $comp->toXML("  ".$indent);
CompartmentList.pm:218:    foreach my $comp (@{$clist->Array})
CompartmentList.pm:220:        if ($comp->SpatialDimensions eq '')
CompartmentList.pm:222:            my $err = sprintf "Compartment %s referred to but not defined", $comp->Name;
Compartment.pm:21:  SpatialDimensions => '$',  # dimension of compartment: 0-3.
Compartment.pm:37:    $comp_copy->Name( $comp->Name );
Compartment.pm:38:    $comp_copy->SpatialDimensions( $comp->SpatialDimensions );
Compartment.pm:40:    $comp_copy->Size( $comp->Size->clone($plist) ) if ( defined $comp->Size );
Compartment.pm:41:    $comp_copy->Outside( $comp->Outside )         if ( defined $comp->Outside );
Compartment.pm:43:    @{ $comp_copy->Inside } = @{ $comp->Inside };
Compartment.pm:64:    $comp->Outside = $clist->lookup( $comp->Outside->Name );
Compartment.pm:66:    foreach my $inside_comp ( @{$comp->Inside} )
Compartment.pm:68:        $inside_comp = $clist->lookup( $inside_comp->Name );
Compartment.pm:80:# ($comp_ref, $err) = Compartment->newCompartment(name,dim,size[,outside]);
Compartment.pm:87:   $dim =~ /^[2-3]$/   or  return( undef, "newCompartment: spatialDimension '$dim' must be integer in [2,3]." );
Compartment.pm:91:   my $comp = Compartment->new(Name=>$name,SpatialDimensions=>$dim,Size=>$size);
Compartment.pm:92:   $err = $comp->put_inside($outside) if ( defined $outside );
Compartment.pm:104:# $err = $comp->put_inside( $outside ); 
Compartment.pm:105:# set $comp1->Outside = $comp;
Compartment.pm:111:       ||  return("Compartment->put_inside > Outside parameter '$outside' must be a Compartment.");
Compartment.pm:113:   !defined($comp->Outside)
Compartment.pm:114:       ||  return("Compartment->put_inside: compartment is already contained by another compartment.");
Compartment.pm:116:   # enforce topology.  (1) alternating dimensions:  ..->volume->surface->volume->surface->..
Compartment.pm:117:   abs( $comp->SpatialDimensions - $outside->SpatialDimensions ) == 1
Compartment.pm:118:       ||  return("Compartment->put_inside: Outside has same dimension as compartment.");
Compartment.pm:121:   if ($comp->SpatialDimensions == 3  &&  $outside->SpatialDimensions == 2)
Compartment.pm:123:     (@{$outside->Inside} == 0)
Compartment.pm:124:         ||  return("Compartment->put_inside: Outside 2-D compartment already contains a 3-D compartment.");
Compartment.pm:128:   $comp->Outside($outside);
Compartment.pm:129:   push @{$outside->Inside}, $comp;
Compartment.pm:137:# int = $comp1->adjacent( $comp2 )
Compartment.pm:139:# return -1 if $comp2 is Outside of Comp1
Compartment.pm:146:    if ( defined $comp2->Outside )
Compartment.pm:148:        if ( $comp2->Outside == $comp1 )
Compartment.pm:152:    if ( defined $comp1->Outside )
Compartment.pm:154:        if ( $comp1->Outside == $comp2 )
Compartment.pm:155:        {  return -1;  }
Compartment.pm:164:# int = $comp1->is_surface_of($comp2)
Compartment.pm:166:# return -1 if $comp2 is a surface facing volume $comp1
Compartment.pm:171:  my $adj = $comp1->adjacent($comp2);
Compartment.pm:173:  {  return($comp2->SpatialDimensions - $comp1->SpatialDimensions);  }
Compartment.pm:181:# int = Compartment1->separated_by_surface(Compartment2) 
Compartment.pm:183:#   separated by a surface and Comp1 is outer-most compartment.
Compartment.pm:184:# return -1 if Compartment1 and Compartment2 are volumes
Compartment.pm:185:#   separated by a surface and Comp2 is outer-most compartment.
Compartment.pm:193:  return 0 unless ( ($comp1->SpatialDimensions==3)  and  ($comp2->SpatialDimensions==3) );
Compartment.pm:196:  # and comp1 is outer-most:
Compartment.pm:197:  return -1  if (  defined $comp1->Outside
Compartment.pm:198:                    and  defined $comp1->Outside->Outside 
Compartment.pm:199:                    and  ($comp1->Outside->Outside == $comp2)       );
Compartment.pm:201:  # and comp2 is outer-most:
Compartment.pm:202:  return  1  if (  defined $comp2->Outside
Compartment.pm:203:                    and  defined $comp2->Outside->Outside 
Compartment.pm:204:                    and  ($comp2->Outside->Outside == $comp1)       );
Compartment.pm:211:# int = Compartment1->separated_by_surface(Compartment2) 
Compartment.pm:214:# return -1 if Compartment1 and Compartment2 are surfaces
Compartment.pm:226:  return 0 unless ( ($comp1->SpatialDimensions==2)  and  ($comp2->SpatialDimensions==2) );
Compartment.pm:230:  return -1  if (  defined $comp1->Outside
Compartment.pm:231:                    and  defined $comp2->Outside
Compartment.pm:232:                    and  ($comp1->Outside == $comp2->Outside) 
Compartment.pm:233:                    and  exists $comp1->Inside->[0]
Compartment.pm:234:                    and  exists $comp2->Inside->[0] 
Compartment.pm:239:  return  1  if (  defined $comp1->Outside
Compartment.pm:240:                    and  defined $comp1->Outside->Outside 
Compartment.pm:241:                    and  ($comp1->Outside->Outside == $comp2)
Compartment.pm:242:                    and  exists $comp1->Inside->[0]
Compartment.pm:243:                    and  defined $comp2->Inside
Compartment.pm:248:  return  1  if (  defined $comp2->Outside
Compartment.pm:249:                    and  defined $comp2->Outside->Outside 
Compartment.pm:250:                    and  ($comp2->Outside->Outside == $comp1)
Compartment.pm:251:                    and  exists $comp2->Inside->[0]
Compartment.pm:252:                    and  defined $comp1->Outside
Compartment.pm:272:	     if ($n1->adjacent($nodes_left[$i])){
Compartment.pm:296:  $string.=$comp->Name;
Compartment.pm:297:  $string.=" ".$comp->SpatialDimensions;
Compartment.pm:299:    $string.=" ".$comp->Size->toString($plist);
Compartment.pm:301:  if (my $ccomp=$comp->Outside){
Compartment.pm:302:    $string.=" ".$ccomp->Name;
Compartment.pm:318:  $string.=" id=\"".$comp->Name."\"";
Compartment.pm:320:  $string.= " spatialDimensions=\"".$comp->SpatialDimensions."\"";
Compartment.pm:322:  $string.= " size=\"".$comp->Size->toString()."\"";
Compartment.pm:324:  if ($comp->Outside){
Compartment.pm:325:    $string.= " outside=\"".$comp->Outside->Name."\"";
Component.pm:45:    my $comp = Component->new();
Component.pm:46:    my $err = $comp->readString($strptr);
Component.pm:68:    #if ($string_left=~ s/^([A-Za-z0-9_*]*)//)
Component.pm:71:        $comp->Name($1);
Component.pm:90:	            if (defined $comp->State)
Component.pm:92:	            $comp->State($arg);
Component.pm:108:	            push @{$comp->Edges}, $arg;
Component.pm:113:	            if (defined $comp->Label)
Component.pm:115:	            $comp->Label($arg);
Component.pm:120:	            if (defined $comp->Compartment)
Component.pm:125:				    if ( my $compart = $clist->lookup($arg) )
Component.pm:126:                    {   $comp->Compartment($compart);   }
Component.pm:160:    my $string .= $comp->Name;
Component.pm:162:    if (defined $comp->State )
Component.pm:163:    {   $string .= sprintf "~%s", $comp->State;   }
Component.pm:166:    {   $string .= sprintf("%%%s", $comp->Label)  if (defined $comp->Label);   }
Component.pm:168:    if ( defined $comp->Compartment )
Component.pm:169:    {   $string .= sprintf "@%s", $comp->Compartment->Name;   }
Component.pm:171:    if (defined $comp->Edges )
Component.pm:176:            foreach my $edge (@{$comp->Edges})
Component.pm:186:        {   $string .= "!" x @{$comp->Edges};   }
Component.pm:206:    my $string      = $comp->Name;
Component.pm:210:    if (defined $comp->Label)
Component.pm:213:    if (defined $comp->Compartment)
Component.pm:216:    if (defined $comp->State)
Component.pm:218:        $string.= sprintf "=\"%s\"", $comp->State;
Component.pm:221:            $string .= ", " . $comp->Name . "Binds";
Component.pm:225:            $string .= ", " . $comp->Name . $comp_label ."Binds";
Component.pm:229:    if (defined $comp->Edges)
Component.pm:231:        $string .= "#"; #As SSC considers every non-bound component as empty, so attaching #
Component.pm:235:            foreach my $edge (@{$comp->Edges})
Component.pm:250:            $string.= ""x scalar(@{$comp->Edges});
Component.pm:279:    $string .= " name=\"" . $comp->Name . "\"";
Component.pm:281:    if (defined $comp->State)
Component.pm:283:        $string .= " state=\"" . $comp->State . "\"";
Component.pm:285:    if (defined $comp->Label)
Component.pm:287:        $string .= " label=\"" . $comp->Label . "\"";
Component.pm:289:    if ($comp->Compartment)
Component.pm:291:        $string .= " compartment=\"" . $comp->Compartment->Name . "\"";
Component.pm:297:    foreach my $edge (@{$comp->Edges})
Component.pm:350:    my $comp_copy = Component->new();
Component.pm:353:    $comp_copy->Name( $comp->Name );
Component.pm:354:    $comp_copy->Label( $comp->Label ) if ($copy_labels);
Component.pm:355:    $comp_copy->State( $comp->State );
Component.pm:356:    $comp_copy->Compartment( $comp->Compartment ) if (defined $comp->Compartment);
Component.pm:359:    if ( @{$comp->Edges} )
Component.pm:362:        $comp_copy->Edges( [map {$_=~/^[*+?]$/ ? $_ : $prefix.$_} @{$comp->Edges}] );
Component.pm:385:    {   return "Component->relinkCompartments: Error!! Method called without CompartmentList object";   }
Component.pm:387:    if ( defined $comp->Compartment )
Component.pm:389:        my $new_compart = $clist->lookup( $comp->Compartment->Name );
Component.pm:391:        {   return "Molecule->relinkCompartments: Error!! could not find compartment name in list";   }
Component.pm:392:        $comp->Compartment( $new_compart );
Component.pm:414:    if ( $cmp = ($a->Name cmp $b->Name) )
Component.pm:418:    if ( defined $a->State )
Component.pm:420:        unless (defined $a->State) { return 1; }
Component.pm:421:        if ( $cmp = ($a->State cmp $b->State) )
Component.pm:424:    elsif ( defined $b->State )
Component.pm:426:        return -1;
Component.pm:430:    if ( defined $a->Compartment )
Component.pm:432:        unless (defined $b->Compartment) { return 1; }
Component.pm:433:        if ( $cmp = ($a->Compartment <=> $b->Compartment) )
Component.pm:436:    elsif ( defined $b->Compartment )
Component.pm:438:        return -1;
Component.pm:442:    if ( $cmp = (@{$a->Edges} <=> @{$b->Edges}) )
ComponentType.pm:13:                # is used in creating new molecules that don't have user-specified
ComponentType.pm:25:  if ($string_left=~ s/^([A-Za-z0-9_]*)//){
ComponentType.pm:26:    $ctype->Name($1);
ComponentType.pm:36:    if ($string_left=~ s/^([~!@])([A-Za-z0-9_]+)//){
ComponentType.pm:58:    $ctype->States([@states]);
ComponentType.pm:61:    $ctype->Edges([@elabels]);
ComponentType.pm:64:    $ctype->Compartments([@compartments]);
ComponentType.pm:77:    $comp_copy->Name( $comp->Name );
ComponentType.pm:78:    $comp_copy->States( [@{$comp->States}] );
ComponentType.pm:79:    $comp_copy->Edges( [@{$comp->Edges}] );
ComponentType.pm:80:    $comp_copy->Compartments( [@{$comp->Compartments}] );            
ComponentType.pm:89:  $string.= $ctype->Name;
ComponentType.pm:90:  for my $state (@{$ctype->States}){
ComponentType.pm:99:  $string.= $ctype->Name;
ComponentType.pm:101:  for my $state (@{$ctype->States}){
ComponentType.pm:114:  $string.=" id=\"".$ctype->Name."\"";
ComponentType.pm:119:  if (@{$ctype->States}){
ComponentType.pm:121:    for my $state (@{$ctype->States}){
Console.pm:37:    my $interactive = ( -t STDIN ) ? 1 : 0;
Console.pm:72:                unless ($filename and -e $filename)
Console.pm:81:                $local_params->{file} = $filename;
Console.pm:84:                $model = BNGModel->new();
Console.pm:87:                    my $err = $model->readFile($local_params);
Console.pm:120:                my $command = '$model->' . $action . '(' . $options . ');';
Console.pm:123:	            # Perform self-consistency checks before operations are performed on model
Console.pm:125:                    my $err = $model->ParamList->check();
Console.pm:148:		    	    my $t_elapsed = cpu_time(0) - $t_start;
Console.pm:182:                print "/-----------------------------------------------\n";
Console.pm:187:                print "-----------------------------------------------/\n";
EnergyPattern.pm:3:#  energy of a Species and influences reaction rates.   --Justin
EnergyPattern.pm:24:    Keq         => 'Expression',      # change in free-energy parameter (per match)
EnergyPattern.pm:38:    my $plist  = $model->ParamList;
EnergyPattern.pm:39:    my $clist  = $model->CompartmentList;
EnergyPattern.pm:40:    my $mtlist = $model->MoleculeTypesList;
EnergyPattern.pm:53:    my $sg = SpeciesGraph->new();
EnergyPattern.pm:54:    $err = $sg->readString( \$string, $clist, 0, $sep, $mtlist, 0 );
EnergyPattern.pm:57:    $epatt->Pattern( $sg );
EnergyPattern.pm:60:    my $Keq_expr = Expression->new();    
EnergyPattern.pm:64:        $err = $Keq_expr->readString( \$string, $plist );
EnergyPattern.pm:70:        $err = $Keq_expr->readString( \$default_Keq, $plist );
EnergyPattern.pm:74:    $epatt->Keq( $Keq_expr );    
EnergyPattern.pm:78:    my $phi_expr = Expression->new();    
EnergyPattern.pm:84:        $err = $phi_expr->readString( \$string, $plist );
EnergyPattern.pm:90:        my $phi_expr = Expression->new();
EnergyPattern.pm:91:        $err = $phi_expr->readString( \$default_phi, $plist );
EnergyPattern.pm:95:    $epatt->Phi( $phi_expr );
EnergyPattern.pm:99:    $epatt->SpecMatches( [] );
EnergyPattern.pm:113:    $string .=  $epatt->Pattern->toString() . "  "
EnergyPattern.pm:114:              . $epatt->Keq->toString($plist) . ", "
EnergyPattern.pm:115:              . $epatt->Phi->toString($plist);
EnergyPattern.pm:184:#        push @sgs, $spec->SpeciesGraph  unless ( $spec->RulesApplied )
EnergyPattern.pm:189:#    unless ( exists $epatt->SpecMatches->[$max_idx] )
EnergyPattern.pm:190:#    {   $epatt->SpecMatches->[$max_idx] = undef;  }
EnergyPattern.pm:195:#        my @matches = $epatt->Pattern->isomorphicToSubgraph($sg);
EnergyPattern.pm:196:#        $epatt->SpecMatches->[ $sg->Species->Index ] = scalar @matches;
EnergyPattern.pm:202:        my @matches = $epatt->Pattern->isomorphicToSubgraph($spec->SpeciesGraph);
EnergyPattern.pm:203:        $epatt->SpecMatches->[ $spec->Index ] = scalar @matches;
EnergyPattern.pm:220:    foreach my $reactant (@{$rxn->Reactants})
EnergyPattern.pm:222:        if ( defined $epatt->SpecMatches->[ $reactant->Index ] )
EnergyPattern.pm:224:            $stoich -= $epatt->SpecMatches->[ $reactant->Index ];
EnergyPattern.pm:227:    foreach my $product (@{$rxn->Products})
EnergyPattern.pm:229:        if ( defined $epatt->SpecMatches->[ $product->Index ] )
EnergyPattern.pm:231:            $stoich += $epatt->SpecMatches->[ $product->Index ];
EnergyPattern.pm:251:    ($stoich, $err) = $epatt->getStoich( $rxn );
EnergyPattern.pm:259:        $rate_expr = Expression->new();
EnergyPattern.pm:264:                $rate_string = "(" . $epatt->Keq->toString($plist) . ")^("
EnergyPattern.pm:265:                                   . $epatt->Phi->toString($plist) . ")" ;               
EnergyPattern.pm:269:                $rate_string = "(" . $epatt->Keq->toString($plist) . ")^($stoich*("
EnergyPattern.pm:270:                                   . $epatt->Phi->toString($plist) . "))" ;   
EnergyPattern.pm:275:            if ( $stoich == -1 )
EnergyPattern.pm:277:                $rate_string = "(" . $epatt->Keq->toString($plist) . ")^("
EnergyPattern.pm:278:                                   . $epatt->Phi->toString($plist) . "-1)" ;               
EnergyPattern.pm:282:                $rate_string = "(" . $epatt->Keq->toString($plist) . ")^(abs($stoich)*("
EnergyPattern.pm:283:                                   . $epatt->Phi->toString($plist) . "-1))" ;   
EnergyPattern.pm:286:        $err = $rate_expr->readString( \$rate_string, $plist );  
Expression.pm:4:#   -added if statement as built in function
Expression.pm:5:#   -added binary logical operators, <,>.<=,>=,==,!=,~=,&&,||
Expression.pm:9:#   -todo: add binary operators to method toMathMLString function
Expression.pm:10:#   -todo: add the unary operator not: '!' (this is implemented, but not tested. --JSH)
Expression.pm:34:    Type    => '$',    # Valid types are 'NUM', 'VAR', 'FUN', '+', '-', '*', '/', '^', '**',
Expression.pm:41:# NOTE: it's weird that some built-in functions with names (like exp, cos, etc) are handled
Expression.pm:42:#  differently thant built-ins with operator symbols (like +, -, etc).  We could really simplify this.
Expression.pm:43:#  --Justin
Expression.pm:44:# Supported most muParser built-in functions. --Leonard 
Expression.pm:84:              '-'  => { 'min'=>1           },
Expression.pm:103:# ------------------
Expression.pm:105:# -   subtraction	 
Expression.pm:119:my $NUMBER_REGEX = '^[\+\-]?(\d+\.?\d*|\.\d+)(|[Ee][\+\-]?\d+|\*10\^[\+\-]?\d+)$';
Expression.pm:121:my $PARAM_REGEX  = '^[A-Za-z]\w*$';
Expression.pm:158:    my $clone = Expression->new();
Expression.pm:159:    $clone->Type( $expr->Type );
Expression.pm:160:    $clone->Arglist( $clone_args );
Expression.pm:161:    $clone->Err( '' );
Expression.pm:164:    foreach my $arg (  @{$expr->Arglist} )
Expression.pm:171:            ($clone_arg, $err) = $arg->clone($plist,$level+1);
Expression.pm:208:        $expr = Expression->new();
Expression.pm:209:        $expr->Type('NUM');
Expression.pm:210:        $expr->Arglist( [$value] );
Expression.pm:211:        $expr->Err( undef );
Expression.pm:220:            (my $param, $err) = $plist->lookup( $value );
Expression.pm:225:                $expr = Expression->new();
Expression.pm:226:                $expr->Type('VAR');
Expression.pm:227:                $expr->Arglist( [$value] );
Expression.pm:228:                $expr->Err( undef );            
Expression.pm:245:#   E.g. '+', '-', 'FUN'.
Expression.pm:247:#   a built-in or user-defined function.
Expression.pm:274:        my $fcn_name = $args_copy->[0];
Expression.pm:276:        # is this a built-in function?
Expression.pm:280:            return undef  unless (  $functions{ $fcn_name }->{NARGS} == (@$args_copy - 1)  );
Expression.pm:287:            (my $fcn_param, $err) = $plist->lookup( $fcn_name );
Expression.pm:290:            if ( ref $fcn_param  ne 'Param'  or  $fcn_param->Type ne 'Function' )
Expression.pm:294:            unless (  @{$fcn_param->Ref->Args} == (@$args_copy - 1)  )
Expression.pm:303:            {   ($arg, $err) = $arg->clone($plist);   }
Expression.pm:321:        if (  (exists $NARGS{$type}->{min})  and  (($NARGS{$type}->{min}) > (@$args_copy))  )
Expression.pm:323:        if (  (exists $NARGS{$type}->{max})  and  (($NARGS{$type}->{max}) < (@$args_copy))  )
Expression.pm:331:            {   ($arg, $err) = $arg->clone($plist);     }
Expression.pm:347:    my $expr = Expression->new();
Expression.pm:348:    $expr->Type( $type );
Expression.pm:349:    $expr->Arglist( $args_copy );
Expression.pm:350:    $expr->Err( undef );
Expression.pm:386:        my $ops_bi    = '\*\*|[+\-*/^]|>=|<=|[<>]|==|!=|~=|&&|\|\|';
Expression.pm:387:        my $ops_un    = '[+\-!~]';
Expression.pm:398:        # -5.0e+3/4
Expression.pm:412:                    my $express = Expression->new();
Expression.pm:413:                    $express->Type($1);
Expression.pm:430:                    my $param_name = $param->Arglist->[0];
Expression.pm:432:					# Make sure parameter name not the same as built-in functions --Leonard
Expression.pm:434:						return "Cannot use built-in function name '$param_name' as a parameter name.";
Expression.pm:437:                    unless ( $param->Type eq 'VAR' )
Expression.pm:438:                    {   return "Attempted assignment to non-variable type in $string_sav at $$sptr.";   }
Expression.pm:448:                    my $rhs = Expression->new();
Expression.pm:449:                    $err = $rhs->readString( $sptr, $plist, $end_chars, $level + 1 );
Expression.pm:453:                    if ( exists $variables->{$param_name} )
Expression.pm:461:                    $plist->set( $param_name, $rhs );
Expression.pm:494:                    # (optional) UNARY OP at start of expression, as in -a + b, or -a^2
Expression.pm:495:                    my $express_u = Expression->new();
Expression.pm:496:                    $express_u->Type($1);
Expression.pm:506:                    ($param, $err) = $plist->lookup($name); 
Expression.pm:511:                    $nargs = $functions{$name}->{NARGS};
Expression.pm:513:                elsif ( $param  and  ($param->Type eq 'Observable') )
Expression.pm:518:                elsif ( $param  and  ($param->Type eq 'Function') )
Expression.pm:521:                    $nargs = scalar( @{ $param->Ref->Args } );
Expression.pm:527:                        $plist->set($name);
Expression.pm:531:                        return "Function $name is not a built-in function, Observable, or defined Function";
Expression.pm:538:                    my $express = Expression->new();
Expression.pm:539:                    $err = $express->readString( $sptr, $plist, ',\)', $level + 1 );
Expression.pm:541:                    if ($express->Type) {   push @fargs, $express;   }
Expression.pm:559:                        if ($fargs[0]->Type ne "VAR"){
Expression.pm:563:                        (my $lv) = $plist->lookup($fargs[0]->Arglist->[0]);
Expression.pm:564:                        if ($lv->Type ne "Local"){
Expression.pm:577:                my $express = Expression->new();
Expression.pm:578:                $express->Type('FUN');
Expression.pm:579:                $express->Arglist( [ $name, @fargs ] );
Expression.pm:590:                    # (optional) UNARY OP at start of expression, as in -a + b, or -a^2
Expression.pm:591:                    my $express_u = Expression->new();
Expression.pm:592:                    $express_u->Type($1);
Expression.pm:604:                        my ( $param, $err ) = $plist->lookup($name);
Expression.pm:608:                            {   $plist->set($name);   }
Expression.pm:619:                my $express = Expression->new();
Expression.pm:620:                $express->Type('VAR');
Expression.pm:621:                $express->Arglist( [$name] );
Expression.pm:622:                ++($variables->{$name});
Expression.pm:633:                    # (optional) UNARY OP at start of expression, as in -a + b, or -a^2
Expression.pm:634:                    my $express_u = Expression->new();
Expression.pm:635:                    $express_u->Type($1);
Expression.pm:638:                my $express = Expression->new();
Expression.pm:639:                $err = $express->readString( $sptr, $plist, '\)', $level + 1 );
Expression.pm:646:                #printf "express=%s %s\n", $express->toString($plist), $$sptr;
Expression.pm:664:        if (@list) {  $expr->copy( arrayToExpression(@list) );  }
Expression.pm:690:    my $type = $expr->Type;
Expression.pm:698:        my $param_name = $expr->Arglist->[0];
Expression.pm:700:        if ( exists $dep->{$param_name} and $dep->{$param_name} )
Expression.pm:717:                (my $param) = $plist->lookup($param_name);
Expression.pm:722:                    $new_dep->{$param_name} = 1;
Expression.pm:723:                    (my $ret, $err) = $param->Expr->depends($plist, $varname, $level+1, $new_dep);
Expression.pm:726:                        $retval = $param_name . '->' . $ret;
Expression.pm:736:        my @arglist = @{ $expr->Arglist };
Expression.pm:741:            ($retval, $err) = $expr->depends($plist, $varname, $level + 1, $dep);
Expression.pm:764:    $edest->Type( $esource->Type );
Expression.pm:765:    $edest->Arglist( [ @{ $esource->Arglist } ] );
Expression.pm:786:    if ( $expr->Type eq 'NUM' )
Expression.pm:788:        $val = $expr->Arglist->[0];
Expression.pm:790:    elsif ( $expr->Type eq 'VAR' )
Expression.pm:793:        {  die "Expression->evaluate: Error! Cannot evaluate VAR type without ParamList.";  }
Expression.pm:795:        my $name = $expr->Arglist->[0];
Expression.pm:796:        $val = $plist->evaluate( $name, [], $level+1 );
Expression.pm:798:        {  die "Expression->evaluate: Error! Parameter $name is not defined!\n";  }
Expression.pm:800:    elsif ( $expr->Type eq 'FUN' )
Expression.pm:803:        my $name  = $expr->Arglist->[0];
Expression.pm:805:        # handle built-in functions
Expression.pm:808:            my $f = $functions{$name}->{FPTR};
Expression.pm:812:            while ( $ii < @{$expr->Arglist} )
Expression.pm:814:                push @$eval_args, $expr->Arglist->[$ii]->evaluate($plist, $level+1);
Expression.pm:817:            $val = $f->(@$eval_args);
Expression.pm:819:        # handle user-defined functions
Expression.pm:823:            {  die "Expression->evaluate: Error! Cannot evaluate user Function without ParamList.";  }
Expression.pm:825:            $val = $plist->evaluate( $name, $expr->Arglist, $level+1 );
Expression.pm:831:        my $operator = $expr->Type;
Expression.pm:833:        # replace non-perl operators with the perl equivalents
Expression.pm:838:        if ( @{$expr->Arglist} == 1 )
Expression.pm:842:                $eval_string = "1.0/(\$expr->Arglist->[0]->evaluate(\$plist,\$level+1))";
Expression.pm:846:                $eval_string = "$operator(\$expr->Arglist->[0]->evaluate(\$plist,\$level+1))";
Expression.pm:852:            my $last = @{$expr->Arglist} - 1;
Expression.pm:853:            $eval_string = join "$operator", map {"(\$expr->Arglist->[$_]->evaluate(\$plist,\$level+1))"} (0..$last);
Expression.pm:895:    unless (defined $plist)    {  die "Expression->evaluate_local: Error! Function called without required ParamList.";  }    
Expression.pm:902:    ($local_expr, $err) = $expr->clone( $plist, $level+1 );   
Expression.pm:905:    foreach my $arg ( @{$local_expr->Arglist} )
Expression.pm:909:        {   $arg = $arg->evaluate_local( $plist, $level+1 );   }
Expression.pm:913:    if ( $expr->Type eq 'FUN' )
Expression.pm:921:        my $name = $expr->Arglist->[0];
Expression.pm:922:        # Handle user-defined functions only (non-built-ins)
Expression.pm:926:            (my $fcn_param) = $plist->lookup( $name );
Expression.pm:929:            if ( $fcn_param->Type eq 'Function' )
Expression.pm:932:                my ($local_fcn, $elim_args) = $fcn_param->Ref->evaluate_local( $local_expr->Arglist, $plist, $level+1 );
Expression.pm:936:                $plist->set( $local_fcn->Name, $local_fcn->Expr, 1, 'Function', $local_fcn, 1 );
Expression.pm:939:                $local_expr->Arglist->[0] = $local_fcn->Name;
Expression.pm:944:                    splice @{$local_expr->Arglist}, $iarg, 1;
Expression.pm:948:            elsif ( $fcn_param->Type eq 'Observable' )
Expression.pm:950:                if ( @{$expr->Arglist} > 1 )
Expression.pm:953:                    my $val = $fcn_param->Ref->evaluate( $local_expr->Arglist, $plist, $level+1 );      
Expression.pm:957:                    $local_expr->Type('NUM');
Expression.pm:958:                    $local_expr->Arglist($args);
Expression.pm:959:                    $local_expr->Err(undef);
Expression.pm:964:            {   $err = "ERROR in Expression->evaluate_local(): expression is a function, but ref type is unknown!";   }   
Expression.pm:986:    {   die "Expression->checkLocalDependency: Error! Missing argument ParamList!";   }
Expression.pm:990:    foreach my $arg ( @{$expr->Arglist} )
Expression.pm:994:            return 1  if ( $arg->checkLocalDependency( $plist, $level+1 ) );
Expression.pm:998:    if ( $expr->Type eq 'FUN' )
Expression.pm:1001:        unless ( exists $functions{ $expr->Arglist->[0] } )
Expression.pm:1004:            my ($fcn_param) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1006:            if ( $fcn_param->Type eq 'Function' ) 
Expression.pm:1008:                my $fcn = $fcn_param->Ref;            
Expression.pm:1009:                return 1  if ( $fcn->checkLocalDependency( $plist, $level+1 ) );
Expression.pm:1011:            elsif ( $fcn_param->Type eq 'Observable' )
Expression.pm:1014:                return (@{$expr->Arglist} > 1 ? 1 : 0);
Expression.pm:1044:    return 0  unless ( $expr1->Type  eq  $expr2->Type );
Expression.pm:1047:    return 0  unless ( @{$expr1->Arglist} == @{$expr2->Arglist} );
Expression.pm:1050:    if    ( $expr1->Type eq 'NUM' )
Expression.pm:1053:        return ( $expr1->Arglist->[0]  ==  $expr2->Arglist->[0] );
Expression.pm:1055:    elsif ( $expr2->Type eq 'VAR' )
Expression.pm:1058:        return ( $expr1->Arglist->[0]  eq  $expr2->Arglist->[0] );
Expression.pm:1060:    elsif ( $expr2->Type eq 'FUN' )
Expression.pm:1063:        return 0  unless ( $expr1->Arglist->[0] eq $expr2->Arglist->[0] );
Expression.pm:1066:        for ( my $i = 1;  $i < @{$expr1->Arglist};  ++$i )
Expression.pm:1069:                unless ( Expression::equivalent($expr1->Arglist->[$i], $expr2->Arglist->[$i], $plist, $level+1) );
Expression.pm:1075:        for ( my $i = 0;  $i < @{$expr1->Arglist};  ++$i )
Expression.pm:1078:                unless ( Expression::equivalent($expr1->Arglist->[$i], $expr2->Arglist->[$i], $plist, $level+1) );
Expression.pm:1107:    my $type = $expr->Type;
Expression.pm:1111:        $string = $expr->Arglist->[0];
Expression.pm:1119:            ( my $param, $err ) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1120:             $string = $param->toString( $plist, $level+1, $expand );
Expression.pm:1125:            $string = $expr->Arglist->[0];
Expression.pm:1127:        #$string= $expr->evaluate($plist);
Expression.pm:1136:            foreach my $i ( 1 .. $#{ $expr->Arglist } ) {
Expression.pm:1137:                push @sarr, $expr->Arglist->[$i]->toString( $plist, $level + 1 );
Expression.pm:1139:            $string = $expr->Arglist->[0] . '(' . join( ',', @sarr ) . ')';
Expression.pm:1144:            foreach my $i ( 1 .. $#{ $expr->Arglist } ) {
Expression.pm:1145:                push @sarr, $expr->Arglist->[$i]->toString( $plist, $level + 1 );
Expression.pm:1147:            $string = $expr->Arglist->[0] . '(' . join( ',', @sarr ) . ')';
Expression.pm:1155:            foreach my $e ( @{ $expr->Arglist } ) {
Expression.pm:1156:                push @sarr, $e->toString( $plist, $level+1, $expand );
Expression.pm:1171:            foreach my $e ( @{ $expr->Arglist } ) {
Expression.pm:1172:                push @sarr, $e->toString( $plist, $level + 1 );
Expression.pm:1187:            #printf "%s=$string\n", $expr->Type;
Expression.pm:1214:    my $type = $expr->Type;
Expression.pm:1218:        $string = $expr->Arglist->[0];
Expression.pm:1225:            ( my $param, $err ) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1226:             $string = $param->toXML( $plist, $level+1, $expand );
Expression.pm:1231:            $string = $expr->Arglist->[0];
Expression.pm:1240:            foreach my $i ( 1 .. $#{$expr->Arglist} )
Expression.pm:1242:                push @sarr, $expr->Arglist->[$i]->toXML( $plist, $level + 1 );
Expression.pm:1244:            $string = $expr->Arglist->[0] . '(' . join( ',', @sarr ) . ')';
Expression.pm:1249:            foreach my $i ( 1 .. $#{$expr->Arglist} )
Expression.pm:1251:                push @sarr, $expr->Arglist->[$i]->toXML( $plist, $level + 1 );
Expression.pm:1253:            $string = $expr->Arglist->[0] . '(' . join( ',', @sarr ) . ')';
Expression.pm:1261:            foreach my $e ( @{$expr->Arglist} )
Expression.pm:1263:                push @sarr, $e->toXML( $plist, $level+1, $expand );
Expression.pm:1278:            foreach my $e ( @{ $expr->Arglist } ) {
Expression.pm:1279:                push @sarr, $e->toXML( $plist, $level + 1 );
Expression.pm:1294:            #printf "%s=$string\n", $expr->Type;
Expression.pm:1299:    #  or a toXML sub.  --Justin
Expression.pm:1336:    my $type   = $expr->Type;
Expression.pm:1340:        $string = $expr->Arglist->[0];
Expression.pm:1348:        (my $param, $err) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1351:            $string = $param->getCVodeName();   
Expression.pm:1355:            $string = $expr->Arglist->[0];
Expression.pm:1361:        my $fcn_name = $expr->Arglist->[0];
Expression.pm:1363:        # first see if this is a built-in function (e.g. sin, cos, exp..)
Expression.pm:1364:        if ( exists $functions{ $expr->Arglist->[0] } )
Expression.pm:1366:            # handle built-ins with 1 argument that have the same name in the C library
Expression.pm:1369:                my @sarr = ( map {$_->toCVodeString($plist, $level+1, $expand)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1372:            # handle the 'if' built-in with 3 arguments
Expression.pm:1376:                my @sarr = ( map {$_->toCVodeString($plist, $level+1)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1381:                {   die "Error in Expression->toCVodeString():  built-in function 'if' must have three arguments!";   }    
Expression.pm:1383:            # fatal error if the built-in is not handled above
Expression.pm:1385:            {   die "Error in Expression->toCVodeString():  don't know how to handle built-in function $fcn_name!";   }
Expression.pm:1388:        # otherwise, this is a user-defined function or observable
Expression.pm:1393:            (my $fcn_param) = $plist->lookup( $fcn_name );
Expression.pm:1395:            {   die "Error in Expression->toCVodeString: could not find function parameter!";   }
Expression.pm:1398:            if ( $fcn_param->Type eq 'Function' )
Expression.pm:1401:                my @sarr = ( map {$_->toCVodeString($plist, $level+1, $expand)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1406:            elsif ( $fcn_param->Type eq 'Observable' )
Expression.pm:1410:                $string = $fcn_param->getCVodeName();
Expression.pm:1413:            {   die "Error in Expression->toCVodeString(): don't know how to process function expression of non-function type!";   }
Expression.pm:1421:        my @sarr = ( map {$_->toCVodeString($plist, $level+1)} @{$expr->Arglist} );
Expression.pm:1426:        {   die "Error in Expression->toCVodeString(): Exponentiation must have exactly two arguments!";   }
Expression.pm:1430:        # handling some other operator (+,-,*,/)
Expression.pm:1432:        my @sarr = ( map {$_->toCVodeString($plist, $level+1, $expand)} @{$expr->Arglist} );
Expression.pm:1450:#  export to a Matlab M-file.
Expression.pm:1463:    my $type   = $expr->Type;
Expression.pm:1467:        $string = $expr->Arglist->[0];
Expression.pm:1472:        (my $param, $err) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1475:            $string = $param->getMatlabName();   
Expression.pm:1479:            $string = $expr->Arglist->[0];
Expression.pm:1485:        my $fcn_name = $expr->Arglist->[0];
Expression.pm:1487:        # first see if this is a built-in function (e.g. sin, cos, exp..)
Expression.pm:1488:        if ( exists $functions{ $expr->Arglist->[0] } )
Expression.pm:1490:            # handle built-ins with 1 argument that have the same name in Matlab
Expression.pm:1493:                my @sarr = ( map {$_->toMatlabString($plist, $level+1, $expand)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1496:            # handle the 'if' built-in with 3 arguments
Expression.pm:1500:                my @sarr = ( map {$_->toMatlabString($plist, $level+1)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1505:                {   die "Error in Expression->toMatlabString():  built-in function 'if' must have three arguments!";   }    
Expression.pm:1507:            # fatal error if the built-in is not handled above
Expression.pm:1509:            {   die "Error in Expression->toMatlabString():  don't know how to handle built-in function $fcn_name!";   }
Expression.pm:1512:        # otherwise, this is a user-defined function or observable
Expression.pm:1517:            (my $fcn_param) = $plist->lookup( $fcn_name );
Expression.pm:1519:            {   die "Error in Expression->toMatlabString: could not find function parameter!";   }
Expression.pm:1522:            if ( $fcn_param->Type eq 'Function' )
Expression.pm:1525:                my @sarr = ( map {$_->toMatlabString($plist, $level+1, $expand)} @{$expr->Arglist}[1..$#{$expr->Arglist}] );
Expression.pm:1530:            elsif ( $fcn_param->Type eq 'Observable' )
Expression.pm:1534:                $string = $fcn_param->getMatlabName();
Expression.pm:1537:            {   die "Error in Expression->toMatlabString(): don't know how to process function expression of non-function type!";   }
Expression.pm:1544:        # handling some other operator (+,-,*,/)
Expression.pm:1546:        my @sarr = ( map {$_->toMatlabString($plist, $level+1, $expand)} @{$expr->Arglist} );
Expression.pm:1570:        '-'  => 'minus',
Expression.pm:1595:        my $type = $expr->Type;
Expression.pm:1598:            $string .= sprintf "%s<cn> %s </cn>\n", $indentp, $expr->Arglist->[0];
Expression.pm:1602:            $string .= sprintf "%s<ci> %s </ci>\n", $indentp, $expr->Arglist->[0];
Expression.pm:1607:            my @arglist  = @{ $expr->Arglist };
Expression.pm:1611:                $string .= $e->toMathMLString( $plist, $indentpp, $level + 1 );
Expression.pm:1619:            $string .= sprintf "%s<%s/>\n", $indentpp, $ophash{ $expr->Type };
Expression.pm:1620:            foreach my $e ( @{ $expr->Arglist } )
Expression.pm:1622:                $string .= $e->toMathMLString( $plist, $indentpp, $level + 1 );
Expression.pm:1641:    my @operators = ( '\*\*|\^', '[*/]', '[+-]','[<>]|==|!=|~=|>=|<=','&&|\|\|'); #edited, msneddon
Expression.pm:1651:            if ( $expr->Type =~ /$optype/ && !( @{ $expr->Arglist } ) )
Expression.pm:1655:                    $expr->Arglist->[0] = $earr[ $i - 1 ];
Expression.pm:1656:                    $expr->Arglist->[1] = $earr[ $i + 1 ];
Expression.pm:1657:                    splice @earr, $i - 1, 3, $expr;
Expression.pm:1662:                    # Handle leading unary op, as in -a + b
Expression.pm:1663:                    $expr->Arglist->[0] = $earr[ $i + 1 ];
Expression.pm:1691:    if ( $$string =~ s/^([+-]?\d+)([.]?\d*)// )
Expression.pm:1703:    elsif ( $$string =~ s/^([+-]?[.]\d+)// )
Expression.pm:1713:    if ( $$string =~ s/^([DEFGdefg][+-]?\d+)// )
Expression.pm:1717:    elsif ( $$string =~ /^[A-Za-z_]/ )
Expression.pm:1725:    my $express = Expression->new();
Expression.pm:1726:    $express->Type('NUM');
Expression.pm:1727:    $express->Arglist( [$number] );
Expression.pm:1745:    if ( $expr->Type eq 'VAR'  and  !$force_fcn )
Expression.pm:1747:        $name = $expr->Arglist->[0];
Expression.pm:1756:            my ( $param, $err ) = $plist->lookup( $basename . $index );
Expression.pm:1763:        $plist->set( $name, $expr, 0, ($force_fcn ? 'Function' : '') );
Expression.pm:1789:    my $type = $expr->Type;
Expression.pm:1796:        my ( $param, $err ) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1798:        if ( defined $param->Type )
Expression.pm:1800:            $rethash->{ $param->Type }->{ $param->Name } = $param;
Expression.pm:1804:            $rethash->{ 'UNDEF' }->{ $param->Name } = $param;
Expression.pm:1809:        my ( $param, $err ) = $plist->lookup( $expr->Arglist->[0] );
Expression.pm:1812:            #printf "function is a built-in\n";      
Expression.pm:1816:            $rethash->{$param->Type}->{ $param->Name } = $param;
Expression.pm:1819:        foreach my $i ( 1 .. $#{$expr->Arglist} )
Expression.pm:1821:            $expr->Arglist->[$i]->getVariables( $plist, $level + 1, $rethash );
Expression.pm:1826:        foreach my $e ( @{ $expr->Arglist } )
Expression.pm:1828:            $e->getVariables( $plist, $level + 1, $rethash );
Function.pm:38:    my ($clone_name) = $same_name ? $fcn->Name : $plist->getName($fcn->Name);
Function.pm:41:    (my $clone_expr, $err) = $fcn->Expr->clone( $plist, $level+1 );
Function.pm:43:    my $clone = Function->new( Name=>$clone_name, Expr=>$clone_expr, Args=>[@{$fcn->Args}] );            
Function.pm:61:    my $local_plist = $plist->getChildList();
Function.pm:67:        $local_plist->set( $fcn->Args->[$ii-1], $args->[$ii], 1, $args->[$ii]->Type );
Function.pm:72:    return $fcn->Expr->evaluate($local_plist, $level+1);
Function.pm:90:    my ($local_fcn, $err) = $fcn->clone( $plist, $level+1 );
Function.pm:93:    my $local_plist = $plist->getChildList();
Function.pm:98:        $local_plist->set( $fcn->Args->[$ii-1], $args->[$ii], 1 );
Function.pm:103:    my $expr = $local_fcn->Expr->evaluate_local($local_plist, $level+1);
Function.pm:104:    $local_fcn->Expr( $expr );
Function.pm:109:    while ( $ii < @{$local_fcn->Args} )
Function.pm:111:        my ($dep, $err) = $expr->depends( $plist, $fcn->Args->[$ii] );
Function.pm:120:            splice @{$local_fcn->Args}, $ii, 1;
Function.pm:141:    return  $fcn->Expr->checkLocalDependency( $plist, $level+1 );
Function.pm:167:    return 0  unless ( @{$fcn1->Args} == @{$fcn2->Args} );
Function.pm:170:    for ( my $i = 0;  $i < @{$fcn1->Args};  ++$i )
Function.pm:172:        return 0 unless ( $fcn1->Args->[$i] eq $fcn2->Args->[$i] );
Function.pm:176:    return 0  unless ( Expression::equivalent($fcn1->Expr, $fcn2->Expr, $plist) );
Function.pm:195:    my $plist = $model->ParamList;
Function.pm:204:    if ( $string =~ s/^\s*([A-Za-z0-9_]+)\s*// )
Function.pm:207:        $fun->Name($name);
Function.pm:209:        # Make sure function name not the same as built-in functions --Leonard
Function.pm:211:			return "Cannot use built-in function name '$name' as a user-defined function name.";
Function.pm:226:            if ( $string =~ s/^\s*([A-Za-z0-9_]+)\s*// )
Function.pm:230:                if ( $plist->set( $arg, '0', 1, 'Local' ) )
Function.pm:232:                    my $name = $fun->Name;
Function.pm:235:                #printf "Added argument %s to function %s\n", $arg, $fun->Name;
Function.pm:248:                my $name= $fun->Name;
Function.pm:252:        $fun->Args( [@Args] );
Function.pm:259:    my $expr = Expression->new();
Function.pm:260:    $expr->setAllowForward(1);  # don't complain if expression refers to undefined parameters
Function.pm:261:    if ( my $err = $expr->readString( \$string, $plist ) ) {  return ($err);  }
Function.pm:263:    $expr->setAllowForward(0);
Function.pm:265:    $fun->Expr($expr);
Function.pm:268:    if ( $plist->set( $fun->Name, $expr, 1, "Function", $fun ) )
Function.pm:270:        my $name = $fun->Name;
Function.pm:274:    $fun->unsetArgs($plist);
Function.pm:293:    my $string = $fun->Name . '(' . join(',', @{$fun->Args}) . ')';
Function.pm:294:    if ( $fun->Expr )
Function.pm:297:        $string .= $fun->Expr->toString($plist);
Function.pm:303:        my $n_spaces = $max_length - pos $string;
Function.pm:328:    unless ( exists $arghash->{fcn_mode} )
Function.pm:329:    {    $arghash->{fcn_mode} = 'call';   }
Function.pm:332:    unless ( exists $arghash->{indent} )
Function.pm:333:    {    $arghash->{indent} = '';   }
Function.pm:336:    if ( $arghash->{fcn_mode} eq 'call' )
Function.pm:339:        my @args = ( @{$fcn->Args}, 'expressions', 'observables' );
Function.pm:340:        $string = $arghash->{indent} . $fcn->Name . '(' . join(',', @args) . ')';
Function.pm:342:    elsif ( $arghash->{fcn_mode} eq 'declare' ) 
Function.pm:345:        my @args = ( (map { "double $_" } @{$fcn->Args}), 'N_Vector expressions', 'N_Vector observables' );
Function.pm:346:        $string = $arghash->{indent} . "double " . $fcn->Name . " ( " . join(', ', @args) . " );\n";
Function.pm:348:    elsif ( $arghash->{fcn_mode} eq 'define' )
Function.pm:351:        my @args = ( (map { "double $_" } @{$fcn->Args}), 'N_Vector expressions', 'N_Vector observables' );
Function.pm:353:        $string .= $arghash->{indent} . "/* user-defined function " . $fcn->Name . " */\n";
Function.pm:354:        $string .= $arghash->{indent} . "double " . $fcn->Name . " ( " . join(', ', @args) . " )\n";
Function.pm:355:        $string .= $arghash->{indent} . "{\n";
Function.pm:356:        $string .= $arghash->{indent} . "    return " . $fcn->Expr->toCVodeString($plist) . ";\n"; 
Function.pm:357:        $string .= $arghash->{indent} . "}\n";     
Function.pm:360:    {    die "Error in Function->toCVodeString(): did not recognize fcn_mode argument!";   }
Function.pm:381:    unless ( exists $arghash->{fcn_mode} )
Function.pm:382:    {    $arghash->{fcn_mode} = 'call';   }
Function.pm:385:    unless ( exists $arghash->{indent} )
Function.pm:386:    {    $arghash->{indent} = '';   }
Function.pm:389:    if ( $arghash->{fcn_mode} eq 'call' )
Function.pm:392:        my @args = ( @{$fcn->Args}, 'expressions', 'observables' );
Function.pm:393:        $string = $arghash->{indent} . $fcn->Name . '(' . join(',', @args) . ')';
Function.pm:395:    elsif ( $arghash->{fcn_mode} eq 'declare' ) 
Function.pm:401:    elsif ( $arghash->{fcn_mode} eq 'define' )
Function.pm:404:        my @args = ( @{$fcn->Args}, 'expressions', 'observables' );
Function.pm:405:        $string .= $arghash->{indent} . '% function ' . $fcn->Name . "\n";
Function.pm:406:        $string .= $arghash->{indent} . 'function [val] = ' . $fcn->Name . '(' . join(', ', @args) . ")\n"
Function.pm:407:                                      . '    val = ' . $fcn->Expr->toMatlabString($plist) . ";\n"
Function.pm:411:    {    die "Error in Function->toMatlabString(): did not recognize fcn_mode argument!";   }
Function.pm:429:    foreach my $arg ( @{$fun->Args} )
Function.pm:431:        $plist->set( $arg, '0', 1, 'Local' ); 
Function.pm:450:    foreach my $arg ( @{$fun->Args} )
Function.pm:452:        $plist->deleteLocal($arg);
Function.pm:471:    $fun->setArgs($plist);
Function.pm:479:    $string .= " id=\"".$fun->Name."\"";
Function.pm:483:    if ( @{$fun->Args} )
Function.pm:486:        foreach my $arg (@{$fun->Args})
Function.pm:497:    my $vhash= $fun->Expr->getVariables($plist);
Function.pm:501:        foreach my $var (keys %{$vhash->{$type}})
Function.pm:504:            $string .= $indent3 . ($vhash->{$type}->{$var})->toXMLReference('Reference', '', $plist);
Function.pm:510:    $string .= $fun->Expr->toXML($plist);
Function.pm:515:    $fun->unsetArgs($plist);
HNauty.pm:64:  # define adj_in - note that this example is not really directed
HNauty.pm:68:    for $j ( keys %{ $adj_out->{$i} } ) {
HNauty.pm:69:      @{ $adj_in->{$j}{$i} } = @{ $adj_out->{$i}{$j} };
HNauty.pm:96:    print Data::Dumper->Dump( [$new_adj] );
HNauty.pm:111:    print Data::Dumper->Dump( [$adj_infor] );
HNauty.pm:118:    # print Data::Dumper->Dump([$le_adj, $new_adj]);
HNauty.pm:144:    print Data::Dumper->Dump( [$result] );
HNauty.pm:157:    print Data::Dumper->Dump( [$result] );
HNauty.pm:187:    print Data::Dumper->Dump( [ $fix, $orbit_reps, $autos ] );
HNauty.pm:189:    print Data::Dumper->Dump( [ $fix, $orbit_reps, $autos ] );
HNauty.pm:195:    print Data::Dumper->Dump( [$autos] );
HNauty.pm:206:    print Data::Dumper->Dump( [$autos] );
HNauty.pm:232:    for $j ( keys %{ $he_out->{$i} } ) {
HNauty.pm:233:      @{ $he_in->{$j}{$i} } = @{ $he_out->{$i}{$j} };
HNauty.pm:269:    print Data::Dumper->Dump( [$result] );
HNauty.pm:273:    print Data::Dumper->Dump( [$result] );
HNauty.pm:277:    print Data::Dumper->Dump( [$result] );
HNauty.pm:361:      and ( not defined( $perm_fix->{ @{ @$partition[$i] }[0] } ) ) )
HNauty.pm:393:        delete( $un_used->{$element} );
HNauty.pm:394:        $element = $perm->{$element};
HNauty.pm:395:        if ( not defined( $un_used->{$element} ) ) {
HNauty.pm:405:        $fix->{ @$cycle[0] } = 1;
HNauty.pm:422:    $tmp->{ scalar @$j } += 1;
HNauty.pm:427:    if ( defined( $tmp->{$j} ) ) {
HNauty.pm:428:      push @$indicator, $tmp->{$j};
HNauty.pm:448:    $new_i = $perm->{$i};
HNauty.pm:449:    $new_adj->{$new_i} = {};
HNauty.pm:450:    for $j ( keys %{ $adj->{$i} } ) {
HNauty.pm:451:      $new_j = $perm->{$j};
HNauty.pm:452:      @{ $new_adj->{$new_i}{$new_j} } = @{ $adj->{$i}{$j} };
HNauty.pm:470:      $perm->{ @{ @$part[$i] }[0] } = $i;
HNauty.pm:476:  $length = ( scalar keys %$adj ) - 1;
HNauty.pm:480:      if ( defined( $new_adj->{$i}{$j} ) ) {
HNauty.pm:482:        for $e ( @{ $new_adj->{$i}{$j} } ) {
HNauty.pm:557:    $union->{$ele}++ && $inter->{$ele}++;
HNauty.pm:624:      $cell->{$v} = 1;
HNauty.pm:634:          for $u ( keys %{ $adj_out->{$v} } ) {
HNauty.pm:635:            for $e ( @{ $adj_out->{$v}{$u} } ) {
HNauty.pm:636:              if ( defined( $cell->{$u} ) ) {
HNauty.pm:637:                $count->{$e} += 1;
HNauty.pm:642:            if ( not defined( $out_degree_count->{$e} ) ) {
HNauty.pm:643:              $out_degree_count->{$e}{0} =
HNauty.pm:647:            $out_degree_count->{$e}{ $count->{$e} }{$v} = 1;
HNauty.pm:648:            if ( defined( $out_degree_count->{$e}{0}{$v} ) ) {
HNauty.pm:649:              delete( $out_degree_count->{$e}{0}{$v} );
HNauty.pm:655:          for $u ( keys %{ $adj_in->{$v} } ) {
HNauty.pm:656:            for $e ( @{ $adj_in->{$v}{$u} } ) {
HNauty.pm:657:              if ( defined( $cell->{$u} ) ) {
HNauty.pm:658:                $count->{$e} += 1;
HNauty.pm:663:            if ( not defined( $in_degree_count->{$e} ) ) {
HNauty.pm:664:              $in_degree_count->{$e}{0} =
HNauty.pm:668:            $in_degree_count->{$e}{ $count->{$e} }{$v} = 1;
HNauty.pm:669:            if ( defined( $in_degree_count->{$e}{0}{$v} ) ) {
HNauty.pm:670:              delete( $in_degree_count->{$e}{0}{$v} );
HNauty.pm:679:          for $size ( sort ( keys %{ $out_degree_count->{$e} } ) ) {
HNauty.pm:680:            if ( scalar( keys %{ $out_degree_count->{$e}{$size} } ) > 0 ) {
HNauty.pm:683:                ( keys %{ $out_degree_count->{$e}{$size} } );
HNauty.pm:695:          for $size ( sort ( keys %{ $in_degree_count->{$e} } ) ) {
HNauty.pm:696:            if ( scalar( keys %{ $in_degree_count->{$e}{$size} } ) > 0 ) {
HNauty.pm:699:                ( keys %{ $in_degree_count->{$e}{$size} } );
HNauty.pm:745:            @$equitable_partition[ 0 .. $partition_count - 1 ],
HNauty.pm:817:      $counter += -1;
HNauty.pm:848:        $counter += -1;
HNauty.pm:880:      delete( $some_hash->{$vertex} );
HNauty.pm:883:        @$this_partition[ 0 .. $t - 1 ],
HNauty.pm:896:          $counter   = $i[1] - 1;
HNauty.pm:930:                  $new_auto->{ @{ @{ @$best_node[0] }[$i] }[0] } =
HNauty.pm:953:                $new_auto->{ @{ @{ @$first_terminal_node[0] }[$i] }[0] } =
HNauty.pm:987:    $perm->{ @{ @{ @$best_node[0] }[$i] }[0] } = $i;
HNauty.pm:1005:    +{ map { $_ => deepCopy( $this->{$_} ) } keys %$this };
MacroBNGModel.pm:19:my $HAVE_PS=0; # Set to 0 for MS Windows systems with no ps command - disables reporting of 
MacroBNGModel.pm:39:    $base_model= BNGModel->new();
MacroBNGModel.pm:45:	$NO_EXEC=$params->{no_exec};
MacroBNGModel.pm:48:	$fname=$params->{file};
MacroBNGModel.pm:56:	$prefix=$params->{prefix};
MacroBNGModel.pm:68:print "\n#################-START BASEMODEL-#####################\n";
MacroBNGModel.pm:69:  if ($err=$base_model->readFile(\%params)){ 
MacroBNGModel.pm:72:print "\n#################-FINISH BASEMODEL-#####################\n";
MacroBNGModel.pm:78:my $slist=$base_model->SpeciesList;
MacroBNGModel.pm:79:$err = $slist->readString($entry,$base_model->ParamList,$base_model->MoleculeTypesList);
MacroBNGModel.pm:80:##$slist->print(*STDOUT, $mtlist);
MacroBNGModel.pm:94:    $base_model->UpdateNet(0);
MacroBNGModel.pm:95:    if ($err=$base_model->readFile(\%params)){ 
MacroBNGModel.pm:104:#pre_macr-begin
MacroBNGModel.pm:132:      my $plist= ParamList->new;
MacroBNGModel.pm:133:      $base_model->ParamList($plist);
MacroBNGModel.pm:134:      my $mtlist= MoleculeTypesList->new;
MacroBNGModel.pm:135:      $base_model->MoleculeTypesList($mtlist); 
MacroBNGModel.pm:167:	      if ($err=$plist->readString($entry)){
MacroBNGModel.pm:172:	    printf "Read %d parameters.\n", scalar(@{$plist->Array});
MacroBNGModel.pm:177:	    my $mtlist= $base_model->MoleculeTypesList;
MacroBNGModel.pm:180:	      if ($err=$mtlist->readString($entry,$mtlist)){
MacroBNGModel.pm:185:	    printf "Read %d molecule types.\n", scalar(keys %{$mtlist->MolTypes});
MacroBNGModel.pm:188:	    my $slist= SpeciesList->new;
MacroBNGModel.pm:191:	      if ($err=$slist->readString($entry,$base_model->ParamList,$base_model->MoleculeTypesList)){
MacroBNGModel.pm:196:	    printf "Read %d species.\n", scalar(@{$slist->Array});
MacroBNGModel.pm:197:	    $base_model->SeedSpeciesList($slist);
MacroBNGModel.pm:198:	    $base_model->SpeciesList($slist);
MacroBNGModel.pm:201:	    my $slist= SpeciesList->new;
MacroBNGModel.pm:205:	      if ($err=$slist->readString($entry,$base_model->ParamList,$base_model->MoleculeTypesList)){
MacroBNGModel.pm:210:	    printf "Read %d species.\n", scalar(@{$slist->Array});
MacroBNGModel.pm:211:	    $base_model->SpeciesList($slist);
MacroBNGModel.pm:231:	      ($rrs,$err)= RxnRule::newRxnRule($entry, $base_model->ParamList, $base_model->MoleculeTypesList);
MacroBNGModel.pm:244:	    $base_model->RxnRules([@rrules]);
MacroBNGModel.pm:245:	    printf "Read %d reaction rule(s).\n", scalar(@{$base_model->RxnRules});
MacroBNGModel.pm:248:	    my $rlist= RxnList->new;
MacroBNGModel.pm:251:	      if ($err=$rlist->readString($entry,$base_model->SpeciesList,$base_model->ParamList)){
MacroBNGModel.pm:257:	    $base_model->RxnList($rlist);
MacroBNGModel.pm:260:	    if (!$base_model->Observables){
MacroBNGModel.pm:265:	    my $maxobs= $#{$base_model->Observables};
MacroBNGModel.pm:272:	      my $obs= $base_model->Observables->[$iobs];
MacroBNGModel.pm:273:	      if ($tokens[0] ne $obs->Name){
MacroBNGModel.pm:279:	      *weights= $obs->Weights;
MacroBNGModel.pm:289:		  $err=errgen("Non-integer group entry: $elt",$lno);
MacroBNGModel.pm:306:	      my $obs= Observable->new();
MacroBNGModel.pm:307:	      if ($err=$obs->readString($entry,$base_model->MoleculeTypesList)){
MacroBNGModel.pm:313:	    $base_model->Observables([@observables]);
MacroBNGModel.pm:314:	    printf "Read %d observable(s).\n", scalar(@{$base_model->Observables});
MacroBNGModel.pm:320:	} elsif (/^([A-Za-z][^(]*)/){
MacroBNGModel.pm:368:      next unless -e $file;
MacroBNGModel.pm:372:#pre_macr-end
MacroBNGModel.pm:374:##pre_species1-begin
MacroBNGModel.pm:397:      foreach (@sit) {  $nm_site->{$name.":".$_}++; }   # L:l 2; 
MacroBNGModel.pm:399:        if ( $key=~/:/ && $val gt 1 ) { $nm2_site->{$key} = $val; }  
MacroBNGModel.pm:401:      $nm_site->{$name}= scalar(@sit);        # L 2
MacroBNGModel.pm:408:#pre_species1-end
MacroBNGModel.pm:410:#pre_rules-begin
MacroBNGModel.pm:418:                 #     ----------RULES-------------
MacroBNGModel.pm:429: &hierarch_sit($dpp_site);        #----prepare hierarchy set2 of variables
MacroBNGModel.pm:437:#pre_rules-end
MacroBNGModel.pm:439:#del_blank-begin
MacroBNGModel.pm:442: for ( @{$str} ) {        # 1  L(r) + R(l,d) <-> L(r!1).R(l!1,d) kp1, km1 14
MacroBNGModel.pm:449:       s/\s{1}/;/g;             #1;L(r);+;R(l,d);<->;L(r!1).R(l!1,d);kp1,;km1
MacroBNGModel.pm:452:       } else {                  #;L(r);+;R(l,d);<->;L(r!1).R(l!1,d);kp1,;km1
MacroBNGModel.pm:455:       push @{$lis1}, $_;        #;L(r);+;R(l,d);<->;L(r!1).R(l!1,d);kp1,;km1
MacroBNGModel.pm:460:#del_blank-end
MacroBNGModel.pm:462:#hash_skf-begin
MacroBNGModel.pm:470:   $rab = $_;              #;Rec(a);+;Lig(l,l);<->;Rec(a!1).Lig(l!1,l);kp1,;km1
MacroBNGModel.pm:471:   $rab =~ /<->|->/;    
MacroBNGModel.pm:489:     foreach (@{$skf->{$key_d}}) { print WFILErec " $_ "; }
MacroBNGModel.pm:494:#hash_skf-end
MacroBNGModel.pm:496:#inc_elt-begin
MacroBNGModel.pm:509:#inc_elt-end
MacroBNGModel.pm:511:#inc-set-begin                 # There are dubl-elements !!!
MacroBNGModel.pm:520:      $jj--;
MacroBNGModel.pm:526:#inc-set-end
MacroBNGModel.pm:528:#del-set-begin                 # There are dubl-elements !!!
MacroBNGModel.pm:538:      $jj--;
MacroBNGModel.pm:543:#del-set-end
MacroBNGModel.pm:546:#inc-set-begin
MacroBNGModel.pm:561:#inc-set-end
MacroBNGModel.pm:563:#activ_sit-begin
MacroBNGModel.pm:580:#activ_sit-end
MacroBNGModel.pm:582:#hierarch_sit-begin
MacroBNGModel.pm:600:      $tab_site{$_} = 1;       # SH2->1 U->1  
MacroBNGModel.pm:617:    delete $dpp_site->{$key};  #  Lyn:SH2    Lyn:U        
MacroBNGModel.pm:619:    @{$dpp_site->{$key}} = @c;        # (13456)
MacroBNGModel.pm:623:    print WFILErec " $key @{$dpp_site->{$key}}\n";
MacroBNGModel.pm:628:#hierarch_sit-end
MacroBNGModel.pm:630:#min_set-begin
MacroBNGModel.pm:631:sub min_set{                    #----prepare minimal set of variables
MacroBNGModel.pm:662:   delete $dpp_site->{$_};
MacroBNGModel.pm:666:   @rabm = @{$dpp_site->{$key}};
MacroBNGModel.pm:667:   if ( ($nm_site->{$key2}) == ($#rabm+1) )  {
MacroBNGModel.pm:668:      delete $dpp_site->{$key} ;
MacroBNGModel.pm:673:   print WFILErec " $key, @{$dpp_site->{$key}}\n";
MacroBNGModel.pm:676:   @rabm = @{$dpp_site->{$key}};          # site1 site3
MacroBNGModel.pm:682:   if ( $site_lig->{$key} > 1 ) {
MacroBNGModel.pm:683:     print WFILErec " $key, $site_lig->{$key}\n";
MacroBNGModel.pm:685:     delete $site_lig->{$key};
MacroBNGModel.pm:692:     print WFILErec " $key, @{$lis1h->{$key}}\n";
MacroBNGModel.pm:694:     delete $lis1h->{$key};
MacroBNGModel.pm:699:#min_set-end
MacroBNGModel.pm:701:#num_site-begin
MacroBNGModel.pm:729:    if ( defined($nm2_site->{$name.":".$_}) ) {           # Lig:l
MacroBNGModel.pm:730:      for ($ii=2;$ii<=$nm2_site->{$name.":".$_};$ii++) {
MacroBNGModel.pm:739:##   @aonly = keys %seen;            # only keys rem-prm  = l!1 wich changed
MacroBNGModel.pm:751:##   @aonly = keys %seen;     # only keys rem-prm=l l:2
MacroBNGModel.pm:761:#num_site-end
MacroBNGModel.pm:763:#hash_sor-begin
MacroBNGModel.pm:770: $ind = -1;
MacroBNGModel.pm:774:   $rab = $_;              #;R(a!1).A(r!1);->;R(a);+;A(r);kmS #;Rec(a);+;Lig(l,l);<->;Rec(a!1).Lig(l!1,l);kp1,;km1
MacroBNGModel.pm:775:   $rab =~ s/^;//;         #R(a!1).A(r!1);->;R(a);+;A(r);kmS #Rec(a);+;Lig(l,l);<->;Rec(a!1).Lig(l!1,l);kp1,;km1
MacroBNGModel.pm:776:   $rab =~ /<->|->/;       # <->  or -> separation
MacroBNGModel.pm:799:     $n_site = &num_site($r1,$p1,$nm2_site,\@dep_sit);  # R(a!1) R(a) -> a
MacroBNGModel.pm:805:     push(@lis_sit,$ind);       # hash matrix->key=number of string
MacroBNGModel.pm:814:     if ( defined(@{$dpp_site->{$key_d}}) ) {
MacroBNGModel.pm:815:        @rxd = @{$dpp_site->{$key_d}};        # a b g
MacroBNGModel.pm:820:     @{$dpp_site->{$key_d}} = @dep_sit;      
MacroBNGModel.pm:821:     if ( defined(@{$lis1h->{$key_l}}) ) {
MacroBNGModel.pm:822:       @rxl = @{$lis1h->{$key_l}};        
MacroBNGModel.pm:827:     @{$lis1h->{$key_l}} = @lis_sit;        
MacroBNGModel.pm:829:     foreach (@lis_sit) { print WFILErec " $_ "; }  # 0  n-string into rules
MacroBNGModel.pm:830:     print WFILErec "  $$lis1[$ind]\n";       # ;Rec(a);+;Lig(l,l);<->;Rec(a!1).Lig(l!1,l);kp1,km1
MacroBNGModel.pm:833:       foreach (@lis_sit) { print WFILErec " $_ "; }  # 0  n-string into rules
MacroBNGModel.pm:834:       print WFILErec "  $$lis1[$ind]\n";  # ;Rec(a);+;Lig(l,l);<->;Rec(a!1).Lig(l!1,l);kp1,km1
MacroBNGModel.pm:847:   foreach (@{$dpp_site->{$key_d}}) { print WFILErec " $_ "; }
MacroBNGModel.pm:852:#hash_sor-end
MacroBNGModel.pm:854:#add_skf-begin
MacroBNGModel.pm:861:     if ( defined($skf->{$key}) ) {
MacroBNGModel.pm:862:       @rabm = @{$skf->{$key}};
MacroBNGModel.pm:864:         push(@{$skf->{$key}},$sit1);              # L:R r
MacroBNGModel.pm:867:       push(@{$skf->{$key}},$sit1);                # L:R r
MacroBNGModel.pm:869:     if ( defined($nm2_site->{$skf1.":".$sit1}) ) {           # L:r
MacroBNGModel.pm:870:       for ($ii=2;$ii<=$nm2_site->{$skf1.":".$sit1};$ii++) {
MacroBNGModel.pm:871:         push(@{$skf->{$key}},$sit1.":".$ii);                 # L:R r r:2
MacroBNGModel.pm:875:#add_skf-end
MacroBNGModel.pm:877:#skf0-begin
MacroBNGModel.pm:919:#skf0-end
MacroBNGModel.pm:921:#cor_net-begin
MacroBNGModel.pm:993: while ( $line=<RFILEnet> ) {            # search-copy "begin molecule types"
MacroBNGModel.pm:1016: while ( $line=<RFILEnet> ) {            # search-copy "begin species"
MacroBNGModel.pm:1064:   $nn = -1;
MacroBNGModel.pm:1080:         if ($#rr1 == 1) {            ####LEFTvariant - 30 5,17 11 kpS
MacroBNGModel.pm:1096:             if ($#rr1i == 1) {         ####LEFTvariant_ii - 30 5,17 11 kpS or 30 5,17 11,7 kpS
MacroBNGModel.pm:1109:         }else {            ####RIGHTvariant - 29 20 4,18 kmS
MacroBNGModel.pm:1125:             if ($#rr1i == 2) {             ####RIGHTvariant_ii - 30 5 17,11 kpS
MacroBNGModel.pm:1148:       $egf = $species[$key-1];           # egf(r)   $key=1 @rabm=9,15,25,37,45,46
MacroBNGModel.pm:1165:       $egf = $species[$an-1];            # egf(r)   from 1 species
MacroBNGModel.pm:1166:       $egfr1148 = $species[$bn-1];       # egfr1148(...)  from 5 spesies
MacroBNGModel.pm:1208:#cor_net-end
MacroBNGModel.pm:1210:#trans_rec-begin
MacroBNGModel.pm:1211:sub trans_rec{         #---transform micro to macro(reactions)
MacroBNGModel.pm:1218: $ind = -1;
MacroBNGModel.pm:1226:       $lin = $ino.$val;         #10;Ssite1_site2(site1);+;K(s);<->;Ssite1_site2(site1!1).K(s!1);k1;k_1
MacroBNGModel.pm:1233:       $lin = $ino.$value;       #10;Ssite1_site2(site1);+;K(s);<->;Ssite1_site2(site1!1).K(s!1);k1;k_1
MacroBNGModel.pm:1240:#trans_rec-end
MacroBNGModel.pm:1242:#trans_obs-begin
MacroBNGModel.pm:1243:sub trans_obs{                     #---transform micro to macro(OBSERVABLES)
MacroBNGModel.pm:1256:   if (!($group_name=~/^[A-Za-z]/)){
MacroBNGModel.pm:1302:#trans_obs-end
MacroBNGModel.pm:1304:#r_mac-begin
MacroBNGModel.pm:1316: $val = $value;                              #R(l!+,a);+;A(r);->;R(l!+,a!1).A(r!1);kpS#;Rec(g~pY);+;Syk(tSH2);<->;Rec(g~pY!1).Syk(tSH2!1);kpS,;kmS
MacroBNGModel.pm:1329:     $val = $';                             #r);->;R(l!+,a!1).A(r!1);kpS        #;<->;Rec(g~pY!1).Syk(tSH2!1);kpS,;kmS
MacroBNGModel.pm:1348:     $val = $';                #;<->;Rec(g~pY!1).Syk(tSH2!1);kpS,;kmS 
MacroBNGModel.pm:1352:         @rabmn = @{$lis1h->{$aft}};        # 0, 2, 10 - $ind string rules
MacroBNGModel.pm:1355:           if ( $value =~ /;\+;.*->;/ ) {   #;Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1358:             } else {                  #add  #;Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1362:               $out = $re[0].";+;".$re[1];   #;$Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1364:             --$rlig{$aft};                    # 2-1=> 1
MacroBNGModel.pm:1367:           if ( $value =~ /->;.*;\+;/ ) {    #;Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1370:             } else {                  #add  #;Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1374:               $out = $re[0].";+;".$re[1];   #;$Reca_g(g~pY);+;SyktSH2_l(tSH2);<->
MacroBNGModel.pm:1376:             --$rlig{$aft};                    # 2-1=> 1
MacroBNGModel.pm:1388:#r_mac-end
MacroBNGModel.pm:1390:#pre_obs1-begin
MacroBNGModel.pm:1401: &del_blank(\@obser1vable,\@lis1);     #-into observ--delete blank e.t.
MacroBNGModel.pm:1408: &trans_obs($dpp_site,$lis1h,\@lis1,$skf);   #---transform micro to macro(OBSERVABLES)
MacroBNGModel.pm:1413:   if ( $_ =~ /^simulate_ode/ )    {    $simul1 = $_; $ii--; }
MacroBNGModel.pm:1419:                  #    ---------  SPECIES2-------------
MacroBNGModel.pm:1426: &del_blank(\@species2,\@lis1);     #-into species2--delete blank e.t.
MacroBNGModel.pm:1435: &trans_specie($dpp_site,$lis1h,\@lis1);    #---transform micro to macro(SPECIES)
MacroBNGModel.pm:1441:#pre_obs1-end
MacroBNGModel.pm:1443:#obs_mac0-begin
MacroBNGModel.pm:1459:      @rskf = @{$skf->{$ij}};           # S:A  site2
MacroBNGModel.pm:1521:#obs_mac0-end
MacroBNGModel.pm:1523:#obs_mac-begin
MacroBNGModel.pm:1582:        &h_dep($dpp_site, \%dep_del, \@rabm, \@rab2, $out);   #@rab2= a b ---prepare @rab2
MacroBNGModel.pm:1586:            $irabm[$jj-1] = 1;                     # irabm = 1 1 0;      irabm = 2 1 1
MacroBNGModel.pm:1587:            $out .= $re[$jj-1].',';               # Reca_b(a!1,b~Y,;    Reca_g(a!1,g~Y,
MacroBNGModel.pm:1603:                $zout .= $re[$jj-1].",";               # Reca_b(a!1,;        Reca_g(a!1,g~Y,
MacroBNGModel.pm:1623:#obs_mac-end
MacroBNGModel.pm:1625:#trans_specie-begin
MacroBNGModel.pm:1626:sub trans_specie{                   #---transform micro to macro(SPECIES)
MacroBNGModel.pm:1633:   foreach (@{$lis1})  {              # line from species ONE RR-MOLECULES
MacroBNGModel.pm:1653:            $value = $dpp_site->{$key_dep};         #a b             site1 site3 site4
MacroBNGModel.pm:1668:                  $ind = &inc_elt($_,\@ra)-1;
MacroBNGModel.pm:1706:#trans_specie-end
MacroBNGModel.pm:1708:#get_line-begin
MacroBNGModel.pm:1728:#get_line-end
MacroBNGModel.pm:1730:#read_block_array-begin
MacroBNGModel.pm:1764:#read_block_array-end
MacroBNGModel.pm:1766:#errgen-begin
MacroBNGModel.pm:1774:#errgen-end
MacroBNGModel.pm:1776:#version-begin (substituted)
MacroBNGModel.pm:1778:return $base_model->version();
MacroBNGModel.pm:1780:#version-end (substituted)
MacroBNGModel.pm:1782:#L_AiAn_BiBn-begin
MacroBNGModel.pm:1795:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:1802:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:1809:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:1817:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:1823:#L_AiAn_BiBn-end
MacroBNGModel.pm:1825:#cros-begin
MacroBNGModel.pm:1836:   $li1 = $species[$ai-1];   #Sykl_tSH2(l~Y,tSH2)
MacroBNGModel.pm:1839:     $_ =~ /\(/;      # NABOR [Sykl_tSH2 Reca_b] macro-name into  @rr1mac
MacroBNGModel.pm:1844:   $li2 = $species[$an-1];   #Syka_tSH2(a~Y,tSH2)
MacroBNGModel.pm:1847:     $_ =~ /\(/;      # NABOR [Syka_tSH2 Reca_g] macro-name into @rr2mac
MacroBNGModel.pm:1862:     for ( $jj=0; $jj<=$#par1; $jj++) {               # pary macro-name (Q1 Q2) (R1 R2)...
MacroBNGModel.pm:1863:       $teil1 = $par1[$jj]; $teil2 = $par2[$jj];      # pary macro-name (Q1 Q2) (R1 R2)...
MacroBNGModel.pm:1873:##       @aonly = keys %seen; # only keys (am - bm) = neobshie sites(ab - ag => b)
MacroBNGModel.pm:1883:##       @aonly = keys %seen; # only keys (bm - am) = neobshie sites(ag - ab => g)
MacroBNGModel.pm:1894:#cros-end
MacroBNGModel.pm:1896:#delsites-begin
MacroBNGModel.pm:1904:  for ($ii=0; $ii<=$#$aonly; $ii++) {    # b-site
MacroBNGModel.pm:1941:  } ##for $ii b-sites
MacroBNGModel.pm:1975:#delsites-end
MacroBNGModel.pm:1977:#add_ts3n-begin
MacroBNGModel.pm:1984:#add_ts3n-end
MacroBNGModel.pm:1986:#R_AiAn_BiBn-begin
MacroBNGModel.pm:1997:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:2002:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:2007:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:2012:    $$reac[$nnn-1] = sprintf "%5d %s\n", $nnn, $ln;
MacroBNGModel.pm:2017:#R_AiAn_BiBn-end
MacroBNGModel.pm:2019:#selectmet-begin
MacroBNGModel.pm:2043:#selectmet-end
MacroBNGModel.pm:2045:#h_dep-begin
MacroBNGModel.pm:2047:my  ($dpp_site, $dep_del, $rabm, $rab2, $out) = @_; # @rab2 - output
MacroBNGModel.pm:2078:#h_dep-end
Map.pm:35:# Map->toString()
Map.pm:44:   my $molecules = $map->Source->Molecules;
Map.pm:48:      my $im2 = $map->MapF->{$im};
Map.pm:49:      $string .= sprintf " %d->%d(", $im+1, $im2+1;
Map.pm:51:      foreach my $ic ( 0..$#{$molecules->[$im]->Components} )
Map.pm:53:         my ($im2, $ic2) = split( '\.', $map->MapF->{"$im.$ic"} );
Map.pm:54:         $string .= sprintf " %d->%d", $ic+1, $ic2+1;
Map.pm:70:# p2 = Map->mapF(p1)
Map.pm:73:# p2 = Map->mapF(p1, offset)
Map.pm:81:   my $p2 = $map->MapF->{$p1};
Map.pm:104:# (autoP, err) = autoR->get_induced_permutation(map)
Map.pm:106:# autoR: R -> R
Map.pm:107:# map:   R -> P
Map.pm:108:# permP: P -> P
Map.pm:115:# permP = map o autoR o map^-1
Map.pm:122:#     autoR: R  -> R (automorphism of R)
Map.pm:123:#      map:  R* -> P (partial mapping of R into P)
Map.pm:129:# then find a permuation of P, permP: P -> P, such that for all r in R*
Map.pm:134:#      R ----autoR-->  R'
Map.pm:139:#      P ----candP---> P'
Map.pm:146:    if ($autoR->Source != $autoR->Target)
Map.pm:147:    {   return undef, "Map::get_induced_permutation() called from a non-self map";   }
Map.pm:149:    if ($autoR->Source != $map->Source)
Map.pm:152:    # create map object to hold P-permutation
Map.pm:155:    $permP->Source( $map->Target );
Map.pm:156:    $permP->Target( $map->Target );
Map.pm:157:    $permP->MapF( $mapF );
Map.pm:160:    foreach my $Pnode ( keys %{$map->MapR} )
Map.pm:163:        my $inv_Pnode = $map->MapR->{$Pnode};
Map.pm:167:            $mapF->{$Pnode} = $Pnode;
Map.pm:171:            # calculate:  map o autoR o map^-1 (Pnode)
Map.pm:172:            $mapF->{$Pnode} = $map->MapF->{ $autoR->MapF->{$inv_Pnode} };
Map.pm:182:## Transform self-map according to map given as argument
Map.pm:183:##  --Jim
Map.pm:188:## err = autoR->mapAuto(map)
Map.pm:190:## autoR: R -> R
Map.pm:191:## map:   R* -> P
Map.pm:198:#  if ($autoR->Source != $autoR->Target)
Map.pm:199:#  {  return "mapAuto called on non-self map";  }
Map.pm:201:#  if ($autoR->Source != $map->Source)
Map.pm:205:#  $autoR->Source($map->Target);
Map.pm:206:#  $autoR->Target($map->Target);
Map.pm:211:#  my $molecules = $map->Target->Molecules;
Map.pm:214:#     $candP->{$im} = "$im";
Map.pm:215:#     foreach my $ic ( 0..$#{$molecules->[$im]->Components} )
Map.pm:216:#     {  $candP->{"$im.$ic"} = "$im.$ic";  }  
Map.pm:219:#  # Transform self-map
Map.pm:220:#  foreach my $src_element ( keys %{$autoR->MapF} )
Map.pm:222:#     my $perm_src_element = $autoR->MapF->{$src_element};
Map.pm:223:#     my $targ_element = $map->MapF->{$src_element};
Map.pm:224:#     my $perm_targ_element = $map->MapF->{$perm_src_element};
Map.pm:226:#     $candP->{$targ_element} = $perm_targ_element;
Map.pm:230:#  # used by self-map, which is generated by calling subGraphIsomorphism))
Map.pm:231:#  $autoR->MapF( $candP );
Map.pm:246:    my $source = $map->Source;
Map.pm:247:    my $target = $map->Target;
Map.pm:250:    $target->Label( $source->Label )         if (defined $source->Label);
Map.pm:251:    $target->MatchOnce( $source->MatchOnce ) if (defined $source->MatchOnce);
Map.pm:252:    $target->Fixed( $source->Fixed )         if (defined $source->Fixed);
Map.pm:255:    for ( my $imol = 0;  $imol < @{$source->Molecules};  ++$imol )
Map.pm:257:        my $mol = $source->Molecules->[$imol];
Map.pm:259:        if (defined $mol->Label)
Map.pm:261:            my $imol_targ = $map->MapF->{$imol};
Map.pm:262:            $target->Molecules->[$imol_targ]->Label( $mol->Label );
Map.pm:266:        for ( my $icomp = 0; $icomp < @{$mol->Components};  ++$icomp )
Map.pm:268:            my $comp = $mol->Components->[$icomp];
Map.pm:270:            if (defined $comp->Label)
Map.pm:272:                my ($imol_targ, $icomp_targ) = split /\./, $map->MapF->{"$imol.$icomp"};
Map.pm:273:                $target->Molecules->[$imol_targ]->Components->[$icomp_targ]->Label( $comp->Label );  
Map.pm:291:    $map_copy->Source( $map->Source );
Map.pm:292:    $map_copy->Target( $map->Target );
Map.pm:293:    %{ $map_copy->MapF } = %{ $map->MapF };
Map.pm:294:    %{ $map_copy->MapR } = %{ $map->MapR };
Map.pm:309:    my $target_copy = $map->Target->copy();
Map.pm:312:    $map_copy->Source( $map->Source );
Map.pm:313:    $map_copy->Target( $target_copy );
Map.pm:314:    %{ $map_copy->MapF } = %{ $map->MapF };
Map.pm:315:    %{ $map_copy->MapR } = %{ $map->MapR };
Map.pm:330:    my $source_copy = $map->Source->copy();
Map.pm:333:    $map_copy->Source( $source_copy );
Map.pm:334:    $map_copy->Target( $map->Target );
Map.pm:335:    %{ $map_copy->MapF } = %{ $map->MapF };
Map.pm:336:    %{ $map_copy->MapR } = %{ $map->MapR };
Map.pm:351:    my $target_copy = $map->Target->copy();    
Map.pm:352:    my $source_copy = $map->Source->copy();
Map.pm:355:    $map_copy->Source( $source_copy );
Map.pm:356:    $map_copy->Target( $target_copy );
Map.pm:357:    %{ $map_copy->MapF } = %{ $map->MapF };
Map.pm:358:    %{ $map_copy->MapR } = %{ $map->MapR };
ModelWrapper.pm:40:    if ( defined $modelwrapper->Model )
ModelWrapper.pm:42:        printf "MODEL.load(FILE): model %s is already defined.\n", $modelwrapper->Name;
ModelWrapper.pm:52:    unless ( -e $file )
ModelWrapper.pm:58:    unless ( -r $file )
ModelWrapper.pm:65:    $modelwrapper->Model = BNGModel->new();
ModelWrapper.pm:67:    my $local_params = { %{$modelwrapper->Defaults} };
ModelWrapper.pm:69:    $local_params->{file} = $file;
ModelWrapper.pm:72:    my $err = $model->readFile( $local_params );
ModelWrapper.pm:93:    %{$modelwrapper->Model} = ();
ModelWrapper.pm:94:    undef %{$modelwrapper->Model};
ModelWrapper.pm:95:    $modelwrapper->Model(undef);
ModelWrapper.pm:111:    my $model = $modelwrapper->Model;    
ModelWrapper.pm:114:        printf "MODEL.load(FILE): model %s is not defined.\n", $modelwrapper->Name;
ModelWrapper.pm:124:        unless ( @$state == $model->SpeciesList->getNumSpecies() )
ModelWrapper.pm:131:        $model->Concentrations( $state_copy );
ModelWrapper.pm:138:        if ( @{$model->Concentrations}
ModelWrapper.pm:140:            @$state_copy = @{$model->Concentrations};
ModelWrapper.pm:144:            @$state_copy = grep {$_->Concentration} @{$model->SpeciesList->Array};
Molecule.pm:49:	my $mol = Molecule->new();
Molecule.pm:50:	my $err = $mol->readString( $string, $clist );
Molecule.pm:71:	if ( $string_left =~ s/^(\w*[A-Za-z]\w*)// )
Molecule.pm:73:		$mol->Name($1);
Molecule.pm:88:			if (@{$mol->Components}) 
Molecule.pm:104:                push @{$mol->Components}, $comp;
Molecule.pm:138:					if ( $val == -1 )
Molecule.pm:142:					$mol->Context($val);
Molecule.pm:158:				if ( defined $mol->State )
Molecule.pm:162:				if ( $arg =~ /(\w+|\?)/ ) {  $mol->State($arg);  }
Molecule.pm:177:					push @{$mol->Edges}, $arg;
Molecule.pm:182:				if ( defined $mol->Label )
Molecule.pm:186:				$mol->Label($arg);
Molecule.pm:190:				if ( defined $mol->Compartment )
Molecule.pm:195:				if ( my $comp = $clist->lookup($arg) )
Molecule.pm:197:					$mol->Compartment($comp);
Molecule.pm:206:		elsif ( $string_left =~ /^(\.|\+|\s+|<?->)/ )
Molecule.pm:236:	my $string .= $mol->Name;
Molecule.pm:238:	$string .= sprintf("~%s", $mol->State)  if (defined $mol->State);
Molecule.pm:241:    {   $string .= sprintf("%%%s", $mol->Label)  if (defined $mol->Label);   }
Molecule.pm:243:	if ( defined $mol->Edges )
Molecule.pm:248:			foreach my $edge ( @{$mol->Edges} )
Molecule.pm:258:		{   $string .= "!" x scalar( @{$mol->Edges} );   }
Molecule.pm:261:	if ( defined $mol->Components )
Molecule.pm:265:		foreach my $comp ( @{$mol->Components} )
Molecule.pm:269:			$string .= $comp->toString($print_edges, $print_attributes);
Molecule.pm:277:	if ( defined $mol->Compartment )
Molecule.pm:279:		unless ( (defined $speciesCompartment) and ($mol->Compartment == $speciesCompartment) )
Molecule.pm:280:		{   $string .= sprintf "@%s", $mol->Compartment->Name;   }
Molecule.pm:287:	    if ( $mol->Context )
Molecule.pm:308:	my $mname   = $mol->Name;
Molecule.pm:309:	my $string .= $mol->Name;
Molecule.pm:316:	foreach my $comp (@{$mol->Components})
Molecule.pm:320:		if (defined $comp->Name)
Molecule.pm:322:			my $cname = $comp->Name;
Molecule.pm:329:				print"    In this preliminary version of BNG-SSC translator we do not handle this case";
Molecule.pm:336:			if ( $sameCompExists == 0 ) { $string .= $comp->toStringSSC(); }
Molecule.pm:358:    my $string .= $mol->Name;
Molecule.pm:361:    if ( defined $mol->Components )
Molecule.pm:363:        foreach my $comp ( @{$mol->Components} )
Molecule.pm:365:            if ( defined $comp->Name )
Molecule.pm:367:                my $cname = $comp->Name;
Molecule.pm:394:	foreach my $comp ( @{ $mol->Components } ) {
Molecule.pm:395:		if ( defined( $comp->Edges ) ) {
Molecule.pm:397:			foreach my $edge ( @{ $comp->Edges } ) {
Molecule.pm:401:					if ( defined( $comp->State ) ) {
Molecule.pm:403:						$string .= $comp->toStringSSC();
Molecule.pm:407:					if ( ( !defined( $comp->State ) ) ) {
Molecule.pm:409:						$string .= $comp->Name . "#" . ( $edge + 1 );
Molecule.pm:416:			if ( defined( $comp->State ) ) {
Molecule.pm:419:				$string .= $comp->Name . "=\"" . $comp->State . "\"";
Molecule.pm:446:	my $string .= $mol->Name;
Molecule.pm:448:	if ( defined( $mol->State ) ) {
Molecule.pm:449:	#do something	$string .= sprintf "~%s", $mol->State;
Molecule.pm:452:	if ( defined( $mol->Label ) ) {
Molecule.pm:453:		#$string .= sprintf "%%%s", $mol->Label;
Molecule.pm:456:	if ( defined( $mol->Edges ) ) {
Molecule.pm:460:	if ( defined( $mol->Components ) ) {
Molecule.pm:464:	if ( defined( $mol->Compartment ) ) {
Molecule.pm:494:	$string .= " name=\"" . $mol->Name . "\"";
Molecule.pm:496:	if ( defined $mol->Label )
Molecule.pm:498:		$string .= " label=\"" . $mol->Label . "\"";
Molecule.pm:501:	if ( defined $mol->Compartment )
Molecule.pm:503:		$string .= " compartment=\"" . $mol->Compartment->Name . "\"";
Molecule.pm:511:	if ( @{$mol->Components} )
Molecule.pm:515:		foreach my $comp ( @{$mol->Components} )
Molecule.pm:517:			$ostring .= $comp->toXML( '  ' . $indent2, $mid, $cindex );
Molecule.pm:555:	my $mol_copy = Molecule->new();
Molecule.pm:558:	$mol_copy->Name( $mol->Name );
Molecule.pm:559:    $mol_copy->State( $mol->State );
Molecule.pm:560:    $mol_copy->Label( $mol->Label ) if ($copy_labels);
Molecule.pm:561:    $mol_copy->Context( $mol->Context );
Molecule.pm:562:    $mol_copy->Compartment( $mol->Compartment ) if (defined $mol->Compartment);
Molecule.pm:565:	if ( @{$mol->Edges} )
Molecule.pm:568:	    $mol_copy->Edges( [map {$_=~/^[*+?]$/ ? $_ : $prefix.$_} @{$mol->Edges}] );
Molecule.pm:571:	if ( @{$mol->Components} )
Molecule.pm:573:		$mol_copy->Components( [map {$_->copy($copy_labels,$prefix)} @{$mol->Components} ] );
Molecule.pm:594:    {   return "Molecule->relinkCompartments: Error!! Method called without CompartmentList object";   }
Molecule.pm:596:    if ( defined $mol->Compartment )
Molecule.pm:598:        my $new_comp = $clist->lookup( $mol->Compartment->Name );
Molecule.pm:600:        {   return "Molecule->relinkCompartments: Error!! could not find compartment name in list";   }
Molecule.pm:601:        $mol->Compartment( $new_comp );
Molecule.pm:604:    foreach my $comp ( @{$mol->Components} )
Molecule.pm:606:        $err = $comp->relinkCompartments( $clist );
Molecule.pm:630:	if ( $cmp = ($a->Name cmp $b->Name) )
Molecule.pm:634:	if ( $cmp = ($a->State cmp $b->State) )
Molecule.pm:638:	if ( $cmp = ( $a->Compartment->Name cmp $b->Compartment->Name ) )
Molecule.pm:642:	if ( $cmp = (@{$a->Edges} <=> @{$b->Edges}) )
Molecule.pm:646:	if ( $cmp = (@{$a->Components} <=> @{$b->Components}) )
Molecule.pm:650:	for ( my $ic = 0;  $ic < @{$a->Components};  ++$ic )
Molecule.pm:652:		if ( $cmp = $a->Components->[$ic]->compare($b->Components->[$ic]) )
MoleculeType.pm:41:    if ( $string_left =~ s/^(\w*[A-Za-z]\w*)// )
MoleculeType.pm:44:        $mtype->Name($1);
MoleculeType.pm:52:    $mtype->PopulationType(0);
MoleculeType.pm:83:	                my $comp = ComponentType->new;
MoleculeType.pm:84:	                my $err  = $comp->readString(\$string_left);
MoleculeType.pm:91:        # (NOTE: this used to be a stop character.  Will removing this cause problems?  --Justin, 7mar2011)
MoleculeType.pm:97:        elsif ( $string_left =~ /^[,.]|[<]?-[>]/ )
MoleculeType.pm:104:            $mtype->PopulationType(1);
MoleculeType.pm:114:        $mtype->Components([@components]);
MoleculeType.pm:131:    $mt_copy->Name( $mt->Name );    
MoleculeType.pm:132:    foreach my $comp ( @{$mt->Components} )
MoleculeType.pm:134:        push @{$mt_copy->Components}, $comp->copy();
MoleculeType.pm:136:    $mt_copy->PopulationType( $mt->PopulationType );
MoleculeType.pm:152:    $mtype->Name($mol->Name);
MoleculeType.pm:154:    foreach my $comp (@{$mol->Components})
MoleculeType.pm:156:        my $ctype=ComponentType->new( Name=>$comp->Name );
MoleculeType.pm:158:        my $state = $comp->State;
MoleculeType.pm:161:            $ctype->States(0, $state);
MoleculeType.pm:165:    $mtype->Components([@ctarray]);
MoleculeType.pm:183:    my $IsSpecies            = exists $params->{IsSpecies}     ? $params->{IsSpecies}     : 1;
MoleculeType.pm:184:    my $AllowNewStates       = exists $params->{AllowNewTypes} ? $params->{AllowNewTypes} : !$IsSpecies;
MoleculeType.pm:188:    my $InheritList          = exists $params->{InheritList}   ? $params->{InheritList}   : 0;
MoleculeType.pm:190:    my @ctypes = @{$mtype->Components};
MoleculeType.pm:191:    foreach my $comp (@{$mol->Components})
MoleculeType.pm:198:            if ($comp->Name eq $comp_type->Name)
MoleculeType.pm:200:    	        my $state = $comp->State;
MoleculeType.pm:205:    	            my $InheritState = ($InheritList) ? $InheritList->[$index] : 0;
MoleculeType.pm:207:    	            if (@{$comp_type->States} && !$InheritState && !$AllowUndefinedStates)
MoleculeType.pm:210:    	                $comp->Name, $mol->toString(); 
MoleculeType.pm:226:	                unless (@{$comp_type->States})
MoleculeType.pm:229:	                    $comp->Name, $mol->toString(); 
MoleculeType.pm:235:	                foreach my $comp_state (@{$comp_type->States})
MoleculeType.pm:248:	                               $comp->State, $comp->Name, $mol->Name; 
MoleculeType.pm:249:	                        push @{$comp_type->States}, $comp->State;
MoleculeType.pm:255:                                             $comp->State, $comp->Name, $mol->toString(); 
MoleculeType.pm:263:                    if ( grep {$_ =~ /^[+?]$/} @{$comp->Edges} )
MoleculeType.pm:266:                                             $comp->Name, $mol->toString(); 
MoleculeType.pm:280:            my $err = sprintf "Component %s of molecule %s not found in molecule declaration", $comp->Name, $mol->toString();
MoleculeType.pm:291:            $names .= " ".$ct->Name;
MoleculeType.pm:293:        my $err = sprintf "Component(s)${names} missing from molecule %s", $mol->toString();
MoleculeType.pm:314:    my $string = $mtype->Name; 
MoleculeType.pm:317:    foreach my $comp ( @{$mtype->Components} )
MoleculeType.pm:319:        push @cstrings, $comp->toString();
MoleculeType.pm:328:            $string .= ' ' x ($max_length - $string_len);
MoleculeType.pm:333:    if ( $mtype->PopulationType )
MoleculeType.pm:350:    $string .= $mtype->Name;
MoleculeType.pm:354:    foreach my $comp (@{$mtype->Components})
MoleculeType.pm:356:        push @cstrings, $comp->toStringSSC();
MoleculeType.pm:360:    # NOTE: SSC won't recognize population tag, so dont output. --Justin
MoleculeType.pm:378:    $string.=" id=\"".$mtype->Name."\"";
MoleculeType.pm:380:    if ( $mtype->PopulationType ) { $string .= " population=\"1\""; }
MoleculeType.pm:386:    if (@{$mtype->Components})
MoleculeType.pm:389:        foreach my $comp (@{$mtype->Components})
MoleculeType.pm:391:            $ostring .= $comp->toXML("  ".$indent2);
MoleculeTypesList.pm:51:    my $mt = MoleculeType->new;
MoleculeTypesList.pm:52:    my $err = $mt->readString( \$entry, 1, '', $mtl );
MoleculeTypesList.pm:60:    if ( $mtl->MolTypes->{$mt->Name} )
MoleculeTypesList.pm:62:        $err = sprintf "Molecule type %s previously defined.", $mt->Name;
MoleculeTypesList.pm:67:    $mtl->MolTypes->{$mt->Name} = $mt;
MoleculeTypesList.pm:82:    return scalar keys %{$mtlist->MolTypes};
MoleculeTypesList.pm:99:    while ( my ($name,$mt) = each %{$mtlist->MolTypes} )
MoleculeTypesList.pm:101:        my $mt_copy = $mt->copy();
MoleculeTypesList.pm:102:        $mtlist_copy->MolTypes->{$mt_copy->Name} = $mt_copy;
MoleculeTypesList.pm:104:    $mtlist_copy->StrictTyping( $mtlist->StrictTyping );
MoleculeTypesList.pm:123:    if ( exists $mtlist->MolTypes->{$mt->Name} )
MoleculeTypesList.pm:129:        $mtlist->MolTypes->{$mt->Name} = $mt;
MoleculeTypesList.pm:149:    if ( exists $mtl->MolTypes->{$name} )
MoleculeTypesList.pm:151:        $mt = $mtl->MolTypes->{$name};
MoleculeTypesList.pm:164:# Set $params->{IsSpecies} to 1 to force all components to be 
MoleculeTypesList.pm:172:    my $IsSpecies     = (defined $params->{IsSpecies}    ) ? $params->{IsSpecies}     : 1;
MoleculeTypesList.pm:173:    my $AllowNewTypes = (defined $params->{AllowNewTypes}) ? $params->{AllowNewTypes} : 0;
MoleculeTypesList.pm:175:    foreach my $mol (@{$sg->Molecules})
MoleculeTypesList.pm:178:        if ($mol->Name =~ /[*]/)
MoleculeTypesList.pm:182:            foreach $mtype (keys %{$mtl->MolTypes})
MoleculeTypesList.pm:184:	            next unless ($mol->Name =~ $mtype);
MoleculeTypesList.pm:185:	            if ( $mtype->check($mol,$params) eq '' )
MoleculeTypesList.pm:191:	                my $err = sprintf "Molecule string %s does not match any declared molecule types", $mol->toString();
MoleculeTypesList.pm:196:        elsif ( $mtype = $mtl->MolTypes->{$mol->Name} )
MoleculeTypesList.pm:199:            if ( my $err = $mtype->check($mol,$params) )
MoleculeTypesList.pm:210:	            my $mtype= MoleculeType->new;
MoleculeTypesList.pm:211:	            $mtype->add($mol);
MoleculeTypesList.pm:212:	            $mtl->MolTypes->{$mol->Name} = $mtype;
MoleculeTypesList.pm:216:	            my $err = sprintf "Molecule %s does not match any declared molecule types", $mol->toString();
MoleculeTypesList.pm:217:	            #$err.= "\n".$mtl->writeBNGL();
MoleculeTypesList.pm:240:    my $IsSpecies     = exists $params->{IsSpecies}     ? $params->{IsSpecies}     : 1;
MoleculeTypesList.pm:241:    my $AllowNewTypes = exists $params->{AllowNewTypes} ? $params->{AllowNewTypes} : 0;
MoleculeTypesList.pm:244:    if ( $mtype = $mtl->MolTypes->{$mol->Name} )
MoleculeTypesList.pm:247:        if ( my $err = $mtype->check($mol,$params) )
MoleculeTypesList.pm:256:            my $mtype = MoleculeType->new;
MoleculeTypesList.pm:257:            $mtype->add($mol);
MoleculeTypesList.pm:258:            $mtl->MolTypes->{$mol->Name} = $mtype;
MoleculeTypesList.pm:262:            my $err = sprintf "Molecule %s does not match any declared molecule types", $mol->toString();
MoleculeTypesList.pm:284:    if ( $user_params->{pretty_formatting} ) 
MoleculeTypesList.pm:286:        while ( my ($name, $mt) = each %{$mtlist->MolTypes} )
MoleculeTypesList.pm:288:            my $string = $mt->toString();
MoleculeTypesList.pm:295:    while ( my ($name, $mt) = each %{$mtlist->MolTypes} )
MoleculeTypesList.pm:297:        if ( $user_params->{pretty_formatting} )
MoleculeTypesList.pm:299:            $out .= '  ' . $mt->toString($max_length) . "\n";
MoleculeTypesList.pm:303:            $out .= sprintf "%5d %s\n", $index, $mt->toString();
MoleculeTypesList.pm:327:    foreach my $mname (sort keys %{$mtlist->MolTypes})
MoleculeTypesList.pm:329:        my $mt = $mtlist->MolTypes->{$mname};
MoleculeTypesList.pm:330:        $string .= $mt->toXML("  ".$indent);
Observable.pm:42:    $obs_copy->Name( $obs->Name );
Observable.pm:43:    $obs_copy->Type( $obs->Type );
Observable.pm:44:    $obs_copy->Output( $obs->Output );
Observable.pm:46:    foreach my $patt ( @{$obs->Patterns} )
Observable.pm:48:        my $patt_copy = $patt->copy();
Observable.pm:49:        push @{$obs_copy->Patterns}, $patt_copy;
Observable.pm:52:    if ( defined $obs->Weights )
Observable.pm:54:        $obs_copy->Weights( [ @{$obs->Weights} ] );
Observable.pm:72:    $obs->Weights( [(0) x $alloc] );
Observable.pm:90:    {   return "Observable->relinkCompartments: Error!! Method called without CompartmentList object";   }
Observable.pm:92:    foreach my $patt ( @{$obs->Patterns} )
Observable.pm:94:        $err = $patt->relinkCompartments( $clist );
Observable.pm:112:    @{$obs->Weights} = ();
Observable.pm:136:        push @$eval_args, $args->[$ii]->evaluate( $plist, $level+1 );
Observable.pm:147:            {   # molecule-scopes observable
Observable.pm:149:                {  die "Observable->evaluate(): Error! Can't find current Model to evaluate global observable!";  }
Observable.pm:151:                my $sg = $BNGModel::GLOBAL_MODEL->SpeciesList->Array->[$species_idx-1]->SpeciesGraph;
Observable.pm:152:                $val += $obs->match( $sg, $mol_idx );
Observable.pm:155:            {   # complex-scoped (i.e. species-scoped) observable
Observable.pm:156:                $val += (defined $obs->Weights->[$species_idx]) ? $obs->Weights->[$species_idx] : 0;
Observable.pm:159:            {  die "Observable->evaluate(): Error! Observable argument was not a pointer to a species or a molecule!";  }
Observable.pm:166:        {  die "Observable->evaluate(): Error! Can't find current Model to evaluate global observable!";  }
Observable.pm:168:        my $conc  = $BNGModel::GLOBAL_MODEL->Concentrations();
Observable.pm:169:        my $slist = $BNGModel::GLOBAL_MODEL->SpeciesList();
Observable.pm:172:        $slist->checkOrInitConcentrations($conc);
Observable.pm:174:        for ( my $sidx = 1; $sidx < @{$obs->Weights}; ++$sidx )
Observable.pm:176:            next unless ( defined $obs->Weights->[$sidx] );
Observable.pm:177:            $val += $obs->Weights->[$sidx] * $conc->[$sidx-1];
Observable.pm:198:    my $plist  = $model->ParamList;
Observable.pm:199:    my $clist  = $model->CompartmentList;
Observable.pm:200:    my $mtlist = $model->MoleculeTypesList;
Observable.pm:203:    $obs->Output(1);
Observable.pm:212:    #  Adding Counter and Population types  --Justin, 5nov2010
Observable.pm:214:    #    evaluations among the output observables --Justin
Observable.pm:218:        $obs->Type($1);
Observable.pm:227:        #$obs->Type('Molecules');
Observable.pm:231:    if ( $string =~ s/^\s*([A-z]\w*)\s+// )
Observable.pm:234:        $obs->Name($name);
Observable.pm:242:    if ( $obs->Type ne 'Function' )
Observable.pm:245:        if ( $plist->set( $obs->Name, "0", 1, "Observable", $obs) )
Observable.pm:247:      	    my $name= $obs->Name;
Observable.pm:255:            my $g = SpeciesGraph->new();
Observable.pm:257:            my $count_autos = $obs->Type eq 'Molecules' ? 1 : 0;
Observable.pm:258:            $err = $g->readString( \$string, $clist, 0, $sep, $mtlist, $count_autos );
Observable.pm:259:            if ($err) {  return "While reading observable " . $obs->Name . ": $err";  }
Observable.pm:263:            if ( $g->isNull() )
Observable.pm:265:                send_warning( sprintf("Found useless instance of null pattern in observable %s.", $obs->Name) );
Observable.pm:269:            if ( ($obs->Type eq 'Species') and (!defined($g->Quantifier) or $g->Quantifier eq ''))
Observable.pm:271:                $g->MatchOnce(1);
Observable.pm:273:            push @{$obs->Patterns}, $g;
Observable.pm:278:        # This is a Function observable (this undocumented'feature' might be dropped --Justin)
Observable.pm:281:        $expr->setAllowForward(1);
Observable.pm:282:        if ( my $err = $expr->readString( \$string, $plist ) )
Observable.pm:289:        $expr->setAllowForward(0);
Observable.pm:292:        if ( $plist->set( $obs->Name, $expr, 1, 'Observable', $obs ) )
Observable.pm:294:      	    my $name= $obs->Name;
Observable.pm:312:    my $string = $obs->Type . ' ' . $obs->Name;
Observable.pm:313:    foreach my $patt (@{$obs->Patterns})
Observable.pm:315:        $string .= ' ' . $patt->toString();
Observable.pm:325:    foreach my $patt (@{$obs->Patterns})
Observable.pm:327:        my ($tempstring, $trash) = $patt->toStringSSC();
Observable.pm:339:    if ( $obs->Type ne 'Function' )
Observable.pm:344:        for ( my $idx1=1; $idx1 < @{$obs->Weights}; $idx1++ )
Observable.pm:346:            my $idx0 = $idx1 - 1;
Observable.pm:347:            if ( defined $obs->Weights->[$idx1] )
Observable.pm:350:                if ( $obs->Weights->[$idx1] == 1 )
Observable.pm:353:                {  $term = $obs->Weights->[$idx1] . "*NV_Ith_S(species,$idx0)";  }
Observable.pm:365:        ( my $param, my $err ) = $plist->lookup( $obs->Name );
Observable.pm:366:        return $param->Expr->toCVodeString( $plist );
Observable.pm:381:    if ( $obs->Type ne 'Function' )
Observable.pm:386:        for ( my $idx1=1; $idx1 < @{$obs->Weights}; $idx1++ )
Observable.pm:388:            if ( defined $obs->Weights->[$idx1] )
Observable.pm:391:                if ( $obs->Weights->[$idx1] == 1 )
Observable.pm:394:                {  $term = $obs->Weights->[$idx1] . "*species($idx1)";  }
Observable.pm:406:        ( my $param, my $err ) = $plist->lookup( $obs->Name );
Observable.pm:407:        return $param->Expr->toMatlabString( $plist );
Observable.pm:430:    if ($obs->Name)
Observable.pm:432:        $string .= " name=\"" . $obs->Name . "\"";
Observable.pm:435:    if ($obs->Type)
Observable.pm:437:        $string .= " type=\"" . $obs->Type . "\"";
Observable.pm:444:    foreach my $patt (@{$obs->Patterns})
Observable.pm:448:        $ostring .= $patt->toXML($indent3,"Pattern",$pid,"");
Observable.pm:481:    foreach my $patt (@{$obs->Patterns})
Observable.pm:486:        {   @matches = $patt->isomorphicToSubgraph($sg, 0, $rootmol);   }
Observable.pm:488:        {   @matches = $patt->isomorphicToSubgraph($sg);   }
Observable.pm:493:        #  Uncomment the following block to enable the correction.  --Justin 15mar2010
Observable.pm:494:        #if ( $obs->Type eq 'Molecules' )
Observable.pm:496:        #    $n_match /= $patt->Automorphisms;
Observable.pm:502:        if ($patt->Quantifier)
Observable.pm:504:	        my $test = $n_match.$patt->Quantifier;
Observable.pm:509:        if ($obs->Type eq 'Species') {  $n_match = 1;  }
Observable.pm:534:    {   $obs->Weights->[@$species] = $obs->Weights->[@$species];   }
Observable.pm:537:    foreach my $patt (@{$obs->Patterns})
Observable.pm:541:            my $sp = $species->[$ii];
Observable.pm:542:            next if ( $sp->ObservablesApplied );
Observable.pm:545:            my @matches = $patt->isomorphicToSubgraph( $sp->SpeciesGraph );
Observable.pm:550:            #  Uncommend the following block to enable the correction.  --Justin 15mar2010
Observable.pm:551:            #if ( $obs->Type eq 'Molecules' )
Observable.pm:553:            #    $n_match /= $patt->Automorphisms;
Observable.pm:558:            if ($patt->Quantifier)
Observable.pm:560:	            my $test = $n_match.$patt->Quantifier;
Observable.pm:565:            if ($obs->Type eq 'Species') {  $n_match = 1;  }
Observable.pm:566:            $obs->Weights->[$sp->Index] += $n_match;
Observable.pm:590:    foreach my $i ( 1..$#{$obs->Weights} )
Observable.pm:592:        my $w = $obs->Weights->[$i];
Observable.pm:616:    my $out   = sprintf "%-20s ", $obs->Name;
Observable.pm:617:    my $i     = -1;
Observable.pm:620:    foreach my $w (@{$obs->Weights})
Observable.pm:646:        print $obs->Patterns->[0]->toString(),": ";
Observable.pm:647:        my $i=-1;
Observable.pm:648:        foreach my $w (@{$obs->Weights})
Observable.pm:652:            my $sstring = $slist->Array->[$i-1]->SpeciesGraph->toString();
Observable.pm:661:    #printf "Group %s contains %d elements.\n", $obs->Name, $n_elt;
Observable.pm:676:    foreach my $w (@{$obs->Weights})
Observable.pm:697:    printf $fh "%s ", $obs->Name;
Observable.pm:702:        my $spec = $species->[$ii];
Observable.pm:703:        my $sp_idx = $spec->Index;
Observable.pm:704:        my $weight = $obs->Weights->[$sp_idx];
Observable.pm:728:    my $n_elt = $obs->sizeOfGroup();
Observable.pm:737:    my $i=-1;
Observable.pm:738:    foreach my $w (@{$obs->Weights})
ParamList.pm:43:    foreach my $param ( @{$plist->Array} )
ParamList.pm:45:        next unless ($param->Type eq 'Constant'  or  $param->Type eq 'ConstantExpression' );
ParamList.pm:46:        my $param_copy = $param->copyConstant( $plist );
ParamList.pm:47:        $plist_copy->add( $param_copy );
ParamList.pm:51:	if ( my $err = $plist_copy->check() ) {  print "complain about parameter check\n";  return undef;  }
ParamList.pm:52:	if ( my $err = $plist_copy->sort()  ) {  print "complain about parameter sort\n";   return undef;  }    
ParamList.pm:68:    return scalar @{$plist->Array};
ParamList.pm:74:    return scalar @{$plist->Array};
ParamList.pm:93:    if ( exists $plist->Hash->{$name} )
ParamList.pm:95:        return $plist->Hash->{$name}, "";
ParamList.pm:97:    elsif ( defined $plist->Parent )
ParamList.pm:99:        return $plist->Parent->lookup($name);
ParamList.pm:118:    $child->Parent( $plist );
ParamList.pm:131:# Find an un-used name in the parameter list
ParamList.pm:144:        my ( $param, $err ) = $plist->lookup( "${basename}_${index}" );
ParamList.pm:167:    my ($param,$err) = $plist->lookup($name);
ParamList.pm:171:        return $param->evaluate($args, $plist, $level + 1);
ParamList.pm:220:    my $expr = Expression->new();
ParamList.pm:221:    $expr->setAllowForward(1);
ParamList.pm:222:    if ( my $err = $expr->readString($sptr,$plist) ) {  return $err;  }
ParamList.pm:226:    $expr->setAllowForward(0);
ParamList.pm:251:    my $param_array = $xml->getParameters();
ParamList.pm:254:        (my $param, $err) = Parameter->readXML($param_hash, $plist);
ParamList.pm:258:        (my $old_param, $err) = $plist->lookup($param->Name);
ParamList.pm:262:        if ( defined $old_param  and  defined $old_param->Expr )
ParamList.pm:273:                $err = "Parameter->readXML: attempt to redefine parameter $name is not allowed"; 
ParamList.pm:280:            unless ( $param->Type eq 'Local'  or  $param->Type eq 'RRef' )
ParamList.pm:282:                push @{$plist->Array}, $param;
ParamList.pm:284:                push @{$plist->Unchecked}, $param;
ParamList.pm:287:            $plist->Hash->{ $param->Name } = $param;
ParamList.pm:295:        print sprintf( "Parameter->readXML: read %d new parameters and redefined %d parameters.\n", $n_pars_new, $n_pars_redef );
ParamList.pm:320:    #printf "ParamList->add( %s, %d, %d )\n", $param->Name, $no_overwrite, $global;
ParamList.pm:324:        if ( defined $plist->Parent )
ParamList.pm:325:        {   return $plist->Parent->add( $param, $no_overwrite, $global );   }
ParamList.pm:329:    (my $old_param) = $plist->lookup( $param->Name );
ParamList.pm:335:        {   return sprintf "Redefining existing parameter '%s' is not permitted", $param->Name;   }
ParamList.pm:338:        if ( $param->Type eq 'Local'  or  $param->Type eq 'RRef' )
ParamList.pm:340:            return sprintf( "Redefining non-local parameter '%s' as a local parameter is not permitted",
ParamList.pm:341:                       $param->Name );
ParamList.pm:345:        for ( my $idx = 0; $idx < @{$plist->Array}; ++$idx )
ParamList.pm:347:            my $old_param = $plist->Array->[$idx];
ParamList.pm:348:            if( $old_param->Name eq $param->Name )
ParamList.pm:350:                $plist->Array->[$idx] = $param;
ParamList.pm:352:                push @{$plist->Unchecked}, $param;
ParamList.pm:361:        unless ( $param->Type eq 'Local'  or  $param->Type eq 'RRef' )
ParamList.pm:363:            push @{$plist->Array}, $param;
ParamList.pm:364:            push @{$plist->Unchecked}, $param;
ParamList.pm:369:    $plist->Hash->{ $param->Name } = $param;
ParamList.pm:375:# ParamList->set( name, expression ) creates a parameter object from a name and an expression (or reference)
ParamList.pm:390:        while (defined $plist->Parent)
ParamList.pm:392:            $plist = $plist->Parent;
ParamList.pm:397:    my ($param,$err)= $plist->lookup($name);
ParamList.pm:402:        $param = Param->new( Name=>$name );
ParamList.pm:405:        {   push @{$plist->Array}, $param;   }
ParamList.pm:407:        $plist->Hash->{$name} = $param;
ParamList.pm:410:        {   push @{$plist->Unchecked}, $param;   }
ParamList.pm:417:    if ($param->Expr ne '')
ParamList.pm:428:        my $expr = Expression->new( Type=>'NUM', Arglist=>[$rhs] );
ParamList.pm:432:    # Set Param->Expression
ParamList.pm:433:    $param->Expr($rhs);
ParamList.pm:435:    # Set Param->Type
ParamList.pm:438:        $param->setType($type);
ParamList.pm:441:        {   $param->Ref($ref);   }
ParamList.pm:445:            my $fun = Function->new();   
ParamList.pm:446:            $fun->Name($param->Name);
ParamList.pm:447:            $fun->Expr($param->Expr);
ParamList.pm:449:            my $vhash = $param->Expr->getVariables($plist);       
ParamList.pm:451:            my @args = keys %{$vhash->{Local}};
ParamList.pm:452:            $fun->Args([@args]);           
ParamList.pm:454:            $param->Ref($fun);                
ParamList.pm:457:    elsif ($rhs->Type eq 'NUM')
ParamList.pm:459:        $param->setType('Constant');
ParamList.pm:464:        my $vhash = $param->Expr->getVariables($plist);
ParamList.pm:465:        if ( $vhash->{Observable} || $vhash->{Function} )
ParamList.pm:467:            $param->setType('Function');
ParamList.pm:468:            my $fun= Function->new();
ParamList.pm:469:            $fun->Name($param->Name);
ParamList.pm:470:            $fun->Expr($param->Expr);
ParamList.pm:471:            my @args = keys %{$vhash->{Local}};
ParamList.pm:472:            $fun->Args([@args]);
ParamList.pm:473:            $param->Ref($fun);
ParamList.pm:475:        elsif ( $vhash->{Constant} or $vhash->{ConstantExpression} )
ParamList.pm:477:            $param->setType('ConstantExpression');
ParamList.pm:482:            $param->setType('Constant');
ParamList.pm:502:    foreach my $param ( @{$plist->Array} )
ParamList.pm:504:        $out .= sprintf "Parameter %s=%s\n", $param->Name, $param->toString($plist);
ParamList.pm:524:    foreach my $param ( @{$plist->Array} )
ParamList.pm:526:        my $type = $param->Type;
ParamList.pm:528:        $out .= " " . $param->Name . " = ";
ParamList.pm:529:        $out .= $param->evaluate([],$plist) . "\n";
ParamList.pm:552:    foreach my $param (@{$plist->Array})
ParamList.pm:554:        $max_length = ($max_length >= length $param->Name) ? $max_length : length $param->Name;
ParamList.pm:560:    foreach my $param (@{$plist->Array})
ParamList.pm:562:        next unless ( $param->Type =~ /^Constant/ ); 
ParamList.pm:564:        if ( $user_params->{'pretty_formatting'} )
ParamList.pm:573:        $out .= sprintf "%-${max_length}s  ", $param->Name;
ParamList.pm:575:        if ( $user_params->{'evaluate_expressions'} )
ParamList.pm:577:     	    $out .= $param->evaluate([], $plist);            
ParamList.pm:581:            $out .= $param->toString($plist);
ParamList.pm:585:        if ( $user_params->{'pretty_formatting'} )
ParamList.pm:591:            $out .= "  # " . $param->Type . "\n";
ParamList.pm:615:    if ( $user_params->{pretty_formatting} )
ParamList.pm:618:        foreach my $param ( @{$plist->Array} )
ParamList.pm:620:		    my $type= $param->Type;
ParamList.pm:621:            next unless ( $param->Type eq 'Function' );
ParamList.pm:623:            my $string = $param->Ref->toString( $plist, 1);
ParamList.pm:631:    foreach my $param ( @{$plist->Array} )
ParamList.pm:633:		my $type= $param->Type;
ParamList.pm:634:        next unless ( $param->Type eq 'Function' );
ParamList.pm:636:        if ( $user_params->{'pretty_formatting'} )
ParamList.pm:638:            $out .= '  ' . $param->Ref->toString( $plist, 1, $max_length) . "\n";
ParamList.pm:642:            next if ( $param->Ref->checkLocalDependency($plist) );
ParamList.pm:644:            $out .= ' ' . $param->Ref->toString( $plist, 0) . "\n";
ParamList.pm:669:    foreach my $param ( @{$plist->Array} )
ParamList.pm:671:        if ( $param->Type eq 'Function' )
ParamList.pm:674:            my ($fcn_copy,$err) = $param->Ref->clone( $plist, 0, 1 );
ParamList.pm:697:    my ($param,$err) = $plist->lookup($pname);
ParamList.pm:701:    if ($param->Type ne 'Local') {  return "Parameter $pname is not a local parameter";  }
ParamList.pm:704:    delete $plist->Hash->{$pname};
ParamList.pm:728:    my ($param,$err) = $plist->lookup($pname);
ParamList.pm:732:    delete $plist->Hash->{$pname};
ParamList.pm:735:    my $index = @{$plist->Array};
ParamList.pm:738:        --$index;
ParamList.pm:739:        if ( $param == $plist->Array->[$index] )
ParamList.pm:741:            splice( @{$plist->Array}, $index, 1);
ParamList.pm:747:    my $index = @{$plist->Unchecked};
ParamList.pm:750:        --$index;
ParamList.pm:751:        if ( $param == $plist->Unchecked->[$index] )
ParamList.pm:753:            splice( @{$plist->Unchecked}, $index, 1);
ParamList.pm:778:    foreach my $param (@{$plist->Unchecked})
ParamList.pm:781:        #printf "Checking if parameter %s is defined.\n", $param->Name;
ParamList.pm:782:        unless ( $param->Type )
ParamList.pm:784:            $err= sprintf "Parameter %s is referenced but not defined", $param->Name;
ParamList.pm:790:    foreach my $param ( @{$plist->Unchecked} )
ParamList.pm:792:        #printf "Checking parameter %s for cycles.\n", $param->Name;
ParamList.pm:794:        (my $dep, $err) = ($param->Expr->depends( $plist, $param->Name ));
ParamList.pm:797:            $err= sprintf "Parameter %s has a dependency cycle %s", $param->Name, $param->Name.'->'.$dep;
ParamList.pm:805:        undef @{$plist->Unchecked};
ParamList.pm:806:        #printf "Unchecked=%d\n", scalar(@{$plist->Unchecked});
ParamList.pm:828:        $plist->Array( [sort by_depends @{$plist->Array}] );
ParamList.pm:834:        (my $dep_a, $err) = $a->Expr->depends( $plist, $b->Name );
ParamList.pm:836:        {   #printf "$err %s %s\n", $a->Name, $b->Name;
ParamList.pm:841:        {   #printf "%s depends on %s\n", $a->Name, $b->Name;
ParamList.pm:845:        (my $dep_b, $err) = $b->Expr->depends( $plist, $a->Name );
ParamList.pm:852:        {   #printf "%s depends on %s\n", $b->Name, $a->Name;
ParamList.pm:853:            return(-1);
ParamList.pm:856:        #printf "%s and %s are independent\n", $a->Name, $b->Name;
ParamList.pm:879:    ($err) = $plist->check();
ParamList.pm:883:    ($err) = $plist->sort();
ParamList.pm:891:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:893:        my $type = $param->Type;
ParamList.pm:894:        my $expr = $param->Expr;
ParamList.pm:897:            $param->Index( $n_expressions );
ParamList.pm:898:            $param->CVodeRef( "NV_Ith_S(expressions,$n_expressions)" );
ParamList.pm:903:            $param->Index( $n_expressions );
ParamList.pm:904:            $param->CVodeRef( "NV_Ith_S(expressions,$n_expressions)" );
ParamList.pm:909:            $param->Index( $n_observables );
ParamList.pm:910:            $param->CVodeRef( "NV_Ith_S(observables,$n_observables)" );
ParamList.pm:915:            $param->Index( undef );
ParamList.pm:916:            $param->CVodeRef( '' );
ParamList.pm:949:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:952:        my $type = $param->Type;
ParamList.pm:956:            $expr_defs .= $indent . $param->getCVodeName() . " = parameters[$n_constants];\n";
ParamList.pm:962:            $expr_defs .= $indent . $param->getCVodeName() . " = " .  $param->Expr->toCVodeString( $plist ) . ";\n";    
ParamList.pm:997:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:1000:        my $type = $param->Type;
ParamList.pm:1004:            $expr_defs .= $indent . $param->getMatlabName() . " = parameters(" . ($n_constants + $offset) . ");\n";
ParamList.pm:1010:            $expr_defs .= $indent . $param->getMatlabName() . " = " .  $param->Expr->toMatlabString( $plist ) . ";\n";    
ParamList.pm:1038:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:1040:        if ( $param->Type eq 'Observable')
ParamList.pm:1042:            my $obsrv = $param->Ref;
ParamList.pm:1044:            $obsrv_defs .= $indent . $param->getCVodeName() . " = " . $obsrv->toCVodeString($plist) . ";\n";
ParamList.pm:1072:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:1074:        if ( $param->Type eq 'Observable')
ParamList.pm:1076:            my $obsrv = $param->Ref;
ParamList.pm:1078:            $obsrv_defs .= $indent . $param->getMatlabName() . " = " . $obsrv->toMatlabString($plist) . ";\n";
ParamList.pm:1105:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:1107:        if ( $param->Type eq 'Constant')
ParamList.pm:1109:  		    push @default_values, $param->evaluate([], $plist); 
ParamList.pm:1110:  		    push @constant_names, "'" . $param->Name . "'";
ParamList.pm:1134:    foreach my $param ( @{ $plist->Array } )
ParamList.pm:1136:        if    ( $param->Type eq 'Observable')
ParamList.pm:1138:	        push @observable_names, "'" . $param->Name . "'";
ParamList.pm:1160:    foreach my $param ( @{$plist->Array} )
ParamList.pm:1162:        ++$count  if ( $param->Type  eq $type );
Param.pm:34:		             Observable         => 1,  # A variable defined by the name of an Observable - may take a single argument
Param.pm:54:    #print STDERR "eval param name: ", $param->Name ,"  type: ", $param->Type, "\n";
Param.pm:55:    if ($param->Type eq 'Constant'  or  $param->Type eq 'ConstantExpression' )
Param.pm:57:        if ( defined $param->Expr )
Param.pm:58:        {   return $param->Expr->evaluate( $plist, $level+1);   }
Param.pm:60:    elsif ( $param->Type eq 'Function'  or $param->Type eq 'Observable' )
Param.pm:62:        if ( defined $param->Ref )
Param.pm:63:        {   return $param->Ref->evaluate( $args, $plist, $level+1);   }
Param.pm:79:    return undef unless ( $param->Type eq 'Constant'  or  $param->Type eq 'ConstantExpression' );
Param.pm:81:    my $param_copy = Param->new( 'Name' => $param->Name, 'Type' => $param->Type );
Param.pm:82:    if (defined $param->Expr)
Param.pm:84:        my ($expr_copy, $err) = $param->Expr->clone($plist);
Param.pm:86:        $param_copy->Expr( $expr_copy );
Param.pm:109:    $param->Type($type);
Param.pm:110:    if ($ref) {  param->Ref($ref);  }
Param.pm:130:    if ( $param->Type eq 'Constant'  and  $expand == 2 )
Param.pm:132:        return $param->Name;
Param.pm:136:        if ( defined $param->Expr )
Param.pm:138:            return $param->Expr->toString($plist, $level, $expand);
Param.pm:154:# ($param, $err) = Param->readXML( \%xml_hash, $plist ) 
Param.pm:160:    my $string = $xml_hash->{'-value'};
Param.pm:161:    my $expr = Expression->new();
Param.pm:162:    $expr->setAllowForward(1);
Param.pm:163:    if ( my $err = $expr->readString( \$string, $plist ) ) { return undef, $err; }
Param.pm:164:    $expr->setAllowForward(0);
Param.pm:167:    my $param = Param->new( 'Name'  => $xml_hash->{'-id'},
Param.pm:168:                            'Type' => $xml_hash->{'-type'},
Param.pm:189:    if ( $param->Type eq 'Constant'  and  $expand == 2 )
Param.pm:191:        return $param->Name;
Param.pm:195:        if ( $param->Expr )
Param.pm:197:            return $param->Expr->toXML($plist, $level, $expand);
Param.pm:221:    if ( $param->Type eq 'Constant' )
Param.pm:223:        return $param->getCVodeName;
Param.pm:225:    elsif ( $param->Expr )
Param.pm:227:        return $param->Expr->toCVodeString($plist, $level, $expand);
Param.pm:245:    my $type = $param->Type;
Param.pm:246:    my $expr = $param->Expr;
Param.pm:251:        $name = 'NV_Ith_S(expressions,' . $param->Index .')';
Param.pm:255:        $name = 'NV_Ith_S(expressions,' . $param->Index .')';   
Param.pm:259:        $name = 'NV_Ith_S(observables,' . $param->Index .')'; 
Param.pm:263:        $name = $param->Name;
Param.pm:267:        $name = $param->Name;
Param.pm:285:    if    ( $param->Type eq 'Constant')
Param.pm:287:        $name = 'expressions(' . ($param->Index + $offset) .')';
Param.pm:289:    elsif ( $param->Type eq 'ConstantExpression' )
Param.pm:291:        $name = 'expressions(' . ($param->Index + $offset) .')';   
Param.pm:293:    elsif ( $param->Type eq 'Observable' )
Param.pm:295:        $name = 'observables(' . ($param->Index + $offset) .')'; 
Param.pm:299:        $name = $param->Name;
Param.pm:303:        $name = $param->Name;
Param.pm:307:        $name = $param->Name;
Param.pm:328:    if ( $param->Type eq 'Constant' )
Param.pm:330:        return 'expressions(' . ($param->Index + $offset) . ')';
Param.pm:332:    elsif ( $param->Expr )
Param.pm:334:        return $param->Expr->toMatlabString($plist, $level, $expand);
Param.pm:363:        $string.= " id=\"".$param->Name."\"";
Param.pm:366:    $string.= " name=\"".$param->Name."\"";
Param.pm:368:    $string.= " type=\"".$param->Type."\"";
Param.pm:387:    if ($param->Expr)
Param.pm:389:        return($param->Expr->toMathMLString($plist,$indent));
PopulationList.pm:45:    ($err,$pop) = Population::newPopulation( $string, $model, scalar @{$pop_list->List} );
PopulationList.pm:50:    my $species_label    = $pop->SpeciesGraph->StringExact;
PopulationList.pm:51:    my $population_label = $pop->Population->StringExact;
PopulationList.pm:55:    if ( exists $pop_list->MapSpecies->{$species_label} )
PopulationList.pm:62:    if ( exists $pop_list->MapPopulations->{$population_label} )
PopulationList.pm:69:    push @{$pop_list->List}, $pop;
PopulationList.pm:70:    $pop_list->MapSpecies->{$species_label} = $population_label;
PopulationList.pm:71:    $pop_list->MapPopulations->{$population_label} = $species_label;
PopulationList.pm:88:    return scalar @{$pop_list->List};
Population.pm:49:    unless ( defined $rr->Name )
Population.pm:51:        $rr->Name( 'MapRule' . $index );
Population.pm:55:    $pop = Population->new( SpeciesGraph=>$rr->Reactants->[0], Population=>$rr->Products->[0], MappingRule=>$rr );
Population.pm:58:    my $spec = Species->new( SpeciesGraph=>$pop->SpeciesGraph, Concentration=>0, Index=>$index, RulesApplied=>0, ObservablesApplied=>0 );
Population.pm:59:    $pop->SpeciesGraph->Species($spec);
RateLaw.pm:42:#        if    ($key eq "Type")       { $rl->setTotalRate( $value );  }
RateLaw.pm:43:#        elsif ($key eq "Constants")  { $rl->setConstants( $value );  }
RateLaw.pm:44:#        elsif ($key eq "Factor")     { $rl->setFactor( $value );     }
RateLaw.pm:45:#        elsif ($key eq "TotalRate")  { $rl->setTotalRate( $value );  }
RateLaw.pm:46:#        elsif ($key eq "EnergyHash") { $rl->setEnergyHash( $value ); }
RateLaw.pm:62:#    $rl->[TYPE] = $value;
RateLaw.pm:67:#    return $rl->[TYPE];
RateLaw.pm:75:#    $rl->[CONSTANTS] = $value;
RateLaw.pm:80:#    return $rl->[CONSTANTS];
RateLaw.pm:88:#    $rl->[FACTOR] = $value;
RateLaw.pm:94:#    return $rl->[FACTOR];
RateLaw.pm:102:#    $rl->[TOTALRATE] = $value;
RateLaw.pm:108:#    return $rl->[TOTALRATE];
RateLaw.pm:116:#    $rl->[ENERGYHASH] = $value;
RateLaw.pm:121:#    return $rl->[ENERGYHASH];
RateLaw.pm:157:    $rl_copy->Type( $rl->Type );
RateLaw.pm:158:    @{$rl_copy->Constants} = @{$rl->Constants};
RateLaw.pm:159:    $rl_copy->Factor( $rl->Factor );
RateLaw.pm:160:    $rl_copy->TotalRate( $rl->TotalRate );
RateLaw.pm:161:    %{$rl_copy->EnergyHash} = %{$rl_copy->EnergyHash};
RateLaw.pm:200:    my $energyBNG = exists $model->Options->{energyBNG} ? $model->Options->{energyBNG} : 0;
RateLaw.pm:216:            ($param, $err) = $model->ParamList->lookup($rc);
RateLaw.pm:240:        my $expr1 = Expression->new();
RateLaw.pm:241:        my $err = $expr1->readString( \$expr_string_1, $model->ParamList );
RateLaw.pm:244:        my $name1 = $expr1->getName( $model->ParamList, "localFuncL", $force_fcn );
RateLaw.pm:246:        (my $param1, my $err) = $model->ParamList->lookup($name1);
RateLaw.pm:249:        my $expr2 = Expression->new();
RateLaw.pm:250:        my $err = $expr2->readString( \$expr_string_2, $model->ParamList );
RateLaw.pm:253:        my $name2 = $expr2->getName( $model->ParamList, "localFuncR", $force_fcn );
RateLaw.pm:255:        (my $param2, my $err) = $model->ParamList->lookup($name2);
RateLaw.pm:266:        my $expr = Expression->new();
RateLaw.pm:267:        my $err = $expr->readString( \$string_left, $model->ParamList, "," );
RateLaw.pm:271:        my $name = $expr->getName( $model->ParamList, $basename, $force_fcn );
RateLaw.pm:273:        (my $param, $err) = $model->ParamList->lookup($name);
RateLaw.pm:276:        if ( $param->Type eq "Constant"  or  $param->Type eq "ConstantExpression" )
RateLaw.pm:283:            if ( $totalRate   and  $expr->checkLocalDependency($model->ParamList) )
RateLaw.pm:293:    {   # REMOVED IMPLICIT RATELAWS!!  --Justin
RateLaw.pm:303:    my $rl = RateLaw->new( Type=>$rate_law_type, Constants=>[@rate_constants], TotalRate=>$totalRate, Factor=>$rate_fac );
RateLaw.pm:306:    if ( $err = $rl->validate($reactants,$model) )
RateLaw.pm:339:        ( $param, $err ) = $plist->lookup($1);
RateLaw.pm:342:            $value = $param->evaluate([], $plist);
RateLaw.pm:377:        while ( $string_left =~ s/^([A-Za-z0-9_]+)\s*// )
RateLaw.pm:381:            ( $param, $err ) = $plist->lookup($rc);
RateLaw.pm:398:            ($param, $err) = $plist->lookup($name);
RateLaw.pm:402:            if ( $param->Type =~ /^Constant/ )
RateLaw.pm:426:    $rl = RateLaw->new();
RateLaw.pm:427:    $rl->Type($rate_law_type);
RateLaw.pm:428:    $rl->Constants( [@rate_constants] );
RateLaw.pm:429:    $rl->TotalRate(0);  
RateLaw.pm:430:    $rl->Factor($rate_fac);
RateLaw.pm:433:    if ( $err = $rl->validate ) {  return '', $err;  }
RateLaw.pm:451:    if ( %{$ref_map}  and  $rr->RateLaw->Type eq 'Function' )
RateLaw.pm:454:        (my $rl_param) = $model->ParamList->lookup( $rl->Constants->[0] );
RateLaw.pm:455:        unless ( $rl_param->Type eq 'Function' )
RateLaw.pm:456:        {   die "Error in RateLaw->evaluate_local(): cannot find parameter for functional RateLaw!";   }
RateLaw.pm:459:        my $fcn = $rl_param->Ref;                     
RateLaw.pm:462:        if ( $fcn->checkLocalDependency($model->ParamList) )
RateLaw.pm:466:            my @local_refs = ($fcn->Name);
RateLaw.pm:467:            push @local_refs, map {$ref_map->{$_}} @{$fcn->Args};
RateLaw.pm:470:            (my $local_fcn) = $fcn->evaluate_local( \@local_refs, $model->ParamList );
RateLaw.pm:474:            $model->ParamList->set( $local_fcn->Name, $local_fcn->Expr, 1, 'Function', $local_fcn );
RateLaw.pm:477:            my $local_rl = RateLaw->new( Type=>'Function', Constants=>[$local_fcn->Name], Factor=>$rr->RateLaw->Factor );
RateLaw.pm:506:    return 0  unless ( $rl1->Type  eq  $rl2->Type );
RateLaw.pm:508:    return 0  unless ( @{$rl1->Constants} == @{$rl2->Constants} );
RateLaw.pm:510:    return 0  unless ( $rl1->Factor  ==  $rl2->Factor );    
RateLaw.pm:512:    return 0  unless ( $rl1->TotalRate  eq  $rl2->TotalRate );
RateLaw.pm:515:    if ( $rl1->Type eq 'Function' )
RateLaw.pm:518:        my ($par1, $err) = $plist->lookup( $rl1->Constants->[0] );
RateLaw.pm:521:        my ($par2, $err) = $plist->lookup( $rl2->Constants->[0] );
RateLaw.pm:524:        return 0  unless ( Function::equivalent($par1->Ref, $par2->Ref, $plist) );
RateLaw.pm:529:        for ( my $i = 0;  $i < @{$rl1->Constants};  ++$i )
RateLaw.pm:531:            return 0  unless ( $rl1->Constants->[$i] eq $rl2->Constants->[$i] );
RateLaw.pm:558:    if ( (defined $rl->Factor)  and  ($rl->Factor ne '1')  and  ($rl->Factor ne '') )
RateLaw.pm:560:        $ratelaw_mult = Expression::newNumOrVar( $rl->Factor );
RateLaw.pm:574:    if ( defined $ratelaw_mult ) { $string .= $ratelaw_mult->evaluate($plist) . "*"; }
RateLaw.pm:577:    my $type = $rl->Type;
RateLaw.pm:578:    my $rcs  = $rl->Constants->[0];
RateLaw.pm:587:        my $last = @{$rl->Constants}-1;
RateLaw.pm:588:        my @local_refs = @{$rl->Constants}[1..$last]; 
RateLaw.pm:597:            $string.= $type." ".join(' ', @{$rl->Constants});
RateLaw.pm:599:            $string.= $type."(".join(',', @{$rl->Constants}).")";
RateLaw.pm:624:    if ( (defined $rl->Factor)  and  ($rl->Factor ne '1')  and  ($rl->Factor ne '') )
RateLaw.pm:626:        $ratelaw_mult = Expression::newNumOrVar( $rl->Factor );
RateLaw.pm:642:    if (defined $ratelaw_mult) {  push @rl_terms, $ratelaw_mult->toCVodeString( $plist );  }
RateLaw.pm:644:    my $type = $rl->Type;
RateLaw.pm:645:    my $rate_constants = $rl->Constants;
RateLaw.pm:650:        (my $const) = $plist->lookup( $rate_constants->[0] );
RateLaw.pm:653:        push @rl_terms, $const->toCVodeString($plist);
RateLaw.pm:659:            push @rl_terms, $reactant->getCVodeName;             
RateLaw.pm:665:        (my $fcn_param) = $plist->lookup( $rate_constants->[0] ); 
RateLaw.pm:667:        my $fcn = $fcn_param->Ref;
RateLaw.pm:671:        if ( @{$fcn->Args} )
RateLaw.pm:675:                foreach my $tag (  @{$fcn->Args} )
RateLaw.pm:677:                    unless ( (exists $rrefs->{$tag}) and (exists $reactants->[$rrefs->{$tag}]) )
RateLaw.pm:680:                    push @fcn_args, ($reactants->[$rrefs->{$tag}])->getCVodeName;
RateLaw.pm:688:        #push @rl_terms, $fcn->toCVodeString( $plist, {'fcn_mode' => 'call'});
RateLaw.pm:690:        push @rl_terms, $fcn->Name . '(' . join( ',', @fcn_args ) . ')';
RateLaw.pm:696:            push @rl_terms, $reactant->getCVodeName;
RateLaw.pm:701:        #$string.= $type."(".join(',', @{$rl->Constants}).")";
RateLaw.pm:727:    if ( (defined $rl->Factor)  and  ($rl->Factor ne '1')  and  ($rl->Factor ne '') )
RateLaw.pm:729:        $ratelaw_mult = Expression::newNumOrVar( $rl->Factor );
RateLaw.pm:744:    if (defined $ratelaw_mult) {  push @rl_terms, $ratelaw_mult->toMatlabString( $plist );  }
RateLaw.pm:746:    my $type = $rl->Type;
RateLaw.pm:747:    my $rate_constants = $rl->Constants;
RateLaw.pm:752:        (my $const) = $plist->lookup( $rate_constants->[0] );
RateLaw.pm:755:        push @rl_terms, $const->toMatlabString($plist);
RateLaw.pm:761:            push @rl_terms, $reactant->getMatlabName();          
RateLaw.pm:767:        (my $fcn_param) = $plist->lookup( $rate_constants->[0] ); 
RateLaw.pm:769:        my $fcn = $fcn_param->Ref;
RateLaw.pm:773:        if ( @{$fcn->Args} )
RateLaw.pm:777:                foreach my $tag (  @{$fcn->Args} )
RateLaw.pm:779:                    unless ( (exists $rrefs->{$tag}) and (exists $reactants->[$rrefs->{$tag}]) )
RateLaw.pm:782:                    push @fcn_args, ($reactants->[$rrefs->{$tag}])->getMatlabName();
RateLaw.pm:790:        #push @rl_terms, $fcn->toMatlabString( $plist, {'fcn_mode' => 'call'});
RateLaw.pm:792:        push @rl_terms, $fcn->Name . '(' . join( ',', @fcn_args ) . ')';
RateLaw.pm:798:            push @rl_terms, $reactant->getMatlabName();
RateLaw.pm:803:        #$string.= $type."(".join(',', @{$rl->Constants}).")";
RateLaw.pm:829:    if ( $rl->Type eq "Function" )
RateLaw.pm:831:        return ( $rl->toXMLFunction( $indent, $rr_id, $plist, $rrefs ) );
RateLaw.pm:835:    if ( $rl->Type eq "FunctionProduct" )
RateLaw.pm:837:        return ( $rl->toXMLFunctionProduct( $indent, $rr_id, $plist, $rrefs ) );
RateLaw.pm:857:    $string .= " type=\"" . $rl->Type . "\"";
RateLaw.pm:860:    $string .= " totalrate=\"" . $rl->TotalRate . "\"";
RateLaw.pm:862:    # StatFactor (Is this used anymore??  --Justin)
RateLaw.pm:863:    unless ( $rl->Factor == 1 )
RateLaw.pm:864:    {   $string .= " statFactor=\"" . $rl->Factor . "\"";   }
RateLaw.pm:871:    foreach my $rc ( @{ $rl->Constants } )
RateLaw.pm:923:    $string .= " type=\"" . $rl->Type . "\"";
RateLaw.pm:925:    $string .= " name=\"" . $rl->Constants->[0] . "\"";
RateLaw.pm:927:    $string .= " totalrate=\"" . $rl->TotalRate . "\"";
RateLaw.pm:933:    my ( $param, $err ) = $plist->lookup( $rl->Constants->[0] );
RateLaw.pm:934:    my $fun = $param->Ref;
RateLaw.pm:936:    foreach my $arg ( @{$fun->Args} )
RateLaw.pm:939:        my $ptr = $rrefs->{$arg};
RateLaw.pm:982:    $string .= " type=\"" . $rl->Type . "\"";
RateLaw.pm:984:    $string .= " name1=\"" . $rl->Constants->[0] . "\"";
RateLaw.pm:985:    $string .= " name2=\"" . $rl->Constants->[1] . "\"";
RateLaw.pm:987:    $string .= " totalrate=\"" . $rl->TotalRate . "\"";
RateLaw.pm:993:    my ( $param1, $err ) = $plist->lookup( $rl->Constants->[0] );
RateLaw.pm:994:    my $fun1 = $param1->Ref;
RateLaw.pm:996:    foreach my $arg ( @{$fun1->Args} )
RateLaw.pm:999:        my $ptr = $rrefs->{$arg};
RateLaw.pm:1011:    my ( $param2, $err ) = $plist->lookup( $rl->Constants->[1] );
RateLaw.pm:1012:    my $fun2 = $param2->Ref;
RateLaw.pm:1014:    foreach my $arg ( @{$fun2->Args} )
RateLaw.pm:1017:        my $ptr = $rrefs->{$arg};
RateLaw.pm:1046:    if ( $rl->Type eq 'Ele' )
RateLaw.pm:1050:    elsif ( $rl->Type eq 'Sat' )
RateLaw.pm:1052:        if ( @{$rl->Constants} < 2 )
RateLaw.pm:1058:            if ( @{$rl->Constants} > @{$reactants} + 1 )
RateLaw.pm:1064:    elsif ( $rl->Type eq 'MM' )
RateLaw.pm:1066:        if ( @{$rl->Constants} != 2 )
RateLaw.pm:1068:            return "Michaelis-Menton type ratelaws require exactly 2 rate constants";
RateLaw.pm:1074:                return "Michaelis-Menton type ratelaw require exactly 2 reactants (e.g. Substrate + Enzyme)";
RateLaw.pm:1076:            if ( ref $reactants->[0] eq 'SpeciesGraph'  and  ref $reactants->[1] eq 'SpeciesGraph' )
RateLaw.pm:1078:                if (      $reactants->[0]->isomorphicToSubgraph($reactants->[1])
RateLaw.pm:1079:                     and  $reactants->[1]->isomorphicToSubgraph($reactants->[0]) )
RateLaw.pm:1081:                    return "Michaelis-Menton type ratelaw requires non-identical reactants (e.g. Substrate + Enzyme)";
RateLaw.pm:1086:                    my $err = $model->MoleculeTypesList->checkSpeciesGraph( $reactants->[0],
RateLaw.pm:1091:                        send_warning( "In rule with Michaelis-Menton type ratelaw:\n"
RateLaw.pm:1099:    elsif ( $rl->Type eq 'Hill' )
RateLaw.pm:1101:        if ( @{$rl->Constants} != 3 )
RateLaw.pm:1106:    elsif ( $rl->Type eq 'Function' )
RateLaw.pm:1110:    elsif ( $rl->Type eq 'FunctionProduct' )
RateLaw.pm:1137:    my @k    = @{ $rl->Constants };
RateLaw.pm:1138:    my $type = $rl->Type;
RateLaw.pm:1140:    $statFactor *= $rl->Factor;
RateLaw.pm:1143:    foreach my $index ( 0 .. $#{ $plist->Array } )
RateLaw.pm:1145:        my $pname = $plist->Array->[$index]->Name;
RateLaw.pm:1158:            $string .= " x_{" . $reac->Index . "}";
RateLaw.pm:1182:    my @k    = @{ $rl->Constants };
RateLaw.pm:1183:    my $type = $rl->Type;
RateLaw.pm:1187:    $statFactor *= $rl->Factor;
RateLaw.pm:1256:                $$rindices[ $ik - 1 ];
RateLaw.pm:1269:        return ( '', "Michaelis-Menton type reactions are not curently handled." );
RefineRule.pm:52:	$sep = '^\s*[+]\s*|^\s*([<]?-[>])\s*';    #  "+"  or "->"  or "<->"
RefineRule.pm:53:	$ipatt = -1;
RefineRule.pm:56:		$g = SpeciesGraph->new();
RefineRule.pm:58:		$err = $g->readString( \$string, $model->CompartmentList, SpeciesGraph::IS_SPECIES,
RefineRule.pm:59:		                         $sep, $model->MoleculeTypesList );
RefineRule.pm:64:		if ( defined $g->Label  and  $g->Label ne '' )
RefineRule.pm:66:            $rrefs->{ $g->Label } = $ipatt;
RefineRule.pm:70:		my $imol = -1;
RefineRule.pm:71:		foreach my $mol ( @{ $g->Molecules } )
RefineRule.pm:74:			my $label = $mol->Label;
RefineRule.pm:82:				$rrefs->{$label} = join '.', ($ipatt, $imol);
RefineRule.pm:84:			my $icomp = -1;
RefineRule.pm:87:			foreach my $comp ( @{ $mol->Components } )
RefineRule.pm:90:				$label = $comp->Label;
RefineRule.pm:98:					$rrefs->{$label} = join '.', ($ipatt, $imol, $icomp);
RefineRule.pm:115:			$reversible = ( $1 eq "<->" ) ? 1 : 0;
RefineRule.pm:129:	$ipatt = -1;
RefineRule.pm:132:		my $g = SpeciesGraph->new();	
RefineRule.pm:134:		$err = $g->readString( \$string, $model->CompartmentList, SpeciesGraph::IS_SPECIES,
RefineRule.pm:135:		                       $sep, $model->PopulationTypesList );
RefineRule.pm:141:        unless ( @{$g->Molecules} == 1 )
RefineRule.pm:146:        if ( defined $model->MoleculeTypesList->findMoleculeType($g->Molecules->[0]->Name) )
RefineRule.pm:151:        unless ( @{$g->Molecules->[0]->Components} == 0 )
RefineRule.pm:158:		if ( defined $g->Label  and  $g->Label ne '' )
RefineRule.pm:160:			$prefs->{ $g->Label } = $ipatt;
RefineRule.pm:164:		my $imol = -1;
RefineRule.pm:165:		foreach my $mol ( @{$g->Molecules} )
RefineRule.pm:168:			my $label = $mol->Label;
RefineRule.pm:181:					return ("Mis- or un-matched label $label in products of reaction rule $name", $rr);
RefineRule.pm:183:				$prefs->{$label} = join '.', ($ipatt, $imol);
RefineRule.pm:187:			my $icomp = -1;
RefineRule.pm:188:			foreach my $comp ( @{$mol->Components} )
RefineRule.pm:191:				$label = $comp->Label;
RefineRule.pm:206:						return ("Mis- or un-matched label $label in products of reaction rule $name", $rr);
RefineRule.pm:208:					$prefs->{$label} = join '.', ($ipatt, $imol, $icomp);
RefineRule.pm:238:	if (%$rrefs) {  setRefs( $rrefs, '', $model->ParamList );  }
RefineRule.pm:245:    if (%$rrefs) {  unsetRefs( $rrefs, $model->ParamList );  } 
RefineRule.pm:259:	$rr = RxnRule->new();
RefineRule.pm:260:	if ($name) {  $rr->Name($name);  }
RefineRule.pm:261:	$rr->Reactants( $reac );
RefineRule.pm:262:	$rr->Products(  $prod );
RefineRule.pm:263:	$rr->Priority( 0 );
RefineRule.pm:264:	$rr->RateLaw( $rl );
RefineRule.pm:265:	$rr->Rexclude( [([])] );
RefineRule.pm:266:	$rr->Pexclude( [([])] );
RefineRule.pm:267:	$rr->Rinclude( [([])] );
RefineRule.pm:268:	$rr->Pinclude( [([])] );
RefineRule.pm:269:	$rr->TotalRate( $TotalRate );
RefineRule.pm:270:	$rr->DeleteMolecules( 0 );
RefineRule.pm:271:	$rr->MoveConnected( 0 );
RefineRule.pm:272:	$rr->RRefs( $rrefs );
RefineRule.pm:273:	$rr->PRefs( $prefs );
RefineRule.pm:277:	if ( $err = $rr->findMap($model->PopulationTypesList) )
RefineRule.pm:292:##------------##
RefineRule.pm:294:##------------##
RefineRule.pm:312:	{   $params->{$opt} = $val;   }
RefineRule.pm:321:    %{$rr->RxnLabels} = ();
RefineRule.pm:324:    my $n_reactants = scalar @{$rr->Reactants};
RefineRule.pm:329:	foreach my $patt ( @{$rr->Reactants} )
RefineRule.pm:332:		$rr->Rmatches->[$ipatt] = [];
RefineRule.pm:333:        if ( $params->{exact} )
RefineRule.pm:335:            # add self-embedding of reactant pattern its match list
RefineRule.pm:336:            my $copy_patt = $patt->copy( !SpeciesGraph::COPY_LABEL, SpeciesGraph::GET_LABEL );        
RefineRule.pm:337:            (my $copy_match) = $patt->isomorphicToSubgraph($copy_patt);
RefineRule.pm:338:            push @{$rr->Rmatches->[$ipatt]}, $copy_match;
RefineRule.pm:350:                if ( $sg->isomorphicToSubgraph($patt) )
RefineRule.pm:358:                # add self-embedding of reactant pattern its match list
RefineRule.pm:359:                my $copy_patt = $patt->copy( !SpeciesGraph::COPY_LABEL, SpeciesGraph::GET_LABEL );
RefineRule.pm:360:                (my $copy_match) = $patt->isomorphicToSubgraph($copy_patt);
RefineRule.pm:361:                push @{$rr->Rmatches->[$ipatt]}, $copy_match;
RefineRule.pm:366:	    #my $n_matches = $rr->find_reactant_matches( $ipatt, $sg_list, $model );
RefineRule.pm:367:		my $new_matches = $rr->find_embeddings( $ipatt, $sg_list, $model );
RefineRule.pm:368:        push @{$rr->Rmatches->[$ipatt]}, @$new_matches;
RefineRule.pm:370:		if ( $params->{verbose} )
RefineRule.pm:372:		    my $tot_matches = @{$rr->Rmatches->[$ipatt]};
RefineRule.pm:373:		    printf $params->{indent} . "  ..found %d match%s to reactant pattern %d\n",
RefineRule.pm:382:    $rule_instances->initialize( $rr->Rmatches );
RefineRule.pm:386:    while ( $rule_instances->getNext($rule_instance) )
RefineRule.pm:389:        my $child_rule = $rr->restrict_rule( $rule_instance, $model, $hybrid_model, $params );
RefineRule.pm:392:        if ( exists $child_rule_map->{$child_rule->StringID} )
RefineRule.pm:394:            my $multiplicity = $child_rule->RateLaw->Factor;
RefineRule.pm:395:            my $prior_child_rule = $child_rule_map->{$child_rule->StringID};
RefineRule.pm:396:            $prior_child_rule->RateLaw->Factor( $prior_child_rule->RateLaw->Factor + $multiplicity );
RefineRule.pm:400:            $child_rule_map->{$child_rule->StringID} = $child_rule;
RefineRule.pm:408:        my $ratelaw = $child_rule->RateLaw;
RefineRule.pm:409:        unless ( $ratelaw->Factor == 1.0 )
RefineRule.pm:412:            my $param_name = $ratelaw->Constants->[0];
RefineRule.pm:413:            my ($rate_param,$err) = $hybrid_model->ParamList->lookup($param_name); 
RefineRule.pm:415:            my $new_rate_expr = Expression::operate( '*', [$ratelaw->Factor, $rate_param->Expr], $hybrid_model->ParamList );
RefineRule.pm:416:            my $new_param_name = $new_rate_expr->getName( $hybrid_model->ParamList, $param_name.'_' );
RefineRule.pm:417:            $ratelaw->Constants->[0] = $new_param_name;
RefineRule.pm:419:            $ratelaw->Factor(1);
RefineRule.pm:435:# $child_rule = $rule->restrict_rule( \@rule_instance, $model, $hpp_model, \%params )
RefineRule.pm:453:    {   $params->{$opt} = $val;   }
RefineRule.pm:457:    my $n_reactants = @{$rr->Reactants};
RefineRule.pm:458:    my $n_products  = @{$rr->Products};
RefineRule.pm:467:        my $match_copy = $match->copy_map_and_target();
RefineRule.pm:469:        $match_copy->transferLabels();
RefineRule.pm:472:        push @$reactants, $match_copy->Target;
RefineRule.pm:481:        foreach my $pattR ( @{$rr->Reactants} )
RefineRule.pm:482:        {   $pattR->gatherLabels( $used_labels );   }
RefineRule.pm:484:        foreach my $pattP ( @{$rr->Products} )
RefineRule.pm:485:        {   $pattP->gatherLabels( $used_labels );   }    
RefineRule.pm:491:            $i_label += $reactant->assignLabels( $i_label, $temp_labels, $used_labels );
RefineRule.pm:497:    # supported in NFsim.  So we'll cross this bridge later.  --Justin
RefineRule.pm:500:	my ( $products ) = $rr->apply_operations( $matches );
RefineRule.pm:507:        if ( $rr->DeleteMolecules  and  @$products > $n_products )
RefineRule.pm:509:            if ($params->{verbose})
RefineRule.pm:510:            {   printf "Deleting molecules in Rule %s\n", $rr->Name();  }
RefineRule.pm:515:	        if ($params->{verbose})
RefineRule.pm:516:	        {   printf "Rule %s: n_sub (%d)!= n_prod (%d)\n", $rr->Name, @$products, $n_products;   }
RefineRule.pm:524:	    my $p = $products->[$ip];
RefineRule.pm:525:	    my $iprod = ($ip < @{$rr->Products}) ? $ip : -1;
RefineRule.pm:528:		if ( @{$p->Molecules} > $params->{max_agg} )
RefineRule.pm:530:            #printf "%d molecules exceeds max_agg of %d\n", $#{$p->Molecules}+1, $max_agg;
RefineRule.pm:535:		while ( my ($key,$max) = each %{$params->{max_stoich}} )
RefineRule.pm:538:			if ( $p->stoich($key) > $max )
RefineRule.pm:540:                #printf "Stoichometry of $key in %s exceeds max of %d\n", $p->toString(), $max;
RefineRule.pm:545:        # Put product graph in canonical order (quasi-canonical for the time being)
RefineRule.pm:546:	    if ( my $err = $p->sortLabel() )
RefineRule.pm:550:        	    . ">>", $rr->toString(), "\n";
RefineRule.pm:557:			foreach my $patt_excl ( @{$rr->Pexclude->[$iprod]} )
RefineRule.pm:559:				if ( $patt_excl->isomorphicToSubgraph($p) )
RefineRule.pm:567:            if ( @{$rr->Pinclude->[$iprod]} )
RefineRule.pm:570:			    foreach my $patt_incl ( @{$rr->Pinclude->[$iprod]} )
RefineRule.pm:572:				    if ( $patt_incl->isomorphicToSubgraph($p) )
RefineRule.pm:585:    if ( defined $model->PopulationList )
RefineRule.pm:591:            next unless ( defined $reactant->Species );
RefineRule.pm:592:            foreach my $pop ( @{$model->PopulationList->List} )
RefineRule.pm:594:                if ( $pop->SpeciesGraph->isomorphicToSubgraph($reactant) )
RefineRule.pm:597:                    my $label = $reactant->Label();
RefineRule.pm:598:                    $reactant = $pop->Population->copy();
RefineRule.pm:599:                    $reactant->Label( $label );
RefineRule.pm:607:            foreach my $pop ( @{$model->PopulationList->List} )
RefineRule.pm:609:                if ( $pop->SpeciesGraph->isomorphicToSubgraph($product) )
RefineRule.pm:612:                    my $label = $product->Label();   
RefineRule.pm:613:                    $product = $pop->Population->copy();
RefineRule.pm:614:                    $product->Label( $label );
RefineRule.pm:621:    #  pre-compile the local function. But this can wait until we handle molecule rooted
RefineRule.pm:631:    my $name = $rr->Name . '_v' . ((scalar (keys %{$rr->RxnLabels})) + 1);
RefineRule.pm:634:    $child_rule->Name( $name );
RefineRule.pm:635:    $child_rule->Reactants( $reactants );
RefineRule.pm:636:    $child_rule->Products( $products );
RefineRule.pm:637:    $child_rule->RateLaw( $rr->RateLaw->copy() );
RefineRule.pm:638:    $child_rule->TotalRate( $rr->TotalRate );
RefineRule.pm:639:    $child_rule->Priority( $rr->Priority );	    
RefineRule.pm:640:    $child_rule->DeleteMolecules( $rr->DeleteMolecules );
RefineRule.pm:641:    $child_rule->MoveConnected( $rr->MoveConnected );
RefineRule.pm:647:        my $reactant = $reactants->[$ir];
RefineRule.pm:648:        if ( $reactant->isPopulationType($hybrid_model->MoleculeTypesList) )
RefineRule.pm:655:            push @$rinclude, [ map {$_->copy()->relinkCompartments($hybrid_model->CompartmentList)} @{$rr->Rinclude->[$ir]} ];
RefineRule.pm:656:            push @$rexclude, [ map {$_->copy()->relinkCompartments($hybrid_model->CompartmentList)} @{$rr->Rexclude->[$ir]} ];
RefineRule.pm:664:        my $product = $products->[$ip];
RefineRule.pm:666:        if ( $ip >= @{$rr->Products}  or  $product->isPopulationType($hybrid_model->MoleculeTypesList) )
RefineRule.pm:673:            push @$pinclude, [ map {$_->copy()->relinkCompartments($hybrid_model->CompartmentList)} @{$rr->Pinclude->[$ip]} ];
RefineRule.pm:674:            push @$pexclude, [ map {$_->copy()->relinkCompartments($hybrid_model->CompartmentList)} @{$rr->Pexclude->[$ip]} ];
RefineRule.pm:678:    $child_rule->Rinclude( $rinclude );
RefineRule.pm:679:    $child_rule->Pinclude( $rexclude );
RefineRule.pm:680:    $child_rule->Rexclude( $pinclude );
RefineRule.pm:681:    $child_rule->Pexclude( $pexclude );
RefineRule.pm:688:        my $sg = $reactants->[$i_sg];
RefineRule.pm:689:        $sg->gatherLabels( $rrefs, $i_sg );
RefineRule.pm:694:        my $sg = $products->[$i_sg];
RefineRule.pm:695:        $sg->gatherLabels( $prefs, $i_sg );
RefineRule.pm:697:    $child_rule->RRefs( $rrefs );
RefineRule.pm:698:    $child_rule->PRefs( $prefs );
RefineRule.pm:703:    my $stringID = join '+', (map {$_->toString()} @$reactants);
RefineRule.pm:704:    $stringID .= '->';
RefineRule.pm:705:    $stringID .= join '+', (map {$_->toString()} @$products[0..$n_products-1]);
RefineRule.pm:708:        $stringID .= '+' . join( '+', sort (map {$_->toString()} @$products[$n_products..$#$products]) );
RefineRule.pm:710:    $child_rule->StringID( $stringID );
RefineRule.pm:714:    if ( my $err = $child_rule->findMap( $hybrid_model->MoleculeTypesList ) )
RefineRule.pm:716:        send_warning( sprintf "Could not find reactant-product correspondence map for exapnded rule %s.", $child_rule->Name );
RefineRule.pm:722:    my $delmol = grep {$_ =~ /\./} @{$child_rule->MolDel};
RefineRule.pm:725:        unless ( $child_rule->DeleteMolecules )
RefineRule.pm:728:            $child_rule->DeleteMolecules(1);
RefineRule.pm:729:            if ( @{$rr->MolDel} )
RefineRule.pm:731:                send_warning( sprintf "DeleteMolecules flag added to rule %s.", $child_rule->Name );
RefineRule.pm:738:    $child_rule->RateLaw->Factor( 1 );
RefineRule.pm:741:    $rr->RxnLabels->{$stringID} = $child_rule;
RefineRule.pm:759:	else             {  return $n * factorial( $n - 1 );  }
RxnList.pm:38:    undef %{ $rlist->Hash };
RxnList.pm:46:    return scalar @{$rlist->Array};
RxnList.pm:69:    my $rstring = $rxn->stringID();
RxnList.pm:77:    elsif ( exists $rlist->Hash->{$rstring} )
RxnList.pm:79:        foreach my $rxn2 ( @{ $rlist->Hash->{$rstring} } )
RxnList.pm:82:            if ( $rxn->Priority == $rxn2->Priority )
RxnList.pm:85:                if ( RateLaw::equivalent($rxn->RateLaw, $rxn2->RateLaw, $plist) )
RxnList.pm:87:                    $rxn2->StatFactor( $rxn2->StatFactor + $rxn->StatFactor );
RxnList.pm:96:                    if ( ($rxn->RateLaw != $rxn2->RateLaw) and ($rxn->RxnRule == $rxn2->RxnRule) )
RxnList.pm:101:                            foreach my $const ( @{$rxn->RateLaw->Constants} )
RxnList.pm:102:                            {   $plist->deleteParam( $const );   }
RxnList.pm:106:                        undef %{$rxn->RateLaw};
RxnList.pm:110:                        $rxn->RateLaw( $rxn2->RateLaw );
RxnList.pm:117:            elsif ( $rxn->Priority < $rxn2->Priority )
RxnList.pm:123:            elsif ( $rxn->Priority > $rxn2->Priority )
RxnList.pm:128:                $rlist->remove($rxn2);
RxnList.pm:129:                --$n_add;
RxnList.pm:137:        push @{ $rlist->Array }, $rxn;
RxnList.pm:138:        push @{ $rlist->Hash->{$rstring} }, $rxn;
RxnList.pm:139:        foreach my $spec ( @{$rxn->Products} )
RxnList.pm:140:        {   ++($rlist->AsProduct->{$spec});   }
RxnList.pm:160:    foreach my $i ( 0 .. $#{$rlist->Array} )
RxnList.pm:162:        if ( $rxn == $rlist->Array->[$i] )
RxnList.pm:164:            printf "Deleting rxn %s\n", $rxn->toString();
RxnList.pm:165:            splice( @{$rlist->Array}, $i, 1 );
RxnList.pm:171:    my $harray = $rlist->Hash->{ $rxn->stringID() };
RxnList.pm:174:        if ( $rxn == $harray->[$i] )
RxnList.pm:176:            #printf "Deleting rxn from hash %s\n", $rxn->toString();
RxnList.pm:183:    # Species with non-zero concentration must exist
RxnList.pm:185:    #  *phash = $rlist->AsProduct;
RxnList.pm:186:    #  for my $spec ( @{ $rxn->Products } ) {
RxnList.pm:187:    #    if ( ( --$phash{$spec} ) == 0 ) {
RxnList.pm:190:    #      $rlist->SpeciesList->remove($spec);
RxnList.pm:212:    my $rxn = Rxn->new();
RxnList.pm:215:    my $nspec = scalar @{$slist->Array};
RxnList.pm:238:            {   push @ptrs, $slist->Array->[$index - 1];   }
RxnList.pm:245:    $rxn->Reactants( [@ptrs] );
RxnList.pm:263:            {   push @ptrs, $slist->Array->[$index - 1];   }
RxnList.pm:271:    $rxn->Products( [@ptrs] );
RxnList.pm:293:    $rxn->RateLaw($rl);
RxnList.pm:296:    $rxn->StatFactor(1);
RxnList.pm:297:    $rxn->Priority(0);
RxnList.pm:300:    my $n_add = $rlist->add($rxn);
RxnList.pm:320:    my $text = $params->{TextReaction};
RxnList.pm:328:    foreach my $rxn ( @{ $rlist->Array } )
RxnList.pm:330:        $out .= sprintf "%5d %s\n", $irxn, $rxn->toString( $text, $plist );
RxnList.pm:357:    while ( $i < @{$rlist->Array} )
RxnList.pm:359:        my $rxn = $rlist->Array->[$i];
RxnList.pm:360:        printf $fh "%5d %s\n", $i-$i_start+1, $rxn->toString();
RxnList.pm:382:    foreach my $rxn ( @{$rlist->Array} )
RxnList.pm:384:        $rxn->Index( $n_rxns );
RxnList.pm:412:    foreach my $rxn ( @{ $rlist->Array } )
RxnList.pm:414:        $rate_defs .= $indent . $rxn->getCVodeName() . ' = ' .  $rxn->getCVodeRate($plist) . ";\n";
RxnList.pm:442:    foreach my $rxn ( @{ $rlist->Array } )
RxnList.pm:444:        $rate_defs .= $indent . $rxn->getMatlabName() . ' = ' .  $rxn->getMatlabRate($plist) . ";\n";
RxnList.pm:467:	foreach my $rxn ( @{ $rlist->Array } )
RxnList.pm:469:		# Each reactant contributes a -1
RxnList.pm:470:		foreach my $reactant ( @{ $rxn->Reactants } )
RxnList.pm:471:		{   --( $stoich_hash->{ $reactant->Index }{$i_rxn} );   }
RxnList.pm:474:		foreach my $product ( @{ $rxn->Products } )
RxnList.pm:475:		{   ++( $stoich_hash->{  $product->Index }{$i_rxn} );   }
Rxn.pm:45:        foreach my $r ( @{$rxn->Reactants} )
Rxn.pm:46:        {   push @rstrings, $r->SpeciesGraph->toString();   }
Rxn.pm:47:        foreach my $p ( @{$rxn->Products} )
Rxn.pm:48:        {   push @pstrings, $p->SpeciesGraph->toString();   }
Rxn.pm:49:        $string = join(' + ', @rstrings) . " -> " . join(' + ', @pstrings);
Rxn.pm:53:        $string = $rxn->stringID(); 
Rxn.pm:65:    if ( defined( $rxn->StatFactor ) and ($rxn->StatFactor ne '') and ($rxn->StatFactor ne '1') )
Rxn.pm:66:    {   $rxn_mult = Expression::newNumOrVar( $rxn->StatFactor );   }
Rxn.pm:69:    (my $volume_expr, $err) = $rxn->volume_scale($plist);    
Rxn.pm:81:    $string .= $rxn->RateLaw->toString( $rxn_mult, 1, $plist );
Rxn.pm:83:    if ($rxn->RxnRule)
Rxn.pm:84:    {  $string .= " #" . $rxn->RxnRule->Name;  }
Rxn.pm:99:    return 'NV_Ith_S(ratelaws,' . $rxn->Index . ')'
Rxn.pm:112:    return 'ratelaws(' . ($rxn->Index + $offset) . ')';
Rxn.pm:131:    if ( defined( $rxn->StatFactor ) and ($rxn->StatFactor ne '') and ($rxn->StatFactor ne '1') )
Rxn.pm:132:    {   $rxn_mult = Expression::newNumOrVar( $rxn->StatFactor );   }
Rxn.pm:135:    (my $volume_expr, $err) = $rxn->volume_scale($plist);    
Rxn.pm:148:    if ( $rxn->RxnRule )
Rxn.pm:149:    {   $rrefs = $rxn->RxnRule->RRefs;   }
Rxn.pm:151:    return $rxn->RateLaw->toCVodeString( $rxn_mult, $rxn->Reactants, $rrefs, $plist );
Rxn.pm:171:    if ( defined( $rxn->StatFactor ) and ($rxn->StatFactor ne '') and ($rxn->StatFactor ne '1') )
Rxn.pm:172:    {   $rxn_mult = Expression::newNumOrVar( $rxn->StatFactor );   }
Rxn.pm:175:    (my $volume_expr, $err) = $rxn->volume_scale($plist);    
Rxn.pm:188:    if ( $rxn->RxnRule )
Rxn.pm:189:    {   $rrefs = $rxn->RxnRule->RRefs;   }
Rxn.pm:192:    return $rxn->RateLaw->toMatlabString( $rxn_mult, $rxn->Reactants, $rrefs, $plist );
Rxn.pm:213:    # if a reaction has zero reactants (or products).  --Justin, 29oct2010
Rxn.pm:219:    if ( @{$rxn->Reactants} )
Rxn.pm:220:    {   foreach my $r (@{$rxn->Reactants}) { push @rstrings, $r->Index; }   }
Rxn.pm:226:    if ( @{$rxn->Products} )
Rxn.pm:227:    {   foreach my $p (@{$rxn->Products}) { push @pstrings, $p->Index; };   }
Rxn.pm:231:    # sort reactants and products (if ratelaw is elementary or zero-order)
Rxn.pm:232:    my $type= $rxn->RateLaw->Type;
Rxn.pm:246:# ($vol_expr, $err) = $rxn->volume_scale($plist)
Rxn.pm:252:# Handle volume-dependent rate constants for compartment reactions.
Rxn.pm:259:# for bi-molecular reactions, the reaction compartment is the 3-D volume [V]
Rxn.pm:260:# unless all reactants are at a 2-D surface [S].
Rxn.pm:263:#  ----------------------------------------------------
Rxn.pm:273:#   0 -> S                 S  ??
Rxn.pm:274:#   0 -> V                 V  ??
Rxn.pm:284:    my @reactant_compartments = grep {defined $_} (map {$_->SpeciesGraph->Compartment} @{$rxn->Reactants});
Rxn.pm:285:    my @product_compartments  = grep {defined $_} (map {$_->SpeciesGraph->Compartment} @{$rxn->Products});
Rxn.pm:291:        my @surfaces = ( grep {$_->SpatialDimensions==2} @reactant_compartments );
Rxn.pm:292:        my @volumes  = ( grep {$_->SpatialDimensions==3} @reactant_compartments );
Rxn.pm:303:            push @vol_factors, ( map {$_->Size} (@surfaces, @volumes) );
Rxn.pm:325:            $vol_expr = $comp1->Size;
Rxn.pm:328:        {   send_warning("compartmental BioNetGen doesn't know how to handle zero-order synthesis of products in multiple compartments.");  }
Rxn.pm:337:# For energyBNG only!!  --Justin, 9nov2010
Rxn.pm:347:    my $epatts = $model->EnergyPatterns;
Rxn.pm:348:    my $plist = $model->ParamList;
Rxn.pm:353:    my $fingerprint = $rxn->getEnergyFingerprint( $epatts );
Rxn.pm:356:    if ( exists $rxn->RateLaw->EnergyHash->{ $fingerprint } )
Rxn.pm:359:        $rxn->RateLaw( $rxn->RateLaw->EnergyHash->{ $fingerprint } );
Rxn.pm:366:        push @rate_strings, '('. $rxn->RateLaw->Constants->[0] .')';
Rxn.pm:370:            (my $expr_term, $err) = $epatt->getRateExpression( $rxn, $plist );
Rxn.pm:373:            {   push @rate_strings, '('. $expr_term->toString( $plist ) .')';   }
Rxn.pm:381:        $rxn->RateLaw->EnergyHash->{ $fingerprint } = $updated_rate_law;
Rxn.pm:383:        $rxn->RateLaw( $updated_rate_law );
Rxn.pm:403:        (my $stoich, $err) = $epatt->getStoich( $rxn );
RxnRule.pm:29:# (currently implemented only for XML network-free output)
RxnRule.pm:30:#   --Justin  2dec2010
RxnRule.pm:46:	MapF      => '%',    # Map from reactants to products 'rP.rM.rC' -> 'pP.pM.pC'
RxnRule.pm:47:	MapR      => '%',    # Map from products to reactants 'pP.pM.pC' -> 'rP.rM.rC'
RxnRule.pm:74:	ReactionCenter  => '@', # array of reaction centers for each reactant pattern in RxnRule  --justin
RxnRule.pm:92:    $rr_copy->Name( $rr->Name );
RxnRule.pm:94:    @{$rr_copy->Reactants} = map {$_->copy()} @{$rr->Reactants};
RxnRule.pm:95:    @{$rr_copy->Products}  = map {$_->copy()} @{$rr->Products};
RxnRule.pm:98:    while ( $ir < @{$rr->Reactants} )
RxnRule.pm:100:        push @{$rr_copy->Rinclude}, [ map {$_->copy()} @{$rr->Rinclude->[$ir]} ];
RxnRule.pm:101:        push @{$rr_copy->Rexclude}, [ map {$_->copy()} @{$rr->Rexclude->[$ir]} ];
RxnRule.pm:106:    while ( $ip < @{$rr->Products} )
RxnRule.pm:108:        push @{$rr_copy->Pinclude}, [ map {$_->copy()} @{$rr->Pinclude->[$ip]} ];
RxnRule.pm:109:        push @{$rr_copy->Pexclude}, [ map {$_->copy()} @{$rr->Pexclude->[$ip]} ];
RxnRule.pm:113:    @{$rr_copy->Rmatches} = map { [@{$_}] } @{$rr->Rmatches};
RxnRule.pm:115:    %{$rr_copy->MapF} = %{$rr->MapF};
RxnRule.pm:116:    %{$rr_copy->MapR} = %{$rr->MapR};
RxnRule.pm:118:    $rr_copy->RateLaw( $rr->RateLaw->copy() ) if ( defined $rr->RateLaw );
RxnRule.pm:120:    $rr_copy->TotalRate( $rr->TotalRate );
RxnRule.pm:121:    $rr_copy->Priority( $rr->Priority );
RxnRule.pm:122:    $rr_copy->MultScale( $rr->MultScale );
RxnRule.pm:124:    if ( defined $rr->RuleInstances )
RxnRule.pm:126:        $rr_copy->RuleInstances( $rr_copy->RuleInstances->copy() );
RxnRule.pm:127:        $rr_copy->RuleInstances->Lists( [@{$rr_copy->Rmatches}] );
RxnRule.pm:130:    @{$rr_copy->EdgeAdd} = map { [@$_] } @{$rr->EdgeAdd};
RxnRule.pm:131:    @{$rr_copy->EdgeDel} = map { [@$_] } @{$rr->EdgeDel};       
RxnRule.pm:132:    @{$rr_copy->MolAdd}  = map { [@$_] } @{$rr->MolAdd};            
RxnRule.pm:133:    @{$rr_copy->MolDel}  = @{$rr->MolDel};
RxnRule.pm:134:    @{$rr_copy->CompStateChange}   = map { [@$_] } @{$rr->CompStateChange};      
RxnRule.pm:135:    @{$rr_copy->ChangeCompartment} = map { [@$_] } @{$rr->ChangeCompartment};      
RxnRule.pm:137:    %{$rr_copy->RRefs} = %{$rr->RRefs};
RxnRule.pm:138:    %{$rr_copy->PRefs} = %{$rr->PRefs};
RxnRule.pm:140:    $rr_copy->DeleteMolecules( $rr->DeleteMolecules );
RxnRule.pm:141:    $rr_copy->MoveConnected( $rr->MoveConnected );
RxnRule.pm:143:    @{$rr_copy->ReactionCenter} = @{$rr->ReactionCenter};
RxnRule.pm:144:    %{$rr_copy->RxnLabels} = %{$rr->RxnLabels};
RxnRule.pm:146:    $rr_copy->StringID( $rr->StringID );
RxnRule.pm:162:    %{$rr->RxnLabels} = ();
RxnRule.pm:163:    $rr->StringID( undef );
RxnRule.pm:188:	my $plist  = $model->ParamList;
RxnRule.pm:189:	my $clist  = $model->CompartmentList;
RxnRule.pm:190:	my $mtlist = $model->MoleculeTypesList;
RxnRule.pm:207:	elsif ( $string =~ /^0\s*(\+|->|<->)/ )
RxnRule.pm:223:	$sep = '^\s*[+]\s*|^\s*(<?->)\s*';    #  "+"  or "->"  or "<->"
RxnRule.pm:225:	my $ipatt = -1;
RxnRule.pm:230:		$g = SpeciesGraph->new();
RxnRule.pm:231:		$err = $g->readString( \$string, $clist, 0, $sep, $mtlist );
RxnRule.pm:235:        if ($g->Fixed)
RxnRule.pm:241:        unless ( $g->isNull() )
RxnRule.pm:247:            my $label = $g->Label;
RxnRule.pm:257:		    my $imol = -1;
RxnRule.pm:258:		    foreach my $mol ( @{$g->Molecules} )
RxnRule.pm:261:			    my $label = $mol->Label;
RxnRule.pm:268:			    my $icomp = -1;
RxnRule.pm:271:			    for my $comp ( @{ $mol->Components } )
RxnRule.pm:274:				    $label = $comp->Label;
RxnRule.pm:296:			$reversible = ( $1 eq "<->" ) ? 1 : 0;
RxnRule.pm:297:		    # check reversibility in energyBNG mode.  Does this matter?  Maybe issue warning?  --Justin, 9nov2010
RxnRule.pm:298:		    #if ( !$reversible  and  ($model->Options->{EnergyBNG}) )
RxnRule.pm:310:	$ipatt = -1;
RxnRule.pm:313:		my $g = SpeciesGraph->new();	
RxnRule.pm:314:		$err = $g->readString( \$string, $clist, 0, $sep, $mtlist );
RxnRule.pm:318:        if ($g->Fixed)
RxnRule.pm:324:		unless ( $g->isNull() )
RxnRule.pm:328:            my $label = $g->Label;
RxnRule.pm:341:                    elsif (  $labels{ $g->Label } =~ /^(found|PP|PM|PC)$/ )
RxnRule.pm:354:		    my $imol = -1;
RxnRule.pm:355:		    foreach my $mol ( @{ $g->Molecules } )
RxnRule.pm:358:			    my $label = $mol->Label;
RxnRule.pm:367:                        elsif  ( $labels{ $g->Label } =~ /^(RP|RC)$/ )
RxnRule.pm:371:                        elsif (  $labels{ $g->Label } =~ /^(found|PP|PM|PC)$/ )
RxnRule.pm:384:			    my $icomp = -1;
RxnRule.pm:385:			    for my $comp ( @{ $mol->Components } )
RxnRule.pm:388:				    $label = $comp->Label;
RxnRule.pm:399:                            elsif  ( $labels{ $g->Label } =~ /^(RP|RM)$/ )
RxnRule.pm:403:                            elsif (  $labels{ $g->Label } =~ /^(found|PP|PM|PC)$/ )
RxnRule.pm:410:                            $labels{ $g->Label } = 'PC'
RxnRule.pm:435:                     ."Please double-check rule if this is not your intention.";
RxnRule.pm:443:                     ."Please double-check rule if this is not your intention.";
RxnRule.pm:494:    #   a space is left in place of keyword.  --Justin 
RxnRule.pm:538:		my $index = $1 - 1;
RxnRule.pm:547:				$g = SpeciesGraph->new();
RxnRule.pm:548:				$err = $g->readString( \$arg, $clist, 0, $sep, $mtlist );
RxnRule.pm:561:				$g = SpeciesGraph->new();
RxnRule.pm:562:				$err = $g->readString( \$arg, $clist, 0, $sep, $mtlist );
RxnRule.pm:598:		my $index = $1 - 1;
RxnRule.pm:607:				$g = SpeciesGraph->new();
RxnRule.pm:608:				$err = $g->readString( \$arg, $clist, 0, $sep, $mtlist );
RxnRule.pm:621:				$g = SpeciesGraph->new();
RxnRule.pm:622:				$err = $g->readString( \$arg, $clist, 0, $sep, $mtlist );
RxnRule.pm:642:	my $rr  = RxnRule->new();
RxnRule.pm:643:	if ( $name ne '' ) {  $rr->Name($name);  }
RxnRule.pm:644:	$rr->Reactants( [@reac] );
RxnRule.pm:645:	$rr->Products(  [@prod] );
RxnRule.pm:646:	$rr->Priority($priority);
RxnRule.pm:647:	$rr->RateLaw( $rate_laws[0] );
RxnRule.pm:648:	$rr->Rexclude( [@Rexclude] );
RxnRule.pm:649:	$rr->Pexclude( [@Pexclude] );
RxnRule.pm:650:	$rr->Rinclude( [@Rinclude] );
RxnRule.pm:651:	$rr->Pinclude( [@Pinclude] );
RxnRule.pm:652:	$rr->TotalRate($TotalRate);
RxnRule.pm:653:	$rr->DeleteMolecules($DeleteMolecules);
RxnRule.pm:654:	$rr->MoveConnected($MoveConnected);
RxnRule.pm:655:	$rr->RRefs( {%rrefs} );
RxnRule.pm:656:	$rr->PRefs( {%prefs} );
RxnRule.pm:660:	if ( $err = $rr->findMap($mtlist) ) { return [], $err; }
RxnRule.pm:666:		$rr = RxnRule->new();
RxnRule.pm:667:		if ( $name ne '' ) { $rr->Name("${name}(reverse)"); }
RxnRule.pm:668:		$rr->Reactants( [@prod] );
RxnRule.pm:669:		$rr->Products(  [@reac] );
RxnRule.pm:670:		$rr->Priority($priority);
RxnRule.pm:671:		$rr->RateLaw( $rate_laws[1] );
RxnRule.pm:672:		$rr->Pexclude( [@Rexclude] );
RxnRule.pm:673:		$rr->Rexclude( [@Pexclude] );
RxnRule.pm:674:		$rr->Pinclude( [@Rinclude] );
RxnRule.pm:675:		$rr->Rinclude( [@Pinclude] );
RxnRule.pm:676:		$rr->TotalRate($TotalRate);
RxnRule.pm:677:		$rr->DeleteMolecules($DeleteMolecules);
RxnRule.pm:678:		$rr->MoveConnected($MoveConnected);		
RxnRule.pm:679:		$rr->RRefs( {%prefs} );
RxnRule.pm:680:		$rr->PRefs( {%rrefs} );
RxnRule.pm:683:		if ( $err = $rr->findMap($mtlist) ) { return [], $err; }
RxnRule.pm:704:	foreach my $molAddRef ( @{ $rr->MolAdd } )
RxnRule.pm:709:		my $newMol = $rr->Products->[$p]->Molecules->[$m];
RxnRule.pm:710:		$out .= "  # Add Species " . $newMol->toString() . "\n";
RxnRule.pm:714:	foreach my $sc ( @{ $rr->CompStateChange } )
RxnRule.pm:721:		$out .= "  # StateChange($p,$sR->$sP)\n";
RxnRule.pm:731:    #  cytosis =-1  if exocytosis  (no flip)
RxnRule.pm:733:	foreach my $compartment_change ( @{ $rr->ChangeCompartment } )
RxnRule.pm:736:		( $compartR, $compartP ) = ( $compartR->Name, $compartP->Name );
RxnRule.pm:741:	foreach my $ea ( @{ $rr->EdgeAdd } )
RxnRule.pm:748:	foreach my $ed ( @{ $rr->EdgeDel } )
RxnRule.pm:755:	foreach my $molRef ( @{ $rr->MolDel } )
RxnRule.pm:760:			  . $rr->Reactants->[$p]->Molecules->[$m]->toString() . "\n";
RxnRule.pm:764:			  "  # Delete Pattern " . $rr->Reactants->[$p]->toString() . "\n";
RxnRule.pm:785:	# Name is an index unless it contains non-digit character
RxnRule.pm:786:	if ( defined $rr->Name  and  $rr->Name ne '' )
RxnRule.pm:788:        $string .= $rr->Name . ":  ";
RxnRule.pm:792:    if ( @{$rr->Reactants} )
RxnRule.pm:795:	    foreach my $g ( @{$rr->Reactants} )
RxnRule.pm:798:		    $string .= $g->toString();
RxnRule.pm:807:	$string .= ($rr_rev) ? " <-> " : " -> ";
RxnRule.pm:809:    if ( @{$rr->Products} )
RxnRule.pm:812:	    foreach my $g ( @{$rr->Products} )
RxnRule.pm:815:		    $string .= $g->toString();
RxnRule.pm:825:	$string .= "  " . $rr->RateLaw->toString();
RxnRule.pm:828:		$string .= ", " . $rr_rev->RateLaw->toString();
RxnRule.pm:831:	if ( $rr->Priority != 0 )
RxnRule.pm:833:		$string .= sprintf " priority=%d", $rr->Priority;
RxnRule.pm:836:	foreach my $i ( 0 .. $#{$rr->Rexclude} )
RxnRule.pm:838:		next unless ( @{ $rr->Rexclude->[$i] } );
RxnRule.pm:841:		foreach my $g ( @{ $rr->Rexclude->[$i] } )
RxnRule.pm:843:			$string .= ',' . $g->toString();
RxnRule.pm:848:	foreach my $i ( 0 .. $#{$rr->Pexclude} )
RxnRule.pm:850:		next unless ( @{ $rr->Pexclude->[$i] } );
RxnRule.pm:853:		foreach my $g ( @{ $rr->Pexclude->[$i] } )
RxnRule.pm:855:			$string .= ',' . $g->toString();
RxnRule.pm:860:	foreach my $i ( 0 .. $#{$rr->Rinclude} )
RxnRule.pm:862:		next unless ( @{ $rr->Rinclude->[$i] } );
RxnRule.pm:865:		foreach my $g ( @{ $rr->Rinclude->[$i] } )
RxnRule.pm:867:			$string .= ',' . $g->toString();
RxnRule.pm:872:	foreach my $i ( 0 .. $#{$rr->Pinclude} )
RxnRule.pm:874:		next unless ( @{ $rr->Pinclude->[$i] } );
RxnRule.pm:877:		foreach my $g ( @{ $rr->Pinclude->[$i] } )
RxnRule.pm:879:			$string .= ',' . $g->toString();
RxnRule.pm:885:	$string .= " TotalRate" if ( $rr->TotalRate );
RxnRule.pm:886:    $string .= " DeleteMolecules" if ( $rr->DeleteMolecules );
RxnRule.pm:887:    $string .= " MoveConnected"	if ( $rr->MoveConnected );
RxnRule.pm:928:	# --Molecule Deletion
RxnRule.pm:931:	for my $molRef ( @{ $rr->MolDel } ) {
RxnRule.pm:936:			my $delMol = $rr->Reactants->[$p]->Molecules->[$m]->toStringSSC();
RxnRule.pm:942:			my $delMol = $rr->Reactants->[$p]->toStringSSC();
RxnRule.pm:947:		    # the first one in the pattern. --Justin
RxnRule.pm:967:		    	++$mol_index;   # TODO: missing increment here, is this correct now?  --Justin, 15dec2010
RxnRule.pm:980:	# --Species Creation
RxnRule.pm:981:	for my $molAddRef ( @{ $rr->MolAdd } ) {
RxnRule.pm:986:		my $newMol = $rr->Products->[$p]->Molecules->[$m];
RxnRule.pm:987:		my $addMol = $newMol->toString();
RxnRule.pm:993:	for my $ea ( @{ $rr->EdgeAdd } ) {
RxnRule.pm:995:		my $pstring1 = $rr->MapR->{$p1};    #Mapping back to reactants
RxnRule.pm:996:		my $pstring2 = $rr->MapR->{$p2};
RxnRule.pm:1002:		my $newComp1 = $rr->Reactants->[$pat1]->Molecules->[$mol1]->Components->[$comp1];
RxnRule.pm:1003:		my $newComp2 = $rr->Reactants->[$pat2]->Molecules->[$mol2]->Components->[$comp2];
RxnRule.pm:1006:		( $tempstring, my $checkComp1 ) = $rr->Reactants->[$pat1]->Molecules->[$mol1]->toStringSSC();
RxnRule.pm:1007:		( $tempstring, my $checkComp2 ) = $rr->Reactants->[$pat2]->Molecules->[$mol2]->toStringSSC();
RxnRule.pm:1057:		if ( defined $newComp1->State ) {
RxnRule.pm:1058:			$pstring .= " " . "Mol" . $label1 . "\." . $newComp1->Name . "Binds";
RxnRule.pm:1060:		else { $pstring .= " " . "Mol" . $label1 . "\." . $newComp1->Name; }
RxnRule.pm:1063:		if ( defined $newComp2->State ) {
RxnRule.pm:1064:			$pstring .= "Mol" . $label2 . "\." . $newComp2->Name . "Binds";
RxnRule.pm:1067:			$pstring .= "Mol" . $label2 . "\." . $newComp2->Name;
RxnRule.pm:1069:		my $compName1 = $newComp1->Name;
RxnRule.pm:1070:		my $compName2 = $newComp2->Name;
RxnRule.pm:1075:			( my %compHash ) = $rr->Reactants->[$pat1]->Molecules->[$mol1]->getCompHash();
RxnRule.pm:1084:							if ( defined $newComp1->State ) {
RxnRule.pm:1085:								$tempPString .= " " . "Mol" . $label1 . "\." . $newComp1->Name . $addLabel . "Binds";
RxnRule.pm:1088:								$tempPString .= " " . "Mol" . $label1 . "\." . $newComp1->Name . $addLabel;
RxnRule.pm:1101:			if ( defined $newComp1->State ) {
RxnRule.pm:1102:				$sameProd1 .= " " . "Mol" . $label1 . "\." . $newComp1->Name . "Binds";
RxnRule.pm:1105:				$sameProd1 .= " " . "Mol" . $label1 . "\." . $newComp1->Name;
RxnRule.pm:1111:			if ( defined $newComp2->State ) {
RxnRule.pm:1112:				$sameProd2 .= " " . "Mol" . $label2 . "\." . $newComp2->Name . "Binds";
RxnRule.pm:1115:				$sameProd2 .= " " . "Mol" . $label2 . "\." . $newComp2->Name;
RxnRule.pm:1121:			( my %compHash ) = $rr->Reactants->[$pat2]->Molecules->[$mol2]->getCompHash();
RxnRule.pm:1131:							if ( defined $newComp2->State ) {
RxnRule.pm:1132:								$tempPString .="Mol" . $label2 . "\.". $newComp2->Name . $addLabel . "Binds";
RxnRule.pm:1135:								$tempPString .= "Mol" . $label2 . "\.". $newComp2->Name. $addLabel;
RxnRule.pm:1168:	# --Dissociation
RxnRule.pm:1169:	for my $ed ( @{ $rr->EdgeDel } ) {
RxnRule.pm:1175:		my $newComp1 = $rr->Reactants->[$pat1]->Molecules->[$mol1]->Components->[$comp1];
RxnRule.pm:1176:		my $newComp2 = $rr->Reactants->[$pat2]->Molecules->[$mol2]->Components->[$comp2];
RxnRule.pm:1179:		( my $name, my $bond ) = split /#/, $newComp1->toStringSSC();
RxnRule.pm:1188:	my $stateLabel = -1;
RxnRule.pm:1189:	# --State changes
RxnRule.pm:1190:	for my $sc ( @{ $rr->CompStateChange } ) {
RxnRule.pm:1206:			( my $tempstring, $checkComp1 ) =$rr->Reactants->[$pat1]->Molecules->[$mol1]->toStringSSC();
RxnRule.pm:1219:			( my $tempstring, $checkComp2 ) =$rr->Reactants->[$pat1]->Molecules->[$mol1]->toStringSSC();
RxnRule.pm:1222:		my $newComp = $rr->Reactants->[$pat1]->Molecules->[$mol1]->Components->[$comp1]->toStringSSC();
RxnRule.pm:1233:			( my %compHash ) = $rr->Reactants->[$pat1]->Molecules->[$mol1]->getCompHash();
RxnRule.pm:1253:			( my %compHash ) = $rr->Reactants->[$pat1]->Molecules->[$mol1]->getCompHash();
RxnRule.pm:1276:		while ( defined( $rr->Reactants->[0]->Molecules->[$count] ) ) {
RxnRule.pm:1284:			( my $temprstring, my $checkComp1 ) = $rr->Reactants->[0]->Molecules->[$count]->toStringSSC();
RxnRule.pm:1289:				( my %compHash ) = $rr->Reactants->[0]->Molecules->[$count]->getCompHash();
RxnRule.pm:1297:							for my $compObject (@{$rr->Reactants->[0]->Molecules->[$count]->Components}){
RxnRule.pm:1298:								my $tempName = $compObject->Name;
RxnRule.pm:1300:									for my $edge ( @{ $compObject->Edges } ) {
RxnRule.pm:1327:							for my $compObject (@{$rr->Reactants->[0]->Molecules->[$count]->Components}){
RxnRule.pm:1328:								my $tempName = $compObject->Name;
RxnRule.pm:1330:									for my $edge ( @{ $compObject->Edges } ) {
RxnRule.pm:1362:		while ( defined( $rr->Reactants->[0]->Molecules->[$count] ) ) {
RxnRule.pm:1370:			( my $temprstring, my $checkComp1 ) = $rr->Reactants->[0]->Molecules->[$count]->toStringSSC();
RxnRule.pm:1376:				( my %compHash ) = $rr->Reactants->[0]->Molecules->[$count]->getCompHash();
RxnRule.pm:1384:							for my $compObject (@{$rr->Reactants->[0]->Molecules->[$count]->Components}){
RxnRule.pm:1385:								my $tempName = $compObject->Name;
RxnRule.pm:1387:									for my $edge ( @{ $compObject->Edges } ) {
RxnRule.pm:1412:							for my $compObject (@{$rr->Reactants->[0]->Molecules->[$count]->Components}){
RxnRule.pm:1413:								my $tempName = $compObject->Name;
RxnRule.pm:1415:									for my $edge ( @{ $compObject->Edges } ) {
RxnRule.pm:1451:			while ( defined( $rr->Reactants->[1]->Molecules->[$count] ) ) {
RxnRule.pm:1457:				( my $temprstring, my $checkComp2 ) = $rr->Reactants->[1]->Molecules->[$count]->toStringSSC();
RxnRule.pm:1463:					( my %compHash ) = $rr->Reactants->[1]->Molecules->[$count]->getCompHash();
RxnRule.pm:1471:								for my $compObject (@{$rr->Reactants->[1]->Molecules->[$count]->Components}){
RxnRule.pm:1472:									my $tempName = $compObject->Name;
RxnRule.pm:1474:										for my $edge ( @{ $compObject->Edges } )
RxnRule.pm:1500:								for my $compObject (@{$rr->Reactants->[1]->Molecules->[$count]->Components}){
RxnRule.pm:1501:									my $tempName = $compObject->Name;
RxnRule.pm:1503:										for my $edge ( @{ $compObject->Edges } )
RxnRule.pm:1534:	for my $g ( @{ $rr->Reactants } ) {
RxnRule.pm:1537:		( my $num, my $array ) = $g->findConnected();
RxnRule.pm:1545:		for my $mol ( @{ $g->Molecules } ) {
RxnRule.pm:1546:			for my $comp ( @{ $mol->Components } ) {
RxnRule.pm:1547:				for my $edge ( @{ $comp->Edges } ) {
RxnRule.pm:1604:	$finalString .= " at " . $rr->RateLaw->toString();
RxnRule.pm:1605:	$finalString .= " -> ";
RxnRule.pm:1612:	if ( $rr->Priority != 0 ) {
RxnRule.pm:1617:	for my $i ( 0 .. $#{ $rr->Rexclude } ) {
RxnRule.pm:1618:		next unless ( @{ $rr->Rexclude->[$i] } );
RxnRule.pm:1623:	for my $i ( 0 .. $#{ $rr->Pexclude } ) {
RxnRule.pm:1624:		next unless ( @{ $rr->Pexclude->[$i] } );
RxnRule.pm:1629:	for my $i ( 0 .. $#{ $rr->Rinclude } ) {
RxnRule.pm:1630:		next unless ( @{ $rr->Rinclude->[$i] } );
RxnRule.pm:1635:	for my $i ( 0 .. $#{ $rr->Pinclude } ) {
RxnRule.pm:1636:		next unless ( @{ $rr->Pinclude->[$i] } );
RxnRule.pm:1648:			$finalString .= " at " . $rr->RateLaw->toString();
RxnRule.pm:1649:			$finalString .= "->";
RxnRule.pm:1661:			$finalString .= " at " . $rr->RateLaw->toString();
RxnRule.pm:1662:			$finalString .= "->";
RxnRule.pm:1686:			$finalString .= " at " . $rr->RateLaw->toString() . "->" . $pstring;
RxnRule.pm:1708:			$finalString .= " at " . $rr->RateLaw->toString() . "->" . $pstring;
RxnRule.pm:1738:	if ( $rr->Name ) {
RxnRule.pm:1739:		$string .= " name=\"" . $rr->Name . "\"";
RxnRule.pm:1743:	if ( $rr->Priority != 0 ) {
RxnRule.pm:1744:		$string .= " priority=\"" . $rr->Priority . "\"";
RxnRule.pm:1748:	if ( defined $rr->MultScale ) {
RxnRule.pm:1749:		$string .= " symmetry_factor=\"" . $rr->MultScale . "\"";
RxnRule.pm:1762:	    foreach my $patt ( @{ $rr->Reactants } )
RxnRule.pm:1765:		    $ostring .= $patt->toXML( $indent3, "ReactantPattern", $pid, "" );
RxnRule.pm:1775:	    foreach my $patt ( @{ $rr->Products } )
RxnRule.pm:1778:		    $ostring .= $patt->toXML( $indent3, "ProductPattern", $pid, "" );
RxnRule.pm:1785:	# --justin 29may2008
RxnRule.pm:1787:	foreach my $iReac ( 1 .. @{ $rr->Rexclude } )
RxnRule.pm:1789:		if ( @{ $rr->Rexclude->[ $iReac - 1 ] } )
RxnRule.pm:1794:			foreach my $patt ( @{ $rr->Rexclude->[ $iReac - 1 ] } ) {
RxnRule.pm:1796:				$ostring .= $patt->toXML( $indent3, 'Pattern', $patt_id, "" );
RxnRule.pm:1804:	foreach my $iReac ( 1 .. @{ $rr->Rinclude } )
RxnRule.pm:1806:		if ( @{ $rr->Rinclude->[ $iReac - 1 ] } )
RxnRule.pm:1811:			foreach my $patt ( @{ $rr->Rinclude->[ $iReac - 1 ] } ) {
RxnRule.pm:1813:				$ostring .= $patt->toXML( $indent3, 'Pattern', $patt_id, "" );
RxnRule.pm:1821:	foreach my $iProd ( 1 .. @{ $rr->Pexclude } )
RxnRule.pm:1823:		if ( @{ $rr->Pexclude->[ $iProd - 1 ] } )
RxnRule.pm:1828:			foreach my $patt ( @{ $rr->Pexclude->[ $iProd - 1 ] } ) {
RxnRule.pm:1830:				$ostring .= $patt->toXML( $indent3, 'Pattern', $patt_id, "" );
RxnRule.pm:1838:	foreach my $iProd ( 1 .. @{ $rr->Pinclude } )
RxnRule.pm:1840:		if ( @{ $rr->Pinclude->[ $iProd - 1 ] } )
RxnRule.pm:1845:			foreach my $patt ( @{ $rr->Pinclude->[ $iProd - 1 ] } ) {
RxnRule.pm:1847:				$ostring .= $patt->toXML( $indent3, 'Pattern', $patt_id, "" );
RxnRule.pm:1855:	$ostring .= $rr->RateLaw->toXML( $indent2, $id, $plist, $rr->RRefs );
RxnRule.pm:1862:	    foreach my $source ( sort keys %{ $rr->MapF } )
RxnRule.pm:1865:		    my $target = $rr->MapF->{$source};
RxnRule.pm:1887:	    foreach my $s ( keys %{ $rr->MapF } )
RxnRule.pm:1889:		    my $t = $rr->MapF->{$s};
RxnRule.pm:1894:	# Re-ordered operations to match the order of application!
RxnRule.pm:1895:	# --Justin, 29may2009
RxnRule.pm:1898:	foreach my $sc ( @{ $rr->CompStateChange } )
RxnRule.pm:1920:    #  flipOrientation =-1  if species surface transport to an adjacent branch in the compartment tree.
RxnRule.pm:1924:    #  moveConnected = 1    if molecule transport and the "compartment connected component" should be co-transported.
RxnRule.pm:1926:	foreach my $compartment_change ( @{ $rr->ChangeCompartment } )
RxnRule.pm:1929:		( $compartR, $compartP ) = ( $compartR->Name, $compartP->Name );
RxnRule.pm:1935:		$ostring .= ' moveConnected="' . $rr->MoveConnected . '"';
RxnRule.pm:1941:	foreach my $ed ( @{ $rr->EdgeDel } )
RxnRule.pm:1951:	foreach my $molAddRef ( @{ $rr->MolAdd } )
RxnRule.pm:1955:		  " id=\"" . pointer_to_ID( $id . "_P", $molAddRef->[0] ) . "\"";
RxnRule.pm:1960:	foreach my $ea ( @{ $rr->EdgeAdd } )
RxnRule.pm:1981:	foreach my $molRef ( @{ $rr->MolDel } )
RxnRule.pm:1983:		my $delMolFlag = $rr->DeleteMolecules;
RxnRule.pm:2014:# $err = $rr->findMap( $mtlist );
RxnRule.pm:2020:	my $mtlist = shift @_;    # molecule-types list
RxnRule.pm:2023:    @{$rr->MolDel}  = ();
RxnRule.pm:2024:	@{$rr->MolAdd}  = ();    
RxnRule.pm:2025:	@{$rr->EdgeDel} = ();
RxnRule.pm:2026:    @{$rr->EdgeAdd} = ();
RxnRule.pm:2027:	@{$rr->CompStateChange}   = ();
RxnRule.pm:2028:    @{$rr->ChangeCompartment} = ();	   
RxnRule.pm:2032:	my ($rg) = SpeciesGraph::copymerge( @{$rr->Reactants} );
RxnRule.pm:2033:	my ($pg) = SpeciesGraph::copymerge( @{$rr->Products}  );
RxnRule.pm:2038:	foreach my $ipatt ( 0 .. $#{$rr->Reactants} )
RxnRule.pm:2040:		foreach my $imol ( 0 .. $#{$rr->Reactants->[$ipatt]->Molecules} )
RxnRule.pm:2047:	foreach my $ipatt ( 0 .. $#{$rr->Products} )
RxnRule.pm:2049:		foreach my $imol ( 0 .. $#{$rr->Products->[$ipatt]->Molecules} )
RxnRule.pm:2057:	my $map = $rg->findMaps($pg);
RxnRule.pm:2063:	my @pused = (0) x @{$pg->Molecules};
RxnRule.pm:2065:	foreach my $p_r ( 0 .. $#{$rr->Reactants} )
RxnRule.pm:2067:	    my $molecules = $rr->Reactants->[$p_r]->Molecules;
RxnRule.pm:2073:			my $i_p = $map->MapF->{$i_r};
RxnRule.pm:2082:		if ( $rr->DeleteMolecules  or  ($#mol_delete < $#{$molecules}) )
RxnRule.pm:2086:			{	push @{$rr->MolDel}, "${p_r}.${m_r}";	}
RxnRule.pm:2091:			push @{$rr->MolDel}, $p_r;
RxnRule.pm:2104:		my $mol = $rr->Products->[$p]->Molecules->[$m];
RxnRule.pm:2109:		foreach my $comp ( @{$mol->Components} )
RxnRule.pm:2111:			if ( ( my $cref = $map->MapR->{"$imP.$ic"} ) ne "-1" )
RxnRule.pm:2125:		if ( my $err = $mtlist->checkMolecule($mol, { IsSpecies => 1, InheritList => \@ilist }) )
RxnRule.pm:2128:		push @{$rr->MolAdd}, [ ($ref, @ilist) ];
RxnRule.pm:2133:	my @eused = (0) x @{$pg->Edges};
RxnRule.pm:2134:	foreach my $edgeR ( @{$rg->Edges} )
RxnRule.pm:2139:		my $p1P = $map->MapF->{$p1R};
RxnRule.pm:2140:		my $p2P = $map->MapF->{$p2R};
RxnRule.pm:2143:		if ( ref $pg->Adjacency->{$p1P} eq 'HASH'  and  exists $pg->Adjacency->{$p1P}{$p2P} )
RxnRule.pm:2145:			$eused[ $pg->Adjacency->{$p1P}{$p2P} ] = 1;
RxnRule.pm:2155:		#  if so, the egde is removed as a side-effect and we don't need to
RxnRule.pm:2157:		next if ( grep {$_ eq $aggMapR[$im1]} @{$rr->MolDel}  or  grep {$_ eq $aggMapR[$im2]} @{$rr->MolDel} );
RxnRule.pm:2161:		next if ( grep {$_ eq $ip1 } @{$rr->MolDel} );	        
RxnRule.pm:2164:		push @{$rr->EdgeDel}, [ $aggMapR[$im1] . ".$ic1", $aggMapR[$im2] . ".$ic2" ];
RxnRule.pm:2172:	foreach my $iedgeP ( 0 .. $#{$pg->Edges} )
RxnRule.pm:2175:		my @ps = split / /, $pg->Edges->[$iedgeP];
RxnRule.pm:2184:		push @{$rr->EdgeAdd}, [ $p1P, $p2P ];
RxnRule.pm:2189:    foreach my $imP ( 0 .. @{$pg->Molecules}-1 )
RxnRule.pm:2191:        my $mol = $pg->Molecules->[$imP];
RxnRule.pm:2192:        foreach my $icP ( 0 .. @{$mol->Components}-1 )
RxnRule.pm:2194:            my $comp = $mol->Components->[$icP];
RxnRule.pm:2195:            next unless (@{$comp->Edges});
RxnRule.pm:2197:            my ($imR, $icR) = split /\./, $map->MapR("$imP.$icP");
RxnRule.pm:2200:            next if ( $imR == -1 );
RxnRule.pm:2204:            my $edge = $comp->Edges->[0];
RxnRule.pm:2207:                unless ( grep {$_ eq "+"} @{$rg->Molecules->[$imR]->Components->[$icR]->Edges} )
RxnRule.pm:2209:                    my $err = sprintf("In reaction rule: product component %s has a bond wildcard, ", $comp->toString() )
RxnRule.pm:2216:                unless ( grep {$_ eq "?"} @{$rg->Molecules->[$imR]->Components->[$icR]->Edges} )
RxnRule.pm:2218:                    my $err = sprintf("In reaction rule: product component %s has a bond wildcard, ", $comp->toString() )
RxnRule.pm:2228:	foreach my $imR ( 0 .. $#{$rg->Molecules} )
RxnRule.pm:2230:		my $imP = $map->MapF->{$imR};
RxnRule.pm:2234:		my $componentsR = $rg->Molecules->[$imR]->Components;
RxnRule.pm:2235:		my $componentsP = $pg->Molecules->[$imP]->Components;
RxnRule.pm:2241:			my ( $imP, $icP ) = split /\./, $map->MapF->{"$imR.$icR"};
RxnRule.pm:2244:            my $stateR = $componentsR->[$icR]->State;
RxnRule.pm:2245:			my $stateP = $componentsP->[$icP]->State;
RxnRule.pm:2252:					        $rr->toString()
RxnRule.pm:2262:				push @{$rr->CompStateChange}, [ ($pR, $stateR, $stateP) ];
RxnRule.pm:2272:    #      syntax:  @C1:SpeciesX -> @C2:SpeciesX
RxnRule.pm:2282:    #       a new compartment based on topological inference (endo/exo-cytosis)
RxnRule.pm:2284:    #      At this time we can check for illegal movement between 2-D and 3-D compartments.
RxnRule.pm:2289:    #      cytosis =  1  surface-to-surface endocytic species transport (invert Outside/Inside)
RxnRule.pm:2290:    #                -1  surface-to-surface exocytic species transport  (preserve Outside/Inside)
RxnRule.pm:2291:    #                 0  otherwise (volume-to-volume species transport and all molecule transport).    
RxnRule.pm:2294:    #      syntax:  MoleculeX()@C1 -> MoleculeX()@C2
RxnRule.pm:2309:    #   mapPattR:  {0,1,..,|ReactantPatterns|}  ->  {-2,-1,0,1,..,|ProductPatterns|}
RxnRule.pm:2313:    #   mapPattR(I) = -1       if ReactantPattern[i] is deleted by the reaction rule.
RxnRule.pm:2314:    #   mapPattR(I) = -2       otherwise.
RxnRule.pm:2317:    #  (i)   build the forward map R->P and store at @mapPattR
RxnRule.pm:2318:    #  (ii)  build the reverse map P->R and store at @mapPattP
RxnRule.pm:2324:	foreach my $im1 ( 0 .. $#{$rg->Molecules} )
RxnRule.pm:2326:		my $im2 = $map->MapF->{$im1};
RxnRule.pm:2329:		$mapf_new->{$pm1} = $pm2;
RxnRule.pm:2331:		#print "map_new: $pm1 -> $pm2\n";
RxnRule.pm:2332:		my $components = $rg->Molecules->[$im1]->Components;
RxnRule.pm:2335:			my ( $im2, $ic2 ) = split /\./, $map->MapF->{"$im1.$ic1"};
RxnRule.pm:2338:				$mapf_new->{"$pm1.$ic1"} = "$pm2.$ic2";
RxnRule.pm:2339:				#print "map_new: $pm1.$ic1 -> $pm2.$ic2\n";
RxnRule.pm:2343:				$mapf_new->{"$pm1.$ic1"} = $im2;
RxnRule.pm:2344:				#print "map_new: $pm1.$ic1 -> $pm2.$ic2\n";
RxnRule.pm:2352:	foreach my $im1 ( 0 .. $#{$pg->Molecules} )
RxnRule.pm:2354:		my $im2 = $map->MapR->{$im1};
RxnRule.pm:2357:		$mapr_new->{$pm1} = $pm2;
RxnRule.pm:2359:		#print "map_new: $pm1 -> $pm2\n";
RxnRule.pm:2360:		my $components = $pg->Molecules->[$im1]->Components;
RxnRule.pm:2363:			my ( $im2, $ic2 ) = split /\./, $map->MapR->{"$im1.$ic1"};
RxnRule.pm:2366:				$mapr_new->{"$pm1.$ic1"} = "$pm2.$ic2";
RxnRule.pm:2367:				#print "map_new: $pm1.$ic1 -> $pm2.$ic2\n";
RxnRule.pm:2371:				$mapr_new->{"$pm1.$ic1"} = $im2;
RxnRule.pm:2372:				#print "map_new: $pm1.$ic1 -> $pm2.$ic2\n";
RxnRule.pm:2379:		my @mapPattR = (); # map from reactant patterns to product patterns (-1 if deleted, -2 if no consistent map)
RxnRule.pm:2380:		my @mapPattP = (); # map from product patterns to reactant patterns (-1 if added, -2 if no consistent map)
RxnRule.pm:2385:		for ( my $i_pattR = 0;  $i_pattR < @{$rr->Reactants};  $i_pattR++ )
RxnRule.pm:2387:		    foreach my $molR ( @{$rr->Reactants->[$i_pattR]->Molecules} )
RxnRule.pm:2389:				my $i_pattP_molP = $mapf_new->{ $aggMapR[ $i_R++ ] };
RxnRule.pm:2395:					# if inconsistent, set mapPattR = -2
RxnRule.pm:2397:					{   $mapPattR[$i_pattR] = -2;   }
RxnRule.pm:2400:				{   # assign pattern mapping ( i_pattP, or -1 if deletion )
RxnRule.pm:2409:		for ( my $i_pattP = 0;  $i_pattP < @{$rr->Products};  $i_pattP++ )
RxnRule.pm:2411:		    foreach my $molP ( @{$rr->Products->[$i_pattP]->Molecules} )
RxnRule.pm:2413:				my $i_pattR_molR = $mapr_new->{ $aggMapP[ $i_P++ ] };
RxnRule.pm:2419:					# if inconsistent, set mapPattR = -2
RxnRule.pm:2421:					{   $mapPattP[$i_pattP] = -2;   }
RxnRule.pm:2424:				{   # assign pattern mapping ( i_pattP, or -1 if deletion )
RxnRule.pm:2432:        #  Pattern mapping is okay if:  $mapPattP[ $mapPattR[i] ] = i  OR  $mapPattR[i] == -1.
RxnRule.pm:2433:		for ( my $i_pattR = 0;  $i_pattR < @{$rr->Reactants};  $i_pattR++ )
RxnRule.pm:2438:			    # NOTE: the assignment was orginally an equality, is this right now?? --justin
RxnRule.pm:2439:				$mapPattR[$i_pattR] = -2;
RxnRule.pm:2444:        #  Pattern mapping is okay if:  $mapPattR[ $mapPattP[i] ] = i  OR  $mapPattP[i] == -1.
RxnRule.pm:2445:		for ( my $i_pattP = 0;  $i_pattP < @{$rr->Products};  $i_pattP++ )
RxnRule.pm:2450:				$mapPattP[$i_pattP] = -2;
RxnRule.pm:2459:		for ( my $i_pattR = 0; $i_pattR < @{$rr->Reactants}; $i_pattR++ )
RxnRule.pm:2462:			if ( $mapPattR[$i_pattR] == -1 ) {  next;  }
RxnRule.pm:2466:			elsif ( $mapPattR[$i_pattR] == -2 )
RxnRule.pm:2468:                # Removed by Justin -- we're being permissive about species syntax.
RxnRule.pm:2470:                # if ( defined $rr->Reactants->[$i_pattR]->Compartment )
RxnRule.pm:2474:                #     ." molecules are removed or added.", $rr->toString()
RxnRule.pm:2485:			my $compR = $rr->Reactants->[$i_pattR]->Compartment;
RxnRule.pm:2486:			my $compP = $rr->Products->[$i_pattP]->Compartment;
RxnRule.pm:2493:            # Assume that species compoartment is just a post-check on the final product.
RxnRule.pm:2497:            # Removed by Justin -- we're being permissive about species syntax.
RxnRule.pm:2504:            #     ." other side of the reaction.", $rr->toString()
RxnRule.pm:2513:			unless ( $compR->SpatialDimensions == $compP->SpatialDimensions )
RxnRule.pm:2516:					        ." of non-equal SpatialDimensions.",
RxnRule.pm:2517:					        $rr->toString()
RxnRule.pm:2523:			if ( $compR->SpatialDimensions == 3 )
RxnRule.pm:2525:				push @{$rr->ChangeCompartment}, [ $i_pattR, $compR, $compP, 0 ];
RxnRule.pm:2529:			if ( $compR->SpatialDimensions == 2 )
RxnRule.pm:2531:				# only allowed between surfaced connected by volume (this is a mimick of endo/exo-cytosis)
RxnRule.pm:2532:				my $cytosis = $compR->separated_by_volume($compP);
RxnRule.pm:2536:						        $rr->toString()
RxnRule.pm:2539:				push @{$rr->ChangeCompartment}, [ $i_pattR, $compR, $compP, $cytosis ];
RxnRule.pm:2543:        # Removed by Justin -- we're being permissive about species syntax.
RxnRule.pm:2545:        # for ( my $i_pattP = 0; $i_pattP < @{$rr->Products}; $i_pattP++ )
RxnRule.pm:2548:        #   if ( $mapPattP[$i_pattP] == -2 )
RxnRule.pm:2551:        #     if ( defined $rr->Products->[$i_pattP]->Compartment )
RxnRule.pm:2555:        #         ." molecules have been removed or added.", $rr->toString()
RxnRule.pm:2571:	for ( my $i_molR = 0;  $i_molR < @{$rg->Molecules};  $i_molR++ )
RxnRule.pm:2574:		my $molR_comp = $rg->Molecules->[$i_molR]->Compartment;
RxnRule.pm:2578:		my $pattR_comp = $rr->Reactants->[$i_pattR]->Compartment;
RxnRule.pm:2584:			unless ( $pattR_comp->adjacent($molR_comp) )
RxnRule.pm:2587:					        $rr->toString()
RxnRule.pm:2593:		my $i_molP = $map->MapF->{$i_molR};
RxnRule.pm:2599:		my $molP_comp = $pg->Molecules->[$i_molP]->Compartment;
RxnRule.pm:2603:		my $pattP_comp = $rr->Products->[$i_pattP]->Compartment;
RxnRule.pm:2609:			unless ( $pattP_comp->adjacent($molP_comp) )
RxnRule.pm:2612:					        $rr->toString()
RxnRule.pm:2626:        				$rr->toString()
RxnRule.pm:2636:		#if (    $molR_comp->adjacent($molP_comp)
RxnRule.pm:2637:	    #     or $molR_comp->separated_by_surface($molP_comp) )
RxnRule.pm:2639:			push @{$rr->ChangeCompartment},
RxnRule.pm:2646:	    #		        $rr->toString()
RxnRule.pm:2655:    my $err = $rr->find_reaction_center( $mapr_new );
RxnRule.pm:2656:    if ($err) { exit_error( "Some problem finding reaction center: $err", $rr->toString() ); }
RxnRule.pm:2671:	my @r_auto   = $rg->isomorphicToSubgraph($rg);
RxnRule.pm:2673:	my @p_auto   = $pg->isomorphicToSubgraph($pg);
RxnRule.pm:2675:	# Set up product automorphism hash (includes identity - trivial autmorphism)
RxnRule.pm:2678:	{  $p_auto_hash{ $auto->toString() } = 1;  }
RxnRule.pm:2693:	    my ($permP, $err) = $auto->get_induced_permutation( $map );
RxnRule.pm:2694:	    if ( exists $p_auto_hash{ $permP->toString() } )
RxnRule.pm:2709:        while ( my ($src_ptr, $targ_ptr) = each %{$auto->MapF} )
RxnRule.pm:2721:        foreach my $Rpatt (@{$rr->ReactionCenter})
RxnRule.pm:2751:                    next RG_LOOP unless ( $auto->MapF->{$imolAgg_icomp} eq $imolAgg_icomp );
RxnRule.pm:2766:    for (my $iR = 0; $iR < @{$rr->Reactants}; ++$iR )
RxnRule.pm:2768:        if ( @{$rr->ReactionCenter->[$iR]}==0 )
RxnRule.pm:2770:            push @context_rgs, $rr->Reactants->[$iR];
RxnRule.pm:2774:    # count the instances of each unqiue context graph (up-to-isomorphism)
RxnRule.pm:2784:            if ( $crg->isomorphicTo($context_rgs[$iR]) )
RxnRule.pm:2796:	$rr->MultScale($multScale);
RxnRule.pm:2799:    #print $rr->toString(), "\n";
RxnRule.pm:2809:	$rr->MapF( $mapf_new );
RxnRule.pm:2810:	$rr->MapR( $mapr_new );
RxnRule.pm:2812:	# print "=====\n", $rr->toString(), "\n";
RxnRule.pm:2813:	# foreach my $key ( keys %{$rr->MapF} )
RxnRule.pm:2815:	#    print $key, " -> ", $rr->MapF->{$key}, "\n";
RxnRule.pm:2817:	# print "-----\n";
RxnRule.pm:2818:	# foreach my $key ( keys %{$rr->MapR} )
RxnRule.pm:2820:	#    print $key, " -> ", $rr->MapR->{$key}, "\n";
RxnRule.pm:2824:    unless ( @{$rr->MolDel} or @{$rr->MolAdd} or @{$rr->EdgeDel} or @{$rr->EdgeAdd}
RxnRule.pm:2825:                             or @{$rr->CompStateChange} or @{$rr->ChangeCompartment} )
RxnRule.pm:2828:                               $rr->toString));        
RxnRule.pm:2837:# void = $rr->initializeRule()
RxnRule.pm:2844:    %{$rr->RxnLabels} = ();
RxnRule.pm:2848:    foreach my $rpatt ( @{$rr->Reactants} )
RxnRule.pm:2851:        $rr->Rmatches->[$ipatt] = [];
RxnRule.pm:2857:    $cartprod_reactants->initialize( $rr->Rmatches );
RxnRule.pm:2858:    $rr->RuleInstances( $cartprod_reactants );
RxnRule.pm:2865:##----------------##
RxnRule.pm:2867:##----------------##
RxnRule.pm:2888:	    {   $params->{$opt} = $val;   }
RxnRule.pm:2898:			unless ( $s->RulesApplied )
RxnRule.pm:2899:			{    push @$new_species, $s->SpeciesGraph;   }
RxnRule.pm:2904:        while ( $rr->RuleInstances->getNext($rule_instance) )
RxnRule.pm:2907:            my $rxn = $rr->build_reaction( $rule_instance, $model, $params );
RxnRule.pm:2909:            {   $n_new_rxns += $model->RxnList->add( $rxn, 0, $model->ParamList );   }
RxnRule.pm:2914:	    for (my $ipatt = @{$rr->Reactants}-1; $ipatt >= 0; --$ipatt )
RxnRule.pm:2917:	        my $new_matches = $rr->find_embeddings( $ipatt, $new_species, $model );
RxnRule.pm:2920:            $rr->RuleInstances->update( $ipatt, $new_matches );
RxnRule.pm:2922:		    if ( $params->{verbose} )
RxnRule.pm:2924:		        my $n_new_matches = @{$rr->Rmatches->[$ipatt]};
RxnRule.pm:2925:		        printf $params->{indent} . "  ..found %d new match%s to reactant pattern %d\n",
RxnRule.pm:2931:            while ( $rr->RuleInstances->getNext($rule_instance) )
RxnRule.pm:2934:                my $rxn = $rr->build_reaction( $rule_instance, $model, $params );
RxnRule.pm:2936:                {   $n_new_rxns += $model->RxnList->add( $rxn, 0, $model->ParamList );   }
RxnRule.pm:2966:        if (@{$rr->Rinclude->[$ipatt]})
RxnRule.pm:2969:            foreach my $patt_incl ( @{$rr->Rinclude->[$ipatt]} )
RxnRule.pm:2971:                if ( $patt_incl->isomorphicToSubgraph($sg) )
RxnRule.pm:2981:	    foreach my $patt_excl ( @{$rr->Rexclude->[$ipatt]} )
RxnRule.pm:2982:	    {   next SGLOOP if ( $patt_excl->isomorphicToSubgraph($sg) );   }
RxnRule.pm:2985:        my @new_matches = $rr->Reactants->[$ipatt]->isomorphicToSubgraph($sg);
RxnRule.pm:2998:        my $err = $rr->filter_identical_by_rxn_center( \@new_matches, $ipatt );
RxnRule.pm:2999:        if ($err) {  exit_error( "Some error comparing matches by reaction center: $err.", $rr->toString );  }
RxnRule.pm:3021:    my $verbose = $params->{verbose};
RxnRule.pm:3024:    my $targets = [ map {$_->Target} @$matches ];
RxnRule.pm:3029:    my $reactant_species = [ map {$_->Target->Species} @$matches ];
RxnRule.pm:3032:	my $using_compartments = $model->CompartmentList->Used();
RxnRule.pm:3037:	{   $compartments = [ map {$_->Compartment} @$targets ];   }
RxnRule.pm:3042:    ($products) = $rr->apply_operations( $matches );
RxnRule.pm:3048:    my $nprod_patterns = scalar @{$rr->Products};
RxnRule.pm:3052:        if ( $rr->DeleteMolecules  and  @$products > $nprod_patterns )
RxnRule.pm:3055:            {   printf "Deleting molecules in rule %s\n", $rr->Name();  }
RxnRule.pm:3061:	        {   printf "Rule %s: n_sub (%d)!= n_prod (%d)\n", $rr->Name, @$products, $nprod_patterns;   }
RxnRule.pm:3072:	    my $p = $products->[$ip];
RxnRule.pm:3073:	    my $iprod = ($ip >= @{$rr->Products}) ? -1 : $ip;
RxnRule.pm:3079:        return undef unless ( $p->isConnected() );
RxnRule.pm:3082:		return undef if ( @{$p->Molecules} > $params->{max_agg} );
RxnRule.pm:3085:		while ( my ($mol, $max) = each %{$params->{max_stoich}} )
RxnRule.pm:3088:			return undef if ( $p->stoich($mol) > $max );
RxnRule.pm:3102:		    my ($infer_comp, $err) = $p->inferSpeciesCompartment();
RxnRule.pm:3111:			            . ">>", $rr->toString(), "\n";
RxnRule.pm:3118:				    if ( $comp->SpatialDimensions == 2 )
RxnRule.pm:3127:				        if ( $comp->SpatialDimensions == 3 )
RxnRule.pm:3135:		            . "RxnRule>", $rr->toString(), "\n";
RxnRule.pm:3141:		    $err = $p->assignCompartment($infer_comp);
RxnRule.pm:3145:			        . "RxnRule>", $rr->toString(), "\n";
RxnRule.pm:3150:		    unless ( $p->verifyTopology(1) )
RxnRule.pm:3154:                     ." necessarily a problem, but it's a good idea to double-check your rules. \n"
RxnRule.pm:3155:				     ."RxnRule>", $rr->toString(), "\n"
RxnRule.pm:3156:                     ."Product> ", $p->toString(), "\n";
RxnRule.pm:3161:		    unless ( $iprod == -1 ) 
RxnRule.pm:3163:			    if ( defined $rr->Products->[$iprod]->Compartment )
RxnRule.pm:3164:			    {	return undef unless ( $infer_comp == $rr->Products->[$iprod]->Compartment );   }
RxnRule.pm:3169:        # Put product graph in canonical order (quasi-canonical for the time being)
RxnRule.pm:3170:		if ( my $err = $p->sortLabel() )
RxnRule.pm:3173:			    . "RxnRule>", $rr->toString(), "\n";
RxnRule.pm:3178:		unless ( $iprod == -1 )
RxnRule.pm:3180:			foreach my $patt_excl ( @{$rr->Pexclude->[$iprod]} )
RxnRule.pm:3181:			{	return undef if ( $patt_excl->isomorphicToSubgraph($p) );   }
RxnRule.pm:3184:            if (@{$rr->Pinclude->[$iprod]})
RxnRule.pm:3187:			    foreach my $patt_incl ( @{$rr->Pinclude->[$iprod]} )
RxnRule.pm:3189:				    if ( $patt_incl->isomorphicToSubgraph($p) )
RxnRule.pm:3205:		my $spec = $model->SpeciesList->lookup($p, $params->{check_iso});
RxnRule.pm:3209:			$spec = $model->SpeciesList->add($p, 0);
RxnRule.pm:3213:            foreach my $obs ( @{$model->Observables} )
RxnRule.pm:3214:            {   $obs->update([$spec]);   }
RxnRule.pm:3217:            $spec->ObservablesApplied(1);
RxnRule.pm:3220:            if ( $model->Options->{energyBNG} )
RxnRule.pm:3222:                foreach my $epatt ( @{$model->EnergyPatterns} )
RxnRule.pm:3223:                {   $epatt->updateSpecies([$spec]);   }
RxnRule.pm:3228:	    unless ($iprod == -1)
RxnRule.pm:3230:	        unless ($rr->Products->[$iprod]->Fixed)
RxnRule.pm:3243:	foreach my $rpatt ( @{$rr->Reactants} )
RxnRule.pm:3245:		if ( $rpatt->Fixed )
RxnRule.pm:3246:		{   push @$product_species, $reactant_species->[$ri];   }
RxnRule.pm:3253:    while ( my ($ref,$ptr1) = each %{$rr->RRefs} )
RxnRule.pm:3257:        my $ptr2 = $reactant_species->[$patt_idx]->Index;
RxnRule.pm:3260:            my ($mol2_idx) = split( /\./, $matches->[$patt_idx]->mapF($mol_idx) );
RxnRule.pm:3264:                my ($mol2_idx, $comp2_idx) = split( /\./, $matches->[$patt_idx]->mapF("$mol_idx.$comp_idx") );
RxnRule.pm:3268:        $local_refs->{$ref} = $ptr2;
RxnRule.pm:3272:    my $rl = $rr->RateLaw->evaluate_local($local_refs, $model);
RxnRule.pm:3275:	my $rxn = Rxn->new( Reactants=>$reactant_species, Products=>$product_species,
RxnRule.pm:3276:                        RateLaw=>$rl, Priority=>$rr->Priority, RxnRule=>$rr,
RxnRule.pm:3277:                        StatFactor=>$rr->MultScale );
RxnRule.pm:3291:# $err = $rr->find_reaction_center( \%mapr )
RxnRule.pm:3294:# Results are stored at the array "RxnRule->ReactionCenter", which has
RxnRule.pm:3306:# This is subject to change!  --justin
RxnRule.pm:3310:	my ( $rr, $mapr ) = @_;    # get RxnRule and reverse map (product->reactant)
RxnRule.pm:3314:	foreach my $iR ( 0 .. @{$rr->Reactants}-1 )
RxnRule.pm:3315:	{	$rr->ReactionCenter->[$iR] = {};   }
RxnRule.pm:3317:	foreach my $action ( @{$rr->EdgeAdd} )
RxnRule.pm:3323:		$targ1_pointer = $mapr->{$targ1_pointer};
RxnRule.pm:3324:		$targ2_pointer = $mapr->{$targ2_pointer};
RxnRule.pm:3326:		unless ( $targ1_pointer eq -1 ) {
RxnRule.pm:3328:			$rr->ReactionCenter->[$iPatt1]->{$targ1_pointer} = 1;
RxnRule.pm:3331:		unless ( $targ2_pointer eq -1 ) {
RxnRule.pm:3333:			$rr->ReactionCenter->[$iPatt2]->{$targ2_pointer} = 1;
RxnRule.pm:3337:	foreach my $action ( @{ $rr->EdgeDel } )
RxnRule.pm:3342:		$rr->ReactionCenter->[$iPatt1]->{$targ1_pointer} = 1;
RxnRule.pm:3345:		$rr->ReactionCenter->[$iPatt2]->{$targ2_pointer} = 1;
RxnRule.pm:3348:	foreach my $targ_pointer ( @{ $rr->MolDel } )
RxnRule.pm:3351:		$rr->ReactionCenter->[$iPatt]->{$targ_pointer} = 1;
RxnRule.pm:3356:	foreach my $action ( @{ $rr->CompStateChange } )
RxnRule.pm:3361:		$rr->ReactionCenter->[$iPatt]->{$targ_pointer} = 1;
RxnRule.pm:3364:	foreach my $action ( @{ $rr->ChangeCompartment } )
RxnRule.pm:3369:		$rr->ReactionCenter->[$iPatt]->{$targ_pointer} = 1;
RxnRule.pm:3374:	foreach my $iR ( 0 .. @{$rr->ReactionCenter}-1 )
RxnRule.pm:3375:    {   $rr->ReactionCenter->[$iR] = [ keys %{$rr->ReactionCenter->[$iR]} ];  }
RxnRule.pm:3388:# $err = $rr->filter_identical_by_rxn_center( \@matches, $iPatt )
RxnRule.pm:3392:# the rxn center.  --justin
RxnRule.pm:3399:# If match[i]->Target == match[j]->Target
RxnRule.pm:3422:		foreach my $node_pointer ( @{ $rr->ReactionCenter->[$iPatt] } )
RxnRule.pm:3428:				push @$image, "${iPatt}." . $match->MapF->{$iMC};
RxnRule.pm:3438:	# All against all comparison:  N*(N-1) compares, where N=#matches.
RxnRule.pm:3452:				next JMATCH unless ( $template->[$k] eq $image->[$k] );
RxnRule.pm:3460:			$jMatch--;
RxnRule.pm:3476:# ($products, $label) = $rr->apply_operations(\@matches,\@permute)
RxnRule.pm:3493:    my $targets = [ (map {$_->Target} @$matches) ];
RxnRule.pm:3497:    my $mol = $g->Molecules;
RxnRule.pm:3500:    #   mapP: product pattern (p.m.c) -> product species (m.c)        
RxnRule.pm:3505:        my $match = $matches->[$ir];
RxnRule.pm:3508:		for ( my $im = 0;  $im < @{$match->Source->Molecules}; ++$im )
RxnRule.pm:3511:			next unless ( exists $rr->MapF->{"$ir.$im"} );
RxnRule.pm:3514:			my $pP = $rr->MapF->{"$ir.$im"};
RxnRule.pm:3516:			# nothing to do if maps to -1 (i.e. "delete")
RxnRule.pm:3517:			next if ( $pP == -1 );
RxnRule.pm:3520:		    $mapP->{$pP} = $match->mapF( "$im", $offsets->[$ir] );
RxnRule.pm:3523:    	    for ( my $ic = 0;  $ic < @{$match->Source->Molecules->[$im]->Components};  ++$ic )
RxnRule.pm:3526:			    my $pP = $rr->MapF->{"$ir.$im.$ic"};
RxnRule.pm:3528:			    $mapP->{$pP} = $match->mapF( "$im.$ic", $offsets->[$ir] );	
RxnRule.pm:3546:			push @$stack, [ $targ->StringExact, $iR ];
RxnRule.pm:3551:		@$stack = ( sort { $a->[0] cmp $b->[0] } @$stack );
RxnRule.pm:3557:			$canonical_reactant_order->[ $targ->[1] ] = $iR;
RxnRule.pm:3561:			$targ = $targ->[0];
RxnRule.pm:3573:		foreach my $molAddRef ( @{$rr->MolAdd} )
RxnRule.pm:3578:			my $newMol = $rr->Products->[$ip]->Molecules->[$im]->copy($molRef);
RxnRule.pm:3581:			@{$newMol->Edges} = ();
RxnRule.pm:3582:			foreach my $comp ( @{$newMol->Components} )
RxnRule.pm:3584:			    @{$comp->Edges} = ();
RxnRule.pm:3595:				if ( defined $permute ) { $ip = $permute->[$ip]; }
RxnRule.pm:3598:				  $matches->[$ip]->mapF( "$im.$ic", $offsets->[$ip] );
RxnRule.pm:3601:				my $stateNew = $mol->[$im_targ]->Components->[$ic_targ]->State;
RxnRule.pm:3602:				$newMol->Components->[$ic_newMol]->State($stateNew);
RxnRule.pm:3607:			$newMol->Label(undef);
RxnRule.pm:3608:			my $nmol = @{$g->Molecules};
RxnRule.pm:3609:			$mapP->{$molRef} = $nmol;
RxnRule.pm:3611:			foreach my $comp ( @{ $newMol->Components } )
RxnRule.pm:3613:				$comp->Label(undef);
RxnRule.pm:3614:				$mapP->{"$molRef.$ic_newMol"} = "$nmol.$ic_newMol";
RxnRule.pm:3618:			push @{$g->Molecules}, $newMol;
RxnRule.pm:3620:			# printf "prod: %s\n", $g->toString();
RxnRule.pm:3625:			push @$stack, $newMol->toString;
RxnRule.pm:3640:		foreach my $sc ( @{$rr->CompStateChange} )
RxnRule.pm:3646:			if ( defined $permute ) { $ip = $permute->[$ip]; }
RxnRule.pm:3649:			        split /\./, $matches->[$ip]->mapF( "$im.$ic", $offsets->[$ip] );
RxnRule.pm:3651:		    $mol->[$im_targ]->Components->[$ic_targ]->State($stateP);
RxnRule.pm:3654:			my $canonical_targ = $canonical_reactant_order->[$ip] . '.' . $matches->[$ip]->mapF("$im.$ic");
RxnRule.pm:3669:		foreach my $comp_change ( @{$rr->ChangeCompartment} )
RxnRule.pm:3678:			if ( defined $permute ) { $ip = $permute->[$ip]; }
RxnRule.pm:3686:				        split /\./, $matches->[$ip]->mapF( "$im.$ic", $offsets->[$ip] );
RxnRule.pm:3688:				$mol->[$im_targ]->Components->[$ic_targ]->Compartment($compartP);
RxnRule.pm:3691:				push @$stack, $canonical_reactant_order->[$ip] . '.'
RxnRule.pm:3692:				              . $matches->[$ip]->mapF("$im.$ic") . ','
RxnRule.pm:3693:				              . $compartP->Name;
RxnRule.pm:3697:				if ( $rr->MoveConnected )
RxnRule.pm:3702:					my ($im_targ) = $matches->[$ip]->mapF( "$im", $offsets->[$ip] );
RxnRule.pm:3706:					for ( my $jm = 0;  $jm < @{ $rr->Reactants->[$ip]->Molecules };  $jm++ )
RxnRule.pm:3711:						my $jm_targ = $matches->[$ip]->mapF( "$jm", $offsets->[$ip] );
RxnRule.pm:3719:					my @compartment_connected = $matches->[$ip]->Target->find_compartment_connected($im_targ);
RxnRule.pm:3727:						$mol->[$jm_targ]->Compartment($compartP);
RxnRule.pm:3731:					push @$stack, $canonical_reactant_order->[$ip] . '.'
RxnRule.pm:3732:					              . $matches->[$ip]->mapF($im) . ','
RxnRule.pm:3733:					              . $compartP->Name . ',' . 'mc';
RxnRule.pm:3737:					my ($im_targ) = $matches->[$ip]->mapF( "$im", $offsets->[$ip] );
RxnRule.pm:3739:					$mol->[$im_targ]->Compartment($compartP);
RxnRule.pm:3742:					push @$stack, $canonical_reactant_order->[$ip] . '.'
RxnRule.pm:3743:					              . $matches->[$ip]->mapF($im) . ','
RxnRule.pm:3744:					              . $compartP->Name;
RxnRule.pm:3751:				push @$stack, $canonical_reactant_order->[$ip] . ',' . $compartP->Name;
RxnRule.pm:3756:					for (  my $im = $offsets->[$ip];
RxnRule.pm:3757:						   $im < $offsets->[$ip] + @{ $matches->[$ip]->Target->Molecules };
RxnRule.pm:3761:						$g->Molecules->[$im]->Compartment($compartP);
RxnRule.pm:3767:					# if $cytosis=-1  [exocytosis]:  map Outside to Outside, Inside to Inside
RxnRule.pm:3769:					my $outsideR = $compartR->Outside;
RxnRule.pm:3770:					my $insideR  = $compartR->Inside->[0];    # should be only one compartment here
RxnRule.pm:3772:					my $outsideP = $compartP->Outside;
RxnRule.pm:3773:					my $insideP  = $compartP->Inside->[0];
RxnRule.pm:3778:					for (  my $im = $offsets->[$ip];
RxnRule.pm:3779:						   $im < $offsets->[$ip] + @{ $matches->[$ip]->Target->Molecules };
RxnRule.pm:3783:						if ( $g->Molecules->[$im]->Compartment == $compartR )
RxnRule.pm:3784:						{   $g->Molecules->[$im]->Compartment($compartP);   }
RxnRule.pm:3786:						elsif ( $g->Molecules->[$im]->Compartment == $outsideR )
RxnRule.pm:3787:						{   $g->Molecules->[$im]->Compartment($outsideP);   }
RxnRule.pm:3789:						elsif ( $g->Molecules->[$im]->Compartment == $insideR )
RxnRule.pm:3790:						{   $g->Molecules->[$im]->Compartment($insideP);   }
RxnRule.pm:3796:								        $rr->toString
RxnRule.pm:3817:		foreach my $edel ( @{$rr->EdgeDel} )
RxnRule.pm:3828:				if ( defined $permute ) { $ip = $permute->[$ip]; }
RxnRule.pm:3832:				    $matches->[$ip]->mapF( "$im.$ic", $offsets->[$ip] );
RxnRule.pm:3835:				my $ref_canonical = $canonical_reactant_order->[$ip] . '.'
RxnRule.pm:3836:				                    . $matches->[$ip]->mapF("$im.$ic");
RxnRule.pm:3841:			$g->deleteEdge(@targs);
RxnRule.pm:3862:		foreach my $eadd ( @{$rr->EdgeAdd} )
RxnRule.pm:3864:			# get pointers to components in the super-graph
RxnRule.pm:3865:			my $g_ref1 = $mapP->{ $eadd->[0] };
RxnRule.pm:3866:			my $g_ref2 = $mapP->{ $eadd->[1] };
RxnRule.pm:3868:            # need to map edge adds from super-graph back to reactant patterns, if possible
RxnRule.pm:3876:				foreach my $ptr ( keys %{$map->MapF} )
RxnRule.pm:3878:					if ( $map->mapF( $ptr, $offsets->[$ip1] ) eq $g_ref1 )
RxnRule.pm:3880:						$ref1 = $canonical_reactant_order->[ defined $permute
RxnRule.pm:3881:						                                     ? $permute->[$ip1]
RxnRule.pm:3882:						                                     : $ip1             ] .'.'. $map->mapF($ptr);		         
RxnRule.pm:3896:				foreach my $ptr ( keys %{$map->MapF} )
RxnRule.pm:3898:					if ( $map->mapF( $ptr, $offsets->[$ip2] ) eq $g_ref2 )
RxnRule.pm:3900:						$ref2 = $canonical_reactant_order->[ defined $permute
RxnRule.pm:3901:						                                     ? $permute->[$ip2]
RxnRule.pm:3902:						                                     : $ip2             ] .'.'. $map->mapF($ptr);
RxnRule.pm:3911:			$g->addEdge( "ne${nedge}", $g_ref1, $g_ref2 );
RxnRule.pm:3935:		foreach my $molref ( @{$rr->MolDel} )
RxnRule.pm:3941:			if ( defined $permute ) {  $ip = $permute->[$ip];  }
RxnRule.pm:3946:				my $im_targ = $matches->[$ip]->mapF( "$im", $offsets->[$ip] );
RxnRule.pm:3948:				$g->Molecules->[$im_targ] = undef;
RxnRule.pm:3952:				push @$stack, $canonical_reactant_order->[$ip] . '.'
RxnRule.pm:3953:				    . $matches->[$ip]->mapF($im);
RxnRule.pm:3961:				    $offsets->[$ip] + $#{ $matches->[$ip]->Target->Molecules };
RxnRule.pm:3962:				foreach my $im_targ ( $offsets->[$ip] .. $im_targ_max )
RxnRule.pm:3964:					$g->Molecules->[$im_targ] = undef;
RxnRule.pm:3969:				push @$stack, $canonical_reactant_order->[$ip];
RxnRule.pm:3975:		while ( $im < @{$g->Molecules} )
RxnRule.pm:3977:			unless ( defined $g->Molecules->[$im] )
RxnRule.pm:3980:				splice @{$g->Molecules}, $im, 1;
RxnRule.pm:3997:	$g->updateEdges( SpeciesGraph::ALLOW_DANGLING_BONDS, SpeciesGraph::TRIM_DANGLING_BONDS);
RxnRule.pm:4001:	#   mapP_reverse: product molecules (m) -> product pattern (p)
RxnRule.pm:4004:	my $mapP_reverse = [ (undef) x (@{$g->Molecules} + @$del_list) ];
RxnRule.pm:4005:    # build map by inverting %mapP for all molecule values. recall thaat mapP: p.m.c -> m.c
RxnRule.pm:4013:        $mapP_reverse->[$mc] = $p;
RxnRule.pm:4028:    my ($err, $products) = $g->splitConnectedComponents($mapP_reverse);
RxnRule.pm:4056:	    # if no elements in pointer A, set cmp=0 if pointer B is empty and -1 otherwise, then break.    	
RxnRule.pm:4057:		unless (@a) {  $cmp = @b ? -1 : 0;  last;  }
RxnRule.pm:4083:	    # if no pointers in edge A:  set cmp=0 if edge B is empty and -1 otherwise, then break.
RxnRule.pm:4084:	    unless (@a) {  $cmp = @b ? -1 : 0;  last;  }
RxnRule.pm:4095:	        # if no elements in pointer A, set cmp=0 if pointer B is empty and -1 otherwise, then break.    
RxnRule.pm:4096:		    unless (@pa) {  $cmp = @pb ? -1 : 0;  last;  }
RxnRule.pm:4125:	if ( $arr[0] == -1 )
RxnRule.pm:4149:		$plist->set( $arg, $oid, 1, "Local" );
RxnRule.pm:4158:	foreach my $arg ( keys %{$refs} ) { $plist->deleteLocal($arg); }
SpeciesGraph.pm:45:    StringExact => '$',    # This is also related to canonical labeling (what's the difference?)  --justin
SpeciesGraph.pm:70:#  Auto   == quasi-canonical labeling with isomorphism checks similar graphs
SpeciesGraph.pm:71:#  Quasi  == quasi-canonical labeling, no checks (unsafe method)
SpeciesGraph.pm:98:    return @{$sg->Molecules} ? 0 : 1;
SpeciesGraph.pm:141:    if ( $string_left =~ /^0($|\s|\+|<->|->|,)/ )
SpeciesGraph.pm:157:		if ( $head =~ s/^([\w\s*]+)// ) {  $sg->Name($1);  }
SpeciesGraph.pm:160:		if ( $head =~ s/^\%(\w+)// ) {  $sg->Label($1);  }
SpeciesGraph.pm:165:			my $comp = $clist->lookup($1);
SpeciesGraph.pm:166:			if   ($comp) { $sg->Compartment($comp); }
SpeciesGraph.pm:192:		    $sg->Fixed(1);
SpeciesGraph.pm:198:			$sg->Quantifier( $op . $2 );
SpeciesGraph.pm:224:					if ( $val == -1 )
SpeciesGraph.pm:228:					$sg->MatchOnce($val);
SpeciesGraph.pm:233:					if ( $val == -1 )
SpeciesGraph.pm:237:					$sg->Fixed($val);
SpeciesGraph.pm:248:		    push @{$sg->Molecules}, $mol;
SpeciesGraph.pm:258:	    unless ( @{$sg->Molecules} )
SpeciesGraph.pm:261:        if ($clist->Used)
SpeciesGraph.pm:264:		    $err = $sg->assignCompartment();
SpeciesGraph.pm:268:            unless ( defined $sg->Compartment )
SpeciesGraph.pm:272:            unless ( $sg->verifyTopology(1) )
SpeciesGraph.pm:276:		# NOTE: sortLabel sorts the molecules in a canonical or semi-canonical fashion,
SpeciesGraph.pm:278:		if ( $err = $sg->sortLabel() ) {  return $err;  }
SpeciesGraph.pm:281:		my ($nsub) = $sg->findConnected();
SpeciesGraph.pm:287:	    $err = $sg->updateEdges( ALLOW_DANGLING_BONDS ); 
SpeciesGraph.pm:294:		$err = $mtlist->checkSpeciesGraph( $sg, { IsSpecies     => $is_species,
SpeciesGraph.pm:295:                                                  AllowNewTypes => !$mtlist->StrictTyping } );
SpeciesGraph.pm:302:        my @autos = $sg->isomorphicToSubgraph($sg);
SpeciesGraph.pm:303:        $sg->Automorphisms( scalar @autos );
SpeciesGraph.pm:318:# check if a speciesGraph represents a fully-specified species.
SpeciesGraph.pm:331:    $err = $model->MoleculeTypesList->checkSpeciesGraph( $sg, $params );                           
SpeciesGraph.pm:335:    ($comp, $err) = $sg->inferSpeciesCompartment();
SpeciesGraph.pm:407:	my $n_mol = scalar( @{ $sg->Molecules } );
SpeciesGraph.pm:416:	foreach my $mol ( @{ $sg->Molecules } )
SpeciesGraph.pm:418:		my $mname = $mol->Name . "."
SpeciesGraph.pm:419:                    . ( defined $mol->State ? $mol->State : '' ) . "."
SpeciesGraph.pm:420:                    . ( defined $mol->Compartment ? $mol->Compartment : '' );
SpeciesGraph.pm:423:		foreach my $edge ( @{ $mol->Edges } )
SpeciesGraph.pm:428:		foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:431:			            . $comp->Name . "."
SpeciesGraph.pm:432:			            . ( defined $comp->State ? $comp->State : '' ) . "."
SpeciesGraph.pm:433:			            . ( defined $comp->Compartment ? $comp->Compartment : '' );
SpeciesGraph.pm:439:			foreach my $edge ( @{$comp->Edges} )
SpeciesGraph.pm:475:	foreach my $mol ( @{ $sg->Molecules } )
SpeciesGraph.pm:477:		my $icomp_end = $icomp_start + $#{ $mol->Components };
SpeciesGraph.pm:478:		my @perm_c = map { $perm->{$_} } ( $icomp_start .. $icomp_end );
SpeciesGraph.pm:480:		my @comp_perm =  map { [ $perm_c[$_], $mol->Components->[$_] ] } ( 0 .. $#{ $mol->Components } );
SpeciesGraph.pm:481:		@comp_perm = sort { $a->[0] <=> $b->[0] } @comp_perm;
SpeciesGraph.pm:482:		$mol->Components( [ map { $_->[1] } @comp_perm ] );
SpeciesGraph.pm:489:	  map { [ $perm->{$_}, $sg->Molecules->[$_] ] }
SpeciesGraph.pm:490:	  ( 0 .. $#{ $sg->Molecules } );
SpeciesGraph.pm:492:	#map {print $_->[0];} @mol_perm;  print "\n";
SpeciesGraph.pm:493:	@mol_perm = sort { $a->[0] <=> $b->[0] } @mol_perm;
SpeciesGraph.pm:494:	$sg->Molecules( [ map { $_->[1] } @mol_perm ] );
SpeciesGraph.pm:497:	$err = $sg->updateEdges( $allow_dangling, $trim_dangling );
SpeciesGraph.pm:503:	my $string = $sg->toString( PRINT_EDGES, !PRINT_ATTRIBUTES );
SpeciesGraph.pm:504:	$sg->StringExact($string);
SpeciesGraph.pm:505:	$sg->StringID($string);
SpeciesGraph.pm:506:	$sg->IsCanonical(TRUE);
SpeciesGraph.pm:529:	foreach my $mol (@{$sg->Molecules})
SpeciesGraph.pm:530:	{   @{$mol->Components} = sort by_component @{$mol->Components};   }
SpeciesGraph.pm:533:	@{$sg->Molecules} = sort by_molecule @{$sg->Molecules};
SpeciesGraph.pm:536:	$err = $sg->updateEdges( $allow_dangling, $trim_dangling );
SpeciesGraph.pm:540:	# Create quasi-canonical string representation
SpeciesGraph.pm:541:	$sg->StringID( $sg->toString(!PRINT_EDGES, !PRINT_ATTRIBUTES ) );
SpeciesGraph.pm:546:	$sg->StringExact( $sg->toString(PRINT_EDGES, !PRINT_ATTRIBUTES) );
SpeciesGraph.pm:547:	$sg->IsCanonical($isCanonical);
SpeciesGraph.pm:571:		$err = $sg->labelQuasi( $is_canonical, $allow_dangling, $trim_dangling );
SpeciesGraph.pm:576:		$err = $sg->labelQuasi( $is_canonical, $allow_dangling, $trim_dangling );
SpeciesGraph.pm:580:		$err = $sg->labelHNauty( $allow_dangling, $trim_dangling );
SpeciesGraph.pm:595: # $err = $sg->assignCompartment()
SpeciesGraph.pm:596: # $err = $sg->assignCompartment( $force_comp )
SpeciesGraph.pm:609:	my ( $species_comp, $err ) = $sg->inferSpeciesCompartment();
SpeciesGraph.pm:616:			return sprintf "Attempt to force incompatible species compartment on SpeciesGraph %s.", $sg->toString();
SpeciesGraph.pm:629:        #                $sg->toString();
SpeciesGraph.pm:634:	$sg->Compartment($species_comp);
SpeciesGraph.pm:638:	foreach my $mol ( @{ $sg->Molecules } )
SpeciesGraph.pm:640:		unless ( defined $mol->Compartment )
SpeciesGraph.pm:642:			$mol->Compartment($species_comp);
SpeciesGraph.pm:657:# (Compartment, err) = $sg->inferCompartment()
SpeciesGraph.pm:674:	foreach my $mol ( @{ $sg->Molecules } )
SpeciesGraph.pm:676:		my $comp = $mol->Compartment;
SpeciesGraph.pm:679:		# transfer the explicit species compartment (if any)  --justin
SpeciesGraph.pm:680:		if ( !(defined $comp)  and  defined $sg->Compartment )
SpeciesGraph.pm:682:			$comp = $sg->Compartment;
SpeciesGraph.pm:687:		if    ( $comp->SpatialDimensions == 2 ) { $surfaces{$comp} = $comp; }
SpeciesGraph.pm:688:		elsif ( $comp->SpatialDimensions == 3 ) { $volumes{$comp}  = $comp; }
SpeciesGraph.pm:710:			  $sg->toString();
SpeciesGraph.pm:721:			unless ( $inferred_comp->adjacent($comp) )
SpeciesGraph.pm:723:				$err = sprintf "Molecule Compartments of %s define invalid Species Compartment.", $sg->toString();
SpeciesGraph.pm:730:		$err = sprintf "Molecule Compartments of %s include more than 1 Surface.", $sg->toString();
SpeciesGraph.pm:735:	if ( defined $sg->Compartment  and  defined $inferred_comp )
SpeciesGraph.pm:737:		unless ( $inferred_comp == $sg->Compartment )
SpeciesGraph.pm:741:			              $sg->Compartment->Name, $inferred_comp->Name;
SpeciesGraph.pm:747:	if ( defined $sg->Compartment and !( defined $inferred_comp ) )
SpeciesGraph.pm:749:		$inferred_comp = $sg->Compartment;
SpeciesGraph.pm:765:# $valid = $sg->verifyTopology( $strict )
SpeciesGraph.pm:774:	foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:776:		foreach my $component ( @{$mol->Components} )
SpeciesGraph.pm:778:			foreach my $edge_idx ( @{$component->Edges} )
SpeciesGraph.pm:789:        my $comp0 = $bond->[0]->Compartment;
SpeciesGraph.pm:790:        my $comp1 = $bond->[1]->Compartment;
SpeciesGraph.pm:793:			return 0 unless ( $comp0==$comp1 or $comp0->adjacent($comp1) );
SpeciesGraph.pm:827:		my $comp = $sg->Compartment;
SpeciesGraph.pm:834:		if ( $comp->SpatialDimensions == 2 )
SpeciesGraph.pm:845:		elsif ( $comp->SpatialDimensions == 3 )
SpeciesGraph.pm:860:		return 0 unless ( $surface->adjacent($volume) );
SpeciesGraph.pm:875:# @compartment_connected = $sg->find_compartment_connected( $i_mol )
SpeciesGraph.pm:885:	my $comp = $sg->Molecules->[$i_mol]->Compartment;
SpeciesGraph.pm:891:	foreach my $edge ( @{ $sg->Edges } ) {
SpeciesGraph.pm:893:		if (    $sg->Molecules->[$mol1]->Compartment == $comp
SpeciesGraph.pm:894:			and $sg->Molecules->[$mol2]->Compartment == $comp )
SpeciesGraph.pm:896:			push @{ $adjacency_hash->{$mol1} }, $mol2;
SpeciesGraph.pm:897:			push @{ $adjacency_hash->{$mol2} }, $mol1;
SpeciesGraph.pm:918:		return if ( exists $connected_component->{$vertex} );
SpeciesGraph.pm:921:		$connected_component->{$vertex} = 1;
SpeciesGraph.pm:924:		foreach my $adjacent_vertex ( @{ $adjacency->{$vertex} } ) {
SpeciesGraph.pm:956:	my $sg_copy = SpeciesGraph->new();
SpeciesGraph.pm:960:	$sg_copy->Molecules($mol_copy);
SpeciesGraph.pm:970:	    $offsets->[$i_sg] = $offset;
SpeciesGraph.pm:971:	    $offset += @{$sg->Molecules};
SpeciesGraph.pm:973:	    # if we find a non-species graph, then allow dangling!
SpeciesGraph.pm:974:	    unless ( defined $sg->Species  and  ref $sg->Species eq 'SPECIES' )
SpeciesGraph.pm:978:		foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:980:			# This form of Molecule->copy adds a prefix to the edges to avoid
SpeciesGraph.pm:982:			push @$mol_copy, $mol->copy( 1, "${i_sg}_" );
SpeciesGraph.pm:988:	my $err = $sg_copy->updateEdges( $allow_dangling );
SpeciesGraph.pm:1015:	my $sg_copy = SpeciesGraph->new();
SpeciesGraph.pm:1018:    $sg_copy->Name( $sg->Name );
SpeciesGraph.pm:1019:    $sg_copy->Compartment( $sg->Compartment ) if (defined $sg->Compartment);
SpeciesGraph.pm:1020:    $sg_copy->Quantifier( $sg->Quantifier );
SpeciesGraph.pm:1021:    $sg_copy->MatchOnce( $sg->MatchOnce );
SpeciesGraph.pm:1022:    $sg_copy->Fixed( $sg->Fixed );
SpeciesGraph.pm:1023:    $sg_copy->Automorphisms( $sg->Automorphisms );
SpeciesGraph.pm:1026:	if ( @{$sg->Molecules} )
SpeciesGraph.pm:1028:	    $sg_copy->Molecules( [map {$_->copy($copy_labels)} @{$sg->Molecules}] );
SpeciesGraph.pm:1034:        $sg_copy->Label( $sg->Label );
SpeciesGraph.pm:1035:        $sg_copy->StringID( $sg->StringID );
SpeciesGraph.pm:1036:        $sg_copy->StringExact( $sg->StringExact );
SpeciesGraph.pm:1037:        $sg_copy->IsCanonical( $sg->IsCanonical );
SpeciesGraph.pm:1040:	    foreach my $edge ( @{$sg->Edges} )
SpeciesGraph.pm:1043:	        {   push @{$sg_copy->Edges}, [@$edge];   }
SpeciesGraph.pm:1045:	        {   push @{$sg_copy->Edges}, $edge;   }
SpeciesGraph.pm:1048:	    while ( my ($key,$val) = each %{$sg->Adjacency} )
SpeciesGraph.pm:1051:	        {   %{ $sg_copy->Adjacency->{$key} } = %{$val};   }
SpeciesGraph.pm:1053:	        {   $sg_copy->Adjacency->{$key} = $val;   }
SpeciesGraph.pm:1060:	        # generate label and, as side-effect, build Edges and Adjacencies
SpeciesGraph.pm:1061:		    my $err = $sg_copy->sortLabel( ALLOW_DANGLING_BONDS, TRIM_DANGLING_BONDS );
SpeciesGraph.pm:1067:		    my $err = $sg_copy->updateEdges( ALLOW_DANGLING_BONDS, TRIM_DANGLING_BONDS );
SpeciesGraph.pm:1072:    if (defined $sg->Species)
SpeciesGraph.pm:1074:        $sg_copy->Species( $sg->Species );
SpeciesGraph.pm:1095:    if ( defined $sg->Compartment )
SpeciesGraph.pm:1097:        my $new_comp = $clist->lookup( $sg->Compartment->Name );
SpeciesGraph.pm:1098:        $sg->Compartment( $new_comp );
SpeciesGraph.pm:1101:    foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1103:        $mol->relinkCompartments( $clist );
SpeciesGraph.pm:1124:    $label_map->{$sg->Label} = $i_sg  if (defined $sg->Label);
SpeciesGraph.pm:1125:    for ( my $i_mol = 0;  $i_mol < @{$sg->Molecules}; ++$i_mol )
SpeciesGraph.pm:1127:        my $mol = $sg->Molecules->[$i_mol];
SpeciesGraph.pm:1128:        $label_map->{$mol->Label} = "$i_sg.$i_mol"  if (defined $mol->Label);
SpeciesGraph.pm:1130:        for ( my $i_comp = 0; $i_comp < @{$mol->Components}; ++$i_comp )
SpeciesGraph.pm:1132:            my $comp = $mol->Components->[$i_comp];
SpeciesGraph.pm:1133:            $label_map->{$comp->Label} = "$i_sg.$i_mol.$i_comp"  if (defined $comp->Label);            
SpeciesGraph.pm:1149:    my $mt = $mtlist->MolTypes->{$sg->Molecules->[0]->Name};
SpeciesGraph.pm:1150:    return (defined $mt->PopulationType) ? $mt->PopulationType : 0;
SpeciesGraph.pm:1171:    foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1173:        unless ( defined $mol->Label )
SpeciesGraph.pm:1175:            while ( exists $used_labels->{"$base$i_label"} )
SpeciesGraph.pm:1177:            $mol->Label( "$base$i_label" );
SpeciesGraph.pm:1178:            $new_labels->{"$base$i_label"} = 1;
SpeciesGraph.pm:1181:        foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1183:            unless ( defined $comp->Label )
SpeciesGraph.pm:1185:                while ( exists $used_labels->{"$base$i_label"} )
SpeciesGraph.pm:1187:                $comp->Label( "$base$i_label" );
SpeciesGraph.pm:1188:                $new_labels->{"$base$i_label"} = 1;                
SpeciesGraph.pm:1210:    foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1212:        if ( defined $mol->Label )
SpeciesGraph.pm:1214:            if ( exists $delete_labels->{$mol->Label} )
SpeciesGraph.pm:1215:            {   $mol->Label(undef);   }
SpeciesGraph.pm:1217:        foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1219:            if ( defined $comp->Label )
SpeciesGraph.pm:1221:                if ( exists $delete_labels->{$comp->Label} )
SpeciesGraph.pm:1222:                {   $comp->Label(undef);   }
SpeciesGraph.pm:1240:    # build auto-labels for reactant molecules
SpeciesGraph.pm:1244:        my $patt = $sgs1->[$ip];
SpeciesGraph.pm:1245:	    for ( my $im = 0 ; $im < @{$patt->Molecules} ; ++$im )
SpeciesGraph.pm:1247:		    my $mol   = $patt->Molecules->[$im];
SpeciesGraph.pm:1249:            foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1251:                if ( defined $comp->Label and (not exists $temp_labels->{$comp->Label}) )
SpeciesGraph.pm:1252:                {   push @comps, "%" . $comp->Label;   }
SpeciesGraph.pm:1254:                {   push @comps, $comp->Name;   }
SpeciesGraph.pm:1256:            my $mlabel = ((defined $mol->Label) and (not exists $temp_labels->{$mol->Label})) ?
SpeciesGraph.pm:1257:                          ("%" . $mol->Label)  :  $mol->Name;
SpeciesGraph.pm:1260:            $autolabels1->{$mlabel} = []  unless (exists $autolabels1->{$mlabel});
SpeciesGraph.pm:1261:		    push @{$autolabels1->{$mlabel}}, "$ip.$im";
SpeciesGraph.pm:1265:    # build auto-labels for product molecules
SpeciesGraph.pm:1269:        my $patt = $sgs2->[$ip];
SpeciesGraph.pm:1270:	    for ( my $im = 0 ; $im < @{$patt->Molecules} ; ++$im )
SpeciesGraph.pm:1272:		    my $mol   = $patt->Molecules->[$im];
SpeciesGraph.pm:1274:            foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1276:                if ( defined $comp->Label and (not exists $temp_labels->{$comp->Label}) )
SpeciesGraph.pm:1277:                {   push @comps, "%" . $comp->Label;   }
SpeciesGraph.pm:1279:                {   push @comps, $comp->Name;   }
SpeciesGraph.pm:1281:            my $mlabel = ((defined $mol->Label) and (not exists $temp_labels->{$mol->Label})) ?
SpeciesGraph.pm:1282:                          ("%" . $mol->Label)  :  $mol->Name;
SpeciesGraph.pm:1286:            $autolabels2->{$mlabel} = []  unless (exists $autolabels2->{$mlabel});
SpeciesGraph.pm:1287:		    push @{$autolabels2->{$mlabel}}, "$ip.$im";
SpeciesGraph.pm:1294:        my @set1 = @{$autolabels1->{$key}};
SpeciesGraph.pm:1295:        my @set2 = exists $autolabels2->{$key} ? @{$autolabels2->{$key}} : ();
SpeciesGraph.pm:1300:            my $mol1 = $sgs1->[$ip1]->Molecules->[$im1];
SpeciesGraph.pm:1309:                my $mol2 = $sgs2->[$ip2]->Molecules->[$im2];
SpeciesGraph.pm:1311:                if ( defined $mol1->Label  and  defined $mol2->Label )
SpeciesGraph.pm:1313:                    if ( $mol1->Label eq $mol2->Label )
SpeciesGraph.pm:1315:                        if ( not $ambiguous  and  exists $temp_labels->{$mol1->Label}  )
SpeciesGraph.pm:1317:                            $mol1->Label(undef);  $mol2->Label(undef);
SpeciesGraph.pm:1325:                        if ( exists $temp_labels->{$mol1->Label}  and  exists $temp_labels->{$mol2->Label} )
SpeciesGraph.pm:1326:                        {   # things could get ambiguous since neither label is non-temporary!
SpeciesGraph.pm:1332:                elsif ( not defined $mol1->Label  and  not defined $mol2->Label )
SpeciesGraph.pm:1338:                elsif ( defined $mol1->Label )
SpeciesGraph.pm:1340:                     $ambiguous = 1  if ( exists $temp_labels->{$mol1->Label} );
SpeciesGraph.pm:1343:                elsif ( defined $mol2->Label )
SpeciesGraph.pm:1345:                    $ambiguous = 1  if ( exists $temp_labels->{$mol2->Label} );
SpeciesGraph.pm:1354:                $mol1->Label(undef) if ( not $ambiguous and defined $mol1->Label and exists $temp_labels->{$mol1->Label} );
SpeciesGraph.pm:1355:                foreach my $comp ( @{$mol1->Components} )
SpeciesGraph.pm:1357:                    $comp->Label(undef) if ( defined $comp->Label and exists $temp_labels->{$comp->Label} );
SpeciesGraph.pm:1366:        unless ( exists $autolabels1->{$key} )
SpeciesGraph.pm:1368:            my @set = @{$autolabels2->{$key}};
SpeciesGraph.pm:1372:                my $mol = $sgs2->[$ip]->Molecules->[$im];
SpeciesGraph.pm:1373:                $mol->Label(undef)  if ( defined $mol->Label  and  exists $temp_labels->{$mol->Label} );
SpeciesGraph.pm:1374:                foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1376:                    $comp->Label(undef)  if ( defined $comp->Label  and  exists $temp_labels->{$comp->Label} );
SpeciesGraph.pm:1384:    #----------------------------------------------------#
SpeciesGraph.pm:1386:    #----------------------------------------------------#
SpeciesGraph.pm:1391:        # build auto-labels for mol1 components
SpeciesGraph.pm:1393:	    for ( my $ic = 0 ; $ic < @{$mol1->Components} ; ++$ic )
SpeciesGraph.pm:1395:            my $comp = $mol1->Components->[$ic];
SpeciesGraph.pm:1396:            my $clabel = ((defined $comp->Label)  and  (not exists $temp_labels->{$comp->Label})) ?
SpeciesGraph.pm:1397:                          ("%" . $comp->Label)  :  $comp->Name;
SpeciesGraph.pm:1398:            $autolabels1->{$clabel} = []  unless (exists $autolabels1->{$clabel});
SpeciesGraph.pm:1399:            push @{$autolabels1->{$clabel}}, "$ic";
SpeciesGraph.pm:1401:        # build auto-labels for mol2 components
SpeciesGraph.pm:1403:	    for ( my $ic = 0 ; $ic < @{$mol2->Components} ; ++$ic )
SpeciesGraph.pm:1405:            my $comp = $mol2->Components->[$ic];
SpeciesGraph.pm:1406:            my $clabel = ((defined $comp->Label) and (not exists $temp_labels->{$comp->Label})) ?
SpeciesGraph.pm:1407:                          ("%" . $comp->Label)  :  $comp->Name;
SpeciesGraph.pm:1409:            $autolabels2->{$clabel} = []  unless (exists $autolabels2->{$clabel});
SpeciesGraph.pm:1410:            push @{$autolabels2->{$clabel}}, "$ic";
SpeciesGraph.pm:1415:            my @set1 = @{$autolabels1->{$key}};
SpeciesGraph.pm:1416:            my @set2 = exists $autolabels2->{$key} ? @{$autolabels2->{$key}} : ();
SpeciesGraph.pm:1420:                my $comp1 = $mol1->Components->[ shift @set1 ];
SpeciesGraph.pm:1429:                    my $comp2 = $mol2->Components->[$ic2];
SpeciesGraph.pm:1431:                    if ( defined $comp1->Label  and  defined $comp2->Label )
SpeciesGraph.pm:1433:                        if ( $comp1->Label eq $comp2->Label )
SpeciesGraph.pm:1435:                            if ( not $ambiguous  and  exists $temp_labels->{$comp1->Label}  )
SpeciesGraph.pm:1437:                                $comp1->Label(undef);  $comp2->Label(undef);
SpeciesGraph.pm:1444:                            if ( exists $temp_labels->{$comp1->Label}  and  exists $temp_labels->{$comp2->Label} )
SpeciesGraph.pm:1445:                            {   # things could get ambiguous since neither label is non-temporary!
SpeciesGraph.pm:1451:                    elsif ( not defined $comp1->Label  and  not defined $comp2->Label )
SpeciesGraph.pm:1456:                    elsif ( defined $comp1->Label )
SpeciesGraph.pm:1458:                        $ambiguous = 1  if ( exists $temp_labels->{$comp1->Label} );
SpeciesGraph.pm:1461:                    elsif ( defined $comp2->Label )
SpeciesGraph.pm:1463:                        $ambiguous = 1  if ( exists $temp_labels->{$comp2->Label} );
SpeciesGraph.pm:1472:                    $comp1->Label(undef) if ( not $ambiguous and defined $comp1->Label and exists $temp_labels->{$comp1->Label} );
SpeciesGraph.pm:1479:            unless ( exists $autolabels1->{$key} )
SpeciesGraph.pm:1481:                my @set = @{$autolabels2->{$key}};
SpeciesGraph.pm:1484:                    my $comp = $mol2->Components->[$ic];
SpeciesGraph.pm:1485:                    $comp->Label(undef)  if ( defined $comp->Label and exists $temp_labels->{$comp->Label} );
SpeciesGraph.pm:1491:    # end sub-sub
SpeciesGraph.pm:1504:# given a speciesGraph $sg with n-connected components, an array @$subgraph
SpeciesGraph.pm:1509:# NOTE: it is assumed the components have no dangling-edges!!  If updateEdges
SpeciesGraph.pm:1518:	my $sg_copy = SpeciesGraph->new();
SpeciesGraph.pm:1522:	$sg_copy->Molecules( $mol_copy );
SpeciesGraph.pm:1523:	foreach my $imol ( 0 .. $#{$sg->Molecules} )
SpeciesGraph.pm:1526:		push @$mol_copy, $sg->Molecules->[$imol]->copy();
SpeciesGraph.pm:1530:	$err = $sg_copy->updateEdges( !ALLOW_DANGLING_BONDS );
SpeciesGraph.pm:1554:	foreach my $mol ( @{ $sg->Molecules } )
SpeciesGraph.pm:1556:		next if ( $mname cmp $mol->Name );
SpeciesGraph.pm:1574:# and stores the list at @{$sg->Edges}.  An adjacency hash is also created
SpeciesGraph.pm:1575:# and stored at @{$sg->Adjacency}.  Returns undefined value if edges are ok.  Returns
SpeciesGraph.pm:1580:#         Molecules and Components should be pre-sorted before calling this routine.
SpeciesGraph.pm:1582:# Q: why are edges sorted? For quasi-canonical labeling?
SpeciesGraph.pm:1596:	#  i.e.  %labeled_edges: elabel -> [m1, c1, m2, c2 ...]
SpeciesGraph.pm:1599:	foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1603:		foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:1607:			foreach my $elabel ( @{$comp->Edges} )
SpeciesGraph.pm:1620:            $comp->Edges( [@wildcards] );
SpeciesGraph.pm:1629:	$sg->Edges($edges);
SpeciesGraph.pm:1633:	$sg->Adjacency($adjacency);
SpeciesGraph.pm:1643:            ($m1, $c1) = @{$edge->[0]};
SpeciesGraph.pm:1644:            ($m2, $c2) = @{$edge->[1]};
SpeciesGraph.pm:1649:			$adjacency->{$p1}{$p2} = $iedge;
SpeciesGraph.pm:1650:			$adjacency->{$p2}{$p1} = $iedge;
SpeciesGraph.pm:1652:			push @{ $sg->Molecules->[$m1]->Components->[$c1]->Edges }, $iedge;
SpeciesGraph.pm:1653:			push @{ $sg->Molecules->[$m2]->Components->[$c2]->Edges }, $iedge;
SpeciesGraph.pm:1667:                ($m1, $c1) = @{$edge->[0]};
SpeciesGraph.pm:1668:			    push @{$sg->Molecules->[$m1]->Components->[$c1]->Edges}, "+";
SpeciesGraph.pm:1705:	    if ($sg->Name)
SpeciesGraph.pm:1706:	    {   $string .= $sg->Name;   }
SpeciesGraph.pm:1708:	    if ($sg->Label)
SpeciesGraph.pm:1709:	    {   $string .= '%' . $sg->Label;   }
SpeciesGraph.pm:1712:	if ( $sg->Compartment )
SpeciesGraph.pm:1713:	{   $string .= '@' . $sg->Compartment->Name;   }
SpeciesGraph.pm:1723:		if ( $sg->MatchOnce )
SpeciesGraph.pm:1733:		if ( $sg->Fixed )
SpeciesGraph.pm:1739:	foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1742:		$string .= $mol->toString( $print_edges, $print_attributes, $sg->Compartment );
SpeciesGraph.pm:1749:        if ( $sg->Quantifier )
SpeciesGraph.pm:1750:        {   $string .= $sg->Quantifier;   }
SpeciesGraph.pm:1773:	if ( $sg->MatchOnce )
SpeciesGraph.pm:1781:	foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1784:		( my $tempstring, $checkSameComp ) = $mol->toStringSSC();
SpeciesGraph.pm:1810:	foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1813:		$string .= $mol->Name;
SpeciesGraph.pm:1814:		$string .= $mol->toStringSSCMol( $print_edges ); #Calls toStringSSCMol of Molecule.pm
SpeciesGraph.pm:1850:	if ( $sg->Label )
SpeciesGraph.pm:1852:		$string .= " label=\"" . $sg->Label . "\"";
SpeciesGraph.pm:1856:	if ( $sg->Compartment )
SpeciesGraph.pm:1858:		$string .= " compartment=\"" . $sg->Compartment->Name . "\"";
SpeciesGraph.pm:1862:	if ( $sg->MatchOnce )
SpeciesGraph.pm:1868:	if ( $sg->Fixed )
SpeciesGraph.pm:1874:	if ( $sg->Quantifier )
SpeciesGraph.pm:1876:		my ( $relation, $quantity ) = ( $sg->Quantifier =~ /(=|==|<=|>=|<|>)(\d+)/ );
SpeciesGraph.pm:1885:	if ( @{$sg->Molecules} )
SpeciesGraph.pm:1889:		foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:1891:			$ostring .= $mol->toXML( "  " . $indent2, $id, $index );
SpeciesGraph.pm:1898:	if ( @{$sg->Edges} )
SpeciesGraph.pm:1903:		foreach my $edge ( @{$sg->Edges} )
SpeciesGraph.pm:1906:            next unless (defined $p2); # Only print full bonds; half-bonds handled by BindingState variable in Components
SpeciesGraph.pm:1910:			$bstring .= " site1=\"" . $sg->p_to_label( $p1, $id ) . "\"";
SpeciesGraph.pm:1911:			$bstring .= " site2=\"" . $sg->p_to_label( $p2, $id ) . "\"";
SpeciesGraph.pm:1955:		push @{ $sg->Molecules->[$im]->Components->[$ic]->Edges }, $ename;
SpeciesGraph.pm:1974:	return unless exists $sg->Adjacency->{$p1}{$p2};
SpeciesGraph.pm:1975:	my $ename = $sg->Adjacency->{$p1}{$p2};
SpeciesGraph.pm:1981:		my $cedges = $sg->Molecules->[$im]->Components->[$ic]->Edges;
SpeciesGraph.pm:1984:			if ( $cedges->[$ie] eq $ename )
SpeciesGraph.pm:2010:#  and replaces with findConnected2.  --Justin, 25mar2011
SpeciesGraph.pm:2019:	my @subgraph   = (0) x @{$sg->Molecules};
SpeciesGraph.pm:2024:		my $imol_start = -1;
SpeciesGraph.pm:2046:				my $mol = $sg->Molecules->[$imol];
SpeciesGraph.pm:2049:				for ( my $icomp=0;  $icomp < @{$mol->Components};  ++$icomp )
SpeciesGraph.pm:2054:					foreach my $q ( keys %{$sg->Adjacency->{$p}} )
SpeciesGraph.pm:2086:    $sg->depthFirstMoleculeSearch( 0, $connected_component );
SpeciesGraph.pm:2088:    for ( my $imol = 0;  $imol < @{$sg->Molecules};  ++$imol )
SpeciesGraph.pm:2090:        return 0  unless ( exists $connected_component->{$imol} );
SpeciesGraph.pm:2116:        unless ( @$map_imol_to_ipatt == @{$sg->Molecules} )
SpeciesGraph.pm:2118:            return "SpeciesGraph->splitConnectedComponents: ERROR! map size is not equal to number of molecules", [];
SpeciesGraph.pm:2120:        my $max_ipatt = -1;
SpeciesGraph.pm:2126:        $n_patt = ($max_ipatt == -1) ? 0 : $max_ipatt + 1;
SpeciesGraph.pm:2130:        $map_imol_to_ipatt = [(undef) x @{$sg->Molecules}];
SpeciesGraph.pm:2141:    for ( my $imol = 0;  $imol < @{$sg->Molecules};  ++$imol )
SpeciesGraph.pm:2144:        next if ( exists $visited->{$imol} );
SpeciesGraph.pm:2148:        $sg->breadthFirstMoleculeSearch( $imol, $connected_component, $visited );
SpeciesGraph.pm:2151:        #  a pre-assigned pattern index
SpeciesGraph.pm:2155:            if ( defined $ipatt  and  defined $map_imol_to_ipatt->[$imol2] )
SpeciesGraph.pm:2157:                if ( $ipatt != $map_imol_to_ipatt->[$imol2] )
SpeciesGraph.pm:2159:                    return "SpeciesGraph->splitConnectedComponents: ERROR!!  Connected molecules mapped to different patterns ", [];
SpeciesGraph.pm:2162:            elsif ( defined $map_imol_to_ipatt->[$imol2] )
SpeciesGraph.pm:2164:                $ipatt = $map_imol_to_ipatt->[$imol2];
SpeciesGraph.pm:2176:        unless ( defined $sgs->[$ipatt] ) {  $sgs->[$ipatt] = SpeciesGraph::new();  }
SpeciesGraph.pm:2182:            $map_imol_to_ipatt->[$imol2] = $ipatt;
SpeciesGraph.pm:2184:            push @{$sgs->[$ipatt]->Molecules}, $sg->Molecules->[$imol2];
SpeciesGraph.pm:2191:    @{$sg->Molecules} = ();
SpeciesGraph.pm:2200:            return "SpeciesGraph->splitConnectedComponents: ERROR!! No molecules corresponding to SpeciesGraph $ipatt", [];
SpeciesGraph.pm:2204:	    my $err = $sg2->updateEdges();
SpeciesGraph.pm:2207:		    return "SpeciesGraph->splitConnectedComponents: ERROR!! some problem in updateEdges:\n" . $sg2->toString() . "\n", [];
SpeciesGraph.pm:2243:        next if ( exists $visited->{$imol} );   
SpeciesGraph.pm:2245:        $visited->{$imol} = 1;
SpeciesGraph.pm:2248:        push @$found, $imol  if ($condition->($imol));
SpeciesGraph.pm:2251:        my $mol = $sg->Molecules->[$imol];
SpeciesGraph.pm:2252:        for ( my $icomp = 0;  $icomp < @{$mol->Components};  ++$icomp )
SpeciesGraph.pm:2255:            foreach my $ptr2 ( keys %{$sg->Adjacency->{$ptr}} )
SpeciesGraph.pm:2283:    return if ( exists $visited->{$imol} );
SpeciesGraph.pm:2284:    $visited->{$imol} = 1;
SpeciesGraph.pm:2287:    $found->{$imol} = 1  if ( $condition->($imol) );
SpeciesGraph.pm:2290:    my $mol = $sg->Molecules->[$imol];
SpeciesGraph.pm:2291:    for ( my $icomp = 0;  $icomp < @{$mol->Components};  ++$icomp )
SpeciesGraph.pm:2294:        foreach my $ptr2 ( keys %{$sg->Adjacency->{$ptr}} )
SpeciesGraph.pm:2297:            $sg->depthFirstMoleculeSearch( $imol2, $found, $visited, $condition );
SpeciesGraph.pm:2320:	if (      defined $sg1->StringID
SpeciesGraph.pm:2321:	     and  defined $sg2->StringID
SpeciesGraph.pm:2322:	     and  ($sg1->StringID cmp $sg2->StringID)  )
SpeciesGraph.pm:2324:		#print "[not isomorphic] failed string test: ", $sg1->StringID, " vs ", $sg2->StringID, "\n";
SpeciesGraph.pm:2329:	if (      defined $sg1->StringExact
SpeciesGraph.pm:2330:	     and  defined $sg2->StringExact
SpeciesGraph.pm:2331:	     and  !($sg1->StringExact cmp $sg2->StringExact)  )
SpeciesGraph.pm:2333:		#print "[isomorphic] passed exact match: ", $sg1->StringExact, " vs ", $sg2->StringExact, "\n";
SpeciesGraph.pm:2338:    unless (@{$sg1->Molecules} == @{$sg2->Molecules})
SpeciesGraph.pm:2342:	my $molecules1 = $sg1->Molecules;
SpeciesGraph.pm:2343:	my $molecules2 = $sg2->Molecules;
SpeciesGraph.pm:2355:	my $components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2359:	my $adj1 = $sg1->Adjacency;
SpeciesGraph.pm:2360:	my $adj2 = $sg2->Adjacency;
SpeciesGraph.pm:2375:			next if ( $molecules1->[$im1]->Name  cmp  $molecules2->[$im2]->Name );
SpeciesGraph.pm:2376:            if ( defined $molecules1->[$im1]->Compartment )
SpeciesGraph.pm:2378:                next unless ( defined $molecules2->[$im2]->Compartment );
SpeciesGraph.pm:2379:                next unless ( $molecules1->[$im1]->Compartment == $molecules2->[$im2]->Compartment );
SpeciesGraph.pm:2381:            elsif ( defined $molecules2->[$im2]->Compartment )
SpeciesGraph.pm:2387:            next unless ( @{$molecules1->[$im1]->Components} == @{$molecules2->[$im2]->Components} );
SpeciesGraph.pm:2391:			$components2  = $molecules2->[$im2]->Components;
SpeciesGraph.pm:2407:			--$im1;
SpeciesGraph.pm:2408:			$components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2414:			$components2 = $molecules2->[$im2]->Components;
SpeciesGraph.pm:2420:        unless ( @{$molecules1->[$im1]->Components} == 0 )
SpeciesGraph.pm:2430:		        for ( $ic2 = $cptr->[$ic1];  $ic2 <= $ncomp;  ++$ic2 )
SpeciesGraph.pm:2432:			        next if $cused->[$ic2];
SpeciesGraph.pm:2433:			        if ( $components1->[$ic1]->compare_local( $components2->[$ic2] ) )
SpeciesGraph.pm:2441:			        foreach my $q1 ( keys %{$adj1->{$p1}} )
SpeciesGraph.pm:2451:				        unless ( defined $adj2->{$p2}{$q2} )
SpeciesGraph.pm:2459:			        $cptr->[$ic1] = $ic2;
SpeciesGraph.pm:2470:				        $cused->[$ic2] = 1;
SpeciesGraph.pm:2490:			        $cptr->[$ic1] = 0;
SpeciesGraph.pm:2491:			        --$ic1;
SpeciesGraph.pm:2492:			        $cused->[ $cptr->[$ic1] ] = 0;    # Reset pointers at new level
SpeciesGraph.pm:2493:			        ++$cptr->[$ic1];
SpeciesGraph.pm:2508:		$components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2530:    my $root_src  = @_ ? shift @_ : -1;
SpeciesGraph.pm:2531:    my $root_targ = @_ ? shift @_ : -1;
SpeciesGraph.pm:2533:	my $molecules1 = $sg1->Molecules;
SpeciesGraph.pm:2534: 	my $edges1     = $sg1->Edges;
SpeciesGraph.pm:2535:	my $adj1       = $sg1->Adjacency;
SpeciesGraph.pm:2537:	my $molecules2 = $sg2->Molecules;
SpeciesGraph.pm:2538:    my $edges2     = $sg2->Edges;
SpeciesGraph.pm:2539:	my $adj2       = $sg2->Adjacency;
SpeciesGraph.pm:2551:	if ( defined $sg1->Compartment )
SpeciesGraph.pm:2553:        return @maps unless ( defined $sg2->Compartment );
SpeciesGraph.pm:2554:        return @maps unless ( $sg1->Compartment == $sg2->Compartment );
SpeciesGraph.pm:2558:    if ( $sg1->isNull() )
SpeciesGraph.pm:2560:        my $map = Map->new( Source=>$sg1, Target=>$sg2 );
SpeciesGraph.pm:2565:    ## Now look for a non-trivial subgraph isomorphism
SpeciesGraph.pm:2592:	my $components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2615:            next unless ( $molecules1->[$im1]->Name eq $molecules2->[$im2]->Name );
SpeciesGraph.pm:2618:            next if ( @$components1 > @{$molecules2->[$im2]->Components} );
SpeciesGraph.pm:2621:			if ( defined $molecules1->[$im1]->Compartment )
SpeciesGraph.pm:2623:                next unless ( defined $molecules2->[$im2]->Compartment );
SpeciesGraph.pm:2624:				next unless ( $molecules1->[$im1]->Compartment == $molecules2->[$im2]->Compartment );
SpeciesGraph.pm:2629:			$components2  = $molecules2->[$im2]->Components;
SpeciesGraph.pm:2632:			$ic1 = ( $comp1_last >= 0 ) ? 0 : -1;
SpeciesGraph.pm:2646:			--$im1;
SpeciesGraph.pm:2647:			$components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2662:			$components2 = $molecules2->[$im2]->Components;
SpeciesGraph.pm:2675:				$ci1 = $components1->[$ic1];
SpeciesGraph.pm:2677:				for ( $ic2 = $comp1_ptr->[$ic1];  $ic2 <= $comp2_last;  ++$ic2 )
SpeciesGraph.pm:2679:					next if $comp2_used->[$ic2];
SpeciesGraph.pm:2680:					$ci2 = $components2->[$ic2];
SpeciesGraph.pm:2683:					next unless ( $ci1->Name eq $ci2->Name );
SpeciesGraph.pm:2686:					if ( defined $ci1->State )
SpeciesGraph.pm:2688:						unless ( $ci1->State eq "?" )
SpeciesGraph.pm:2690:							next unless ( $ci1->State eq $ci2->State );
SpeciesGraph.pm:2694:					if ( defined $ci1->Compartment )
SpeciesGraph.pm:2696:                        next unless ( defined $ci2->Compartment );
SpeciesGraph.pm:2697:						next unless ( $ci1->Compartment == $ci2->Compartment );
SpeciesGraph.pm:2703:					my $diff = @{$ci2->Edges} - @{$ci1->Edges};
SpeciesGraph.pm:2707:                        if ( @{$ci1->Edges} )
SpeciesGraph.pm:2709:						    my $wild = $ci1->Edges->[0];
SpeciesGraph.pm:2718:                            {   # *? (equivalent) wildcard requires $diff>-1, #c2 edges >= #c1 edges - 1 (for wildcard)
SpeciesGraph.pm:2719:							    next unless ( $diff >= -1 );
SpeciesGraph.pm:2732:                    if (ref $adj1->{$p1} eq 'HASH')
SpeciesGraph.pm:2735:                        foreach my $q1 ( keys %{$adj1->{$p1}} )
SpeciesGraph.pm:2744:						    unless ( (ref $adj2->{$p2} eq 'HASH') and (exists $adj2->{$p2}{$q2}) )
SpeciesGraph.pm:2753:					$comp1_ptr->[$ic1] = $ic2;
SpeciesGraph.pm:2763:						$comp2_used->[$ic2] = 1;
SpeciesGraph.pm:2786:				$comp1_ptr->[$ic1] = 0;
SpeciesGraph.pm:2787:				--$ic1;
SpeciesGraph.pm:2788:				$comp2_used->[ $comp1_ptr->[$ic1] ] = 0;    # Reset pointers at new level
SpeciesGraph.pm:2789:				++($comp1_ptr->[$ic1]);
SpeciesGraph.pm:2797:				my $map = Map->new;
SpeciesGraph.pm:2798:				$map->Source($sg1);
SpeciesGraph.pm:2799:				$map->Target($sg2);
SpeciesGraph.pm:2809:						$mapf{"$im.$ic"} = sprintf "%d.%d", $im2, $comp1_ptr->[$ic];
SpeciesGraph.pm:2812:				$map->MapF( {%mapf} );
SpeciesGraph.pm:2815:				if ($sg1->MatchOnce)
SpeciesGraph.pm:2820:					++($comp1_ptr->[$ic1]);
SpeciesGraph.pm:2836:		$components1 = $molecules1->[$im1]->Components;
SpeciesGraph.pm:2862:	$map->Source($sg);
SpeciesGraph.pm:2863:	$map->Target($sg);    
SpeciesGraph.pm:2864:    $map->MapF( $mapF );
SpeciesGraph.pm:2865:    $map->MapR( $mapR );
SpeciesGraph.pm:2869:    foreach my $mol ( @{$sg->Molecules} )
SpeciesGraph.pm:2871:        $mapF->{$im} = $im;
SpeciesGraph.pm:2872:        $mapR->{$im} = $im;
SpeciesGraph.pm:2875:        foreach my $comp ( @{$mol->Components} )
SpeciesGraph.pm:2878:            $mapF->{$ptr} = $ptr;
SpeciesGraph.pm:2879:            $mapR->{$ptr} = $ptr;
SpeciesGraph.pm:2897:# (Map) = SpeciesGraph1->findMaps(SpeciesGraph2)
SpeciesGraph.pm:2917:	my $labelmap1 = $sg1->buildLabelMap();
SpeciesGraph.pm:2918:	my $labelmap2 = $sg2->buildLabelMap();
SpeciesGraph.pm:2921:	my $map = Map->new;
SpeciesGraph.pm:2922:	$map->Source($sg1);
SpeciesGraph.pm:2923:	$map->Target($sg2);
SpeciesGraph.pm:2924:	$map->MapF( buildPointerMap( $labelmap1, $labelmap2 ) );
SpeciesGraph.pm:2925:	$map->MapR( buildPointerMap( $labelmap2, $labelmap1 ) );
SpeciesGraph.pm:2940:		{   # map label index1 to label index2, or -1 if index2 is not defined
SpeciesGraph.pm:2941:			$pmap->{ $lmap1->{$label} } =
SpeciesGraph.pm:2942:			  ( exists $lmap2->{$label} ) ? $lmap2->{$label} : -1;
SpeciesGraph.pm:2958:#   repository or any distribution prior to 2.1.8   --Justin, 16 Dec 2010
SpeciesGraph.pm:2969:  # labelmap = SpeciesGraph->buildLabelMap()
SpeciesGraph.pm:2979:	for ( my $im = 0 ; $im < @{$sg->Molecules} ; ++$im )
SpeciesGraph.pm:2981:		my $mol     = $sg->Molecules->[$im];    # molecule to be labeled
SpeciesGraph.pm:2986:		foreach my $comp ( @{ $mol->Components } )
SpeciesGraph.pm:2988:            if ( defined $comp->Label )
SpeciesGraph.pm:2989:			{   push @clabels, '%' . $comp->Label;   }
SpeciesGraph.pm:2991:            {   push @clabels, $comp->Name;   }
SpeciesGraph.pm:2996:        if ( defined $mol->Label )
SpeciesGraph.pm:2998:            $mlabel = '%' . $mol->Label;
SpeciesGraph.pm:3002:			$mlabel = $mol->Name;
SpeciesGraph.pm:3007:		# write map:  molecule label -> molecule index
SpeciesGraph.pm:3008:		$labelmap->{$mlabel} = $im;
SpeciesGraph.pm:3024:            #$labelmap->{$clabel} = "$im.$ic";
SpeciesGraph.pm:3034:			$labelmap->{$clabel} = "$im.$ic";
SpeciesGraph.pm:3057:	if ( $cmp = ( $a->Name cmp $b->Name ) )
SpeciesGraph.pm:3061:	if ( $cmp = (@{$a->Components} <=> @{$b->Components}) )
SpeciesGraph.pm:3065:	if ( defined $a->Compartment )
SpeciesGraph.pm:3067:		unless ( defined $b->Compartment ) { return 1 };
SpeciesGraph.pm:3068:		if ( $cmp = ($a->Compartment->Name cmp $b->Compartment->Name) )
SpeciesGraph.pm:3071:	elsif ( defined $b->Compartment )
SpeciesGraph.pm:3073:		return -1;
SpeciesGraph.pm:3077:    for ( my $ic = 0;  $ic < @{$a->Components};  ++$ic )
SpeciesGraph.pm:3079:		if ( $cmp = cmp_component($a->Components->[$ic], $b->Components->[$ic]) )
SpeciesGraph.pm:3111:	if ( $cmp = ($a->Name cmp $b->Name) )
SpeciesGraph.pm:3115:    if ( defined $a->State )
SpeciesGraph.pm:3117:        unless ( defined $b->State ) { return 1; }
SpeciesGraph.pm:3118:	    if ( $cmp = ($a->State cmp $b->State) )
SpeciesGraph.pm:3121:    elsif ( defined $b->State )
SpeciesGraph.pm:3123:        return -1;
SpeciesGraph.pm:3129:	if ( $cmp = ( @{$b->Edges} <=> @{$a->Edges} ) )
SpeciesGraph.pm:3215:		if ( $cmp = ($a->[$i]->[0] <=> $b->[$i]->[0]) ) { return $cmp; }
SpeciesGraph.pm:3216:		if ( $cmp = ($a->[$i]->[1] <=> $b->[$i]->[1]) ) { return $cmp; }
SpeciesList.pm:41:    return scalar @{$slist->Array};
SpeciesList.pm:47:    return scalar @{$slist->Array};
SpeciesList.pm:60:    my @newarr = sort {$a->SpeciesGraph->StringExact cmp $b->SpeciesGraph->StringExact} @{$slist->Array};
SpeciesList.pm:61:    $slist->Array(\@newarr);
SpeciesList.pm:63:    foreach my $spec ( @{$slist->Array} )
SpeciesList.pm:65:        $spec->Index($ispec);
SpeciesList.pm:87:    if( $sg->IsCanonical ) {  $check_iso = 0;  }
SpeciesList.pm:90:    my $sstring = $sg->StringID;
SpeciesList.pm:91:    if ( exists $slist->Hash->{$sstring} )
SpeciesList.pm:97:            foreach my $spec2 ( @{$slist->Hash->{$sstring}} )
SpeciesList.pm:99:	            if ($sg->isomorphicTo($spec2->SpeciesGraph))
SpeciesList.pm:108:            $spec = $slist->Hash->{$sstring}->[0];
SpeciesList.pm:128:    if ( exists $slist->Hash_exact->{$sstring} )
SpeciesList.pm:130:        $species = $slist->Hash_exact->{$sstring};
SpeciesList.pm:144:    my $spec = Species->new;
SpeciesList.pm:145:    push @{$slist->Array}, $spec;
SpeciesList.pm:146:    push @{$slist->Hash->{$sg->StringID}}, $spec;
SpeciesList.pm:148:    $slist->Hash_exact->{$sg->StringExact} = $spec;
SpeciesList.pm:149:    $spec->SpeciesGraph($sg);
SpeciesList.pm:150:    $spec->Concentration($conc);
SpeciesList.pm:151:    $spec->Index( scalar @{$slist->Array} );
SpeciesList.pm:152:    $spec->RulesApplied(0);
SpeciesList.pm:154:    $sg->Species($spec);
SpeciesList.pm:165:    splice( @{$slist->Array}, $spec->Index-1, 1 );
SpeciesList.pm:168:    my $harray = $slist->Hash->{$spec->SpeciesGraph->StringID};
SpeciesList.pm:171:        if ($spec == $harray->[$i])
SpeciesList.pm:176:                undef $slist->Hash->{$spec->SpeciesGraph->StringID};
SpeciesList.pm:183:    undef $slist->Hash_exact->{$spec->SpeciesGraph->StringExact};
SpeciesList.pm:207:    $sg = SpeciesGraph->new;
SpeciesList.pm:209:    $err = $sg->readString( \$string, $clist, 1, '^\s+', $mtlist );
SpeciesList.pm:212:    if ( $sg->isNull() )
SpeciesList.pm:219:    my $existing= $slist->lookup($sg);
SpeciesList.pm:222:        my $sstring = $sg->StringExact;
SpeciesList.pm:223:        my $index = $existing->Index;
SpeciesList.pm:232:        my $expr = Expression->new();
SpeciesList.pm:233:        if ( my $err = $expr->readString(\$string, $plist) ) {  return ('', $err);  }
SpeciesList.pm:234:        if ( $expr->Type eq 'NUM' )
SpeciesList.pm:236:            $conc = $expr->evaluate();
SpeciesList.pm:240:            $conc = $expr->getName( $plist, 'InitialConc' );
SpeciesList.pm:249:    $slist->add($sg, $conc);
SpeciesList.pm:261:# string = $slist->writeBNGL( *Array, [*ParamList, bool, *Hash] ) 
SpeciesList.pm:271:    $slist->checkOrInitConcentrations($conc);
SpeciesList.pm:275:    foreach my $spec ( @{$slist->Array} )
SpeciesList.pm:278:        $len += defined $spec->SpeciesGraph->Name        ? length $spec->SpeciesGraph->Name        : 0;
SpeciesList.pm:279:        $len += defined $spec->SpeciesGraph->StringExact ? length $spec->SpeciesGraph->StringExact : 0;
SpeciesList.pm:284:    foreach my $spec ( @{$slist->Array} )
SpeciesList.pm:286:        if ( $user_params->{'pretty_formatting'} )
SpeciesList.pm:292:            $out .= sprintf "%5d ", $spec->Index;
SpeciesList.pm:296:        my $sexact = $spec->SpeciesGraph->toString();
SpeciesList.pm:297:        $out .= sprintf "%-${maxlen}s", $sexact;
SpeciesList.pm:299:        my $c = $conc->[ $spec->Index - 1 ];
SpeciesList.pm:326:    $slist->checkOrInitConcentrations($conc);
SpeciesList.pm:329:    foreach my $spec (@{$slist->Array})
SpeciesList.pm:332:        my $sexact= $spec->SpeciesGraph->toStringSSCMol();
SpeciesList.pm:336:        $c = $conc->[$idx];
SpeciesList.pm:353:    foreach my $i ( $i_start..$#{$slist->Array} )
SpeciesList.pm:355:        my $spec = $slist->Array->[$i];
SpeciesList.pm:356:        printf $fh "%5d %s %s\n", $i-$i_start+1, $spec->SpeciesGraph->StringExact, $spec->Concentration;
SpeciesList.pm:371:    $slist->checkOrInitConcentrations($conc);
SpeciesList.pm:376:    foreach my $spec (@{$slist->Array})
SpeciesList.pm:378:        $string.= $spec->toXML("  ".$indent, $conc->[$i]);
SpeciesList.pm:404:    foreach my $species ( @{ $slist->Array } )
SpeciesList.pm:407:        my $species_vector = $stoich_hash->{ $species->Index };
SpeciesList.pm:410:        if ( $species->SpeciesGraph->Fixed )
SpeciesList.pm:420:                my $stoich = $species_vector->{$i_rxn};
SpeciesList.pm:423:                my $i_rxn0 = $i_rxn - 1;
SpeciesList.pm:424:                my $rxn = $rlist->Array->[$i_rxn0];
SpeciesList.pm:428:                {   $species_deriv .= " +" . $rxn->getCVodeName();             }
SpeciesList.pm:431:                elsif ( $stoich == -1 )
SpeciesList.pm:432:                {   $species_deriv .= " -" . $rxn->getCVodeName();             }
SpeciesList.pm:434:                {   $species_deriv .= " +$stoich.0*" . $rxn->getCVodeName();   }
SpeciesList.pm:436:                {   $species_deriv .= " $stoich.0*" . $rxn->getCVodeName();    } 
SpeciesList.pm:448:        $deriv_defs .= $indent . $species->getCVodeDerivName() . " = $species_deriv;\n"; 
SpeciesList.pm:472:    foreach my $species ( @{ $slist->Array } )
SpeciesList.pm:475:        my $species_vector = $stoich_hash->{ $species->Index };
SpeciesList.pm:478:        if ( $species->SpeciesGraph->Fixed )
SpeciesList.pm:488:                my $stoich = $species_vector->{$i_rxn};
SpeciesList.pm:491:                my $i_rxn0 = $i_rxn - 1;
SpeciesList.pm:492:                my $rxn = $rlist->Array->[$i_rxn0];
SpeciesList.pm:496:                {   $species_deriv .= " +" . $rxn->getMatlabName();             }
SpeciesList.pm:499:                elsif ( $stoich == -1 )
SpeciesList.pm:500:                {   $species_deriv .= " -" . $rxn->getMatlabName();             }
SpeciesList.pm:502:                {   $species_deriv .= " +$stoich.0*" . $rxn->getMatlabName();   }
SpeciesList.pm:504:                {   $species_deriv .= " $stoich.0*" . $rxn->getMatlabName();    } 
SpeciesList.pm:516:        $deriv_defs .= $indent . $species->getMatlabDerivName() . " = $species_deriv;\n"; 
SpeciesList.pm:536:    my $plist = $model->ParamList;
SpeciesList.pm:543:    # TODO: this matlab output is a hack.  improve this.  --justin
SpeciesList.pm:548:    foreach my $param ( @{$plist->Array} )
SpeciesList.pm:550:        if ( $param->Type eq 'Constant' )
SpeciesList.pm:552:            $ref_map->{ $param->Name } = "params($m_idx)";
SpeciesList.pm:560:    foreach my $species ( @{ $slist->Array } )
SpeciesList.pm:562:        push @species_names, "'" . $species->SpeciesGraph->StringExact . "'";    
SpeciesList.pm:563:        (my $param) = $plist->lookup( $species->Concentration );    
SpeciesList.pm:568:            $species_init .= $indent . "species_init($m_idx) = " . $param->toString( $plist, 0, 2 ) . ";\n";          
SpeciesList.pm:572:            $species_init .= $indent . "species_init($m_idx) = " . $species->Concentration . ";\n";
SpeciesList.pm:580:        my $matlab_ref = $ref_map->{$pname};
SpeciesList.pm:593:    foreach my $species ( @{ $slist->Array } )
SpeciesList.pm:595:    		push @species_names, "'" . $species->SpeciesGraph->StringExact . "'";
SpeciesList.pm:603:# If @$conc is non-empty, then check if @$conc is okay (pad with zeros if too short)
SpeciesList.pm:605:# $slist->checkOrInitConcentrations( $conc )
SpeciesList.pm:614:        if ( @$conc > @{$slist->Array} )
SpeciesList.pm:615:        {   # this case is not well-defined
SpeciesList.pm:616:            exit_error( "SpeciesList->initConcentrations(): concentration array is longer than species array" );
SpeciesList.pm:618:        elsif ( @$conc < @{$slist->Array} )
SpeciesList.pm:620:            my $n_zeros = @{$slist->Array} - @$conc;
SpeciesList.pm:626:        @$conc = map {$_->Concentration} @{$slist->Array};
Species.pm:37:    my $conc   = @_ ? shift @_ : $spec->Concentration;
Species.pm:38:    my $id = @_ ? shift : "S".$spec->Index;  # what's this for??
Species.pm:47:    $attributes .= " name=\"" . $spec->SpeciesGraph->toString() . "\"";
Species.pm:50:    my $string = $spec->SpeciesGraph->toXML($indent,$type,$id,$attributes);
Species.pm:64:    my $offset = -1;
Species.pm:65:    return 'NV_Ith_S(species,' . ($species->Index + $offset). ')';
Species.pm:71:    my $offset = -1;
Species.pm:72:    return 'NV_Ith_S(Dspecies,' . ($species->Index + $offset). ')';
Species.pm:85:    return 'species(' . ($species->Index + $offset). ')';
Species.pm:92:    return 'Dspecies(' . ($species->Index + $offset). ')';
XMLReader.pm:15:		_tree => XML::TreePP->new((force_hash=>['Model']))->parsefile($_[1])
XMLReader.pm:23:	return $self->{_tree}->{sbml}->{Model}->{ListOfParameters}->{Parameter};
XMLReader.pm:28:	return $self->{_tree}->{sbml}->{Model}->{ListOfParameters}->{Parameter}->[$idx];
XMLReader.pm:34:	return $self->{_tree}->{sbml}->{Model}->{ListOfParameters}->{Parameter};
XMLReader.pm:39:	return $self->{_tree}->{sbml}->{Model}->{ListOfMoleculeTypes}->{MoleculeType} ;
XMLReader.pm:44:	return $self->{_tree}->{sbml}->{Model}->{ListOfSpecies}->{Species};
XMLReader.pm:49:	return $self->{_tree}->{sbml}->{Model}->{ListOfCompartments}->{Compartment};
XMLReader.pm:54:	return $self->{_tree}->{sbml}->{Model}->{ListOfReactionRules}->{ReactionRule};
XMLReader.pm:59:	return $self->{_tree}->{sbml}->{Model}->{ListOfObservables}->{Observable};
XMLReader.pm:64:	return $self->{_tree}->{sbml}->{Model}->{ListOfFunctions};
