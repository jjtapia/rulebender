package resultviewer.ui;

import java.awt.Dimension;
import java.io.*;
import java.util.ArrayList;

import javax.swing.JFrame;
import javax.swing.JPanel;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.ToolBarManager;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.source.SourceViewer;
import org.eclipse.jface.viewers.*;
import org.eclipse.jface.window.*;
import org.eclipse.swt.*;
import org.eclipse.swt.custom.CTabFolder;
import org.eclipse.swt.custom.CTabItem;
import org.eclipse.swt.custom.SashForm;
import org.eclipse.swt.custom.StyleRange;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.events.MenuAdapter;
import org.eclipse.swt.events.MenuEvent;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseListener;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.*;
import org.jfree.chart.JFreeChart;

import resultviewer.tree.*;
import resultviewer.tree.TreeNode;

import resultviewer.data.*;
import resultviewer.graph.*;
import resultviewer.text.*;
import visualizationviewer.VisualizationViewerController;

public class ResultViewer extends ApplicationWindow {

	// variables
	private String rootDirPath; // root path of result viewer
	private String expandFilePath; // default opened file path
	private String expandFileType; // default opened file type (GDAT, SCAN)
	private Rectangle windowBounds; // window bounds of result viewer
	private String chartType; // line or point or line & point
	private ArrayList<String> chartTypeList; // used for comparing multiple
												// files
	private String xAxisType; // linear or log
	private String yAxisType; // linear or log

	// color used to highlight selected text in NET file
	private static Color color_DarkGoldenrod1 = new Color(null, 255, 185, 15);

	// composites
	private SashForm sash_form_bottom, sash_form_top;
	private CTabFolder textFolder, outlineFolder, explorerFolder;
	private Composite outlineCmp_cdat, outlineCmp_gdat, outlineCmp_compare;

	// components
	private TreeViewer file_tv; // explorer tree
	private TreeNode rootNode;
	private CTabItem elementOutline;
	private CheckboxTreeViewer element_tv_cdat;
	private CheckboxTreeViewer element_tv_gdat;
	private TreeViewer element_tv_net;
	private ArrayList<CheckboxTreeViewer> element_tv_compare; // compare
																// multiple
																// files
	private CustomizedChartComposite curChartPanel; // chart panel for CDAT,
													// GDAT, SCAN files
	private FileNode curFileNode; // current viewing file
	private ArrayList<FileNode> curFileList; // opened files in tabs

	// to show the graph generated by Prefuse
	private JFrame jf;
	// private JPanel panel;

	// syntax highlighting configure for NET and BNGL files
	private NETConfiguration netConfig;
	private NETDocumentProvider netProvider;

	// menus
	private Menu textFolderMenu; // control items on textFolder
	private Menu textMenu; // control text for NET file
	private Menu explorerMenu; // control items in explorer

	public ResultViewer(String rootDirPath, String expandFilePath,
			String expandFileType, Rectangle bounds) {
		super(null);

		this.rootDirPath = rootDirPath;
		this.expandFilePath = expandFilePath;
		this.expandFileType = expandFileType;
		this.windowBounds = bounds;

		// create a NETDocumentProvider object
		netProvider = new NETDocumentProvider();

		// create a list to store current fileNodes
		curFileList = new ArrayList<FileNode>();

		chartTypeList = new ArrayList<String>();

		addStatusLine(); // status line
		// addMenuBar(); // menu bar
		// addToolBar(SWT.FLAT | SWT.WRAP); // tool bar
	}

	/*
	 * Create the contents
	 * 
	 * @see
	 * org.eclipse.jface.window.Window#createContents(org.eclipse.swt.widgets
	 * .Composite)
	 */
	protected Control createContents(Composite parent) {

		getShell().setText("Simulation Results Viewer"); // window title

		sash_form_bottom = new SashForm(parent, SWT.HORIZONTAL | SWT.NULL);

		sash_form_top = new SashForm(sash_form_bottom, SWT.VERTICAL | SWT.NULL);

		explorerFolder = new CTabFolder(sash_form_top, SWT.BORDER);
		initExplorerFolder();

		outlineFolder = new CTabFolder(sash_form_top, SWT.BORDER);
		initOutlineFolder();

		sash_form_top.setWeights(new int[] { 9, 11 });
		sash_form_top.setMaximizedControl(explorerFolder);

		textFolder = new CTabFolder(sash_form_bottom, SWT.BORDER);
		initTextFolder();

		sash_form_bottom.setWeights(new int[] { 2, 5 });

		// open default file
		openDefaultFile(this.expandFilePath, this.expandFileType);

		parent.setBounds(this.windowBounds);

		return parent;
	}

	/*
	 * Create the menu bar
	 * 
	 * @see org.eclipse.jface.window.ApplicationWindow#createMenuManager()
	 */
	protected MenuManager createMenuManager() {
		MenuManager bar_menu = new MenuManager("");

		MenuManager file_menu = new MenuManager("&File");
		MenuManager edit_menu = new MenuManager("&Edit");
		MenuManager view_menu = new MenuManager("&View");

		bar_menu.add(file_menu);
		bar_menu.add(edit_menu);
		bar_menu.add(view_menu);

		return bar_menu;
	}

	/*
	 * Create the tool bar
	 * 
	 * @see org.eclipse.jface.window.ApplicationWindow#createToolBarManager(int)
	 */
	protected ToolBarManager createToolBarManager(int style) {

		ToolBarManager tool_bar_manager = new ToolBarManager(style);

		return tool_bar_manager;
	}

	/*
	 * Initialize explorer tab folder
	 */
	private void initExplorerFolder() {
		CTabItem modelExplorer = new CTabItem(explorerFolder, SWT.NONE);
		modelExplorer.setText("Explorer");
		file_tv = new TreeViewer(explorerFolder, SWT.FULL_SELECTION | SWT.MULTI);
		file_tv.setContentProvider(new TreeContentProvider());
		file_tv.setLabelProvider(new TreeLabelProvider());
		rootNode = new FolderNode(new File(rootDirPath));
		file_tv.setInput(rootNode);
		modelExplorer.setControl(file_tv.getControl());

		// set default selection on modelExplorer tab item
		explorerFolder.setSelection(modelExplorer);

		// add listener to maximize the tab
		explorerFolder.addListener(SWT.MouseDoubleClick, new Listener() {

			public void handleEvent(Event event) {
				// maximize explorerFolder
				Control curControl = sash_form_top.getChildren()[0];
				if (sash_form_top.getMaximizedControl() == null) {
					sash_form_top.setMaximizedControl(curControl);
				} else {
					sash_form_top.setMaximizedControl(null);
				}
			}

		});

		// add selection listener
		file_tv.addSelectionChangedListener(new ISelectionChangedListener() {

			public void selectionChanged(SelectionChangedEvent event) {
				IStructuredSelection selection = (IStructuredSelection) event
						.getSelection();

				if (selection.isEmpty()) {
					return;
				}
				// set message on status line
				if (selection.size() == 1) {
					setStatus("Selected: "
							+ ((TreeNode) selection.getFirstElement())
									.getName());
				} else {
					setStatus("Selected " + selection.size() + " files");
				}
			}
		});

		// add double click listener
		file_tv.addDoubleClickListener(new IDoubleClickListener() {
			public void doubleClick(DoubleClickEvent e) {
				IStructuredSelection selection = (IStructuredSelection) e
						.getSelection();

				if (selection.isEmpty()) {
					return;
				}

				if (curFileNode != null
						&& !curFileNode.getName().contains("Compare")
						&& (curFileNode.getName().endsWith(".gdat") || curFileNode
								.getName().endsWith(".scan"))) {
					DATFileData data = (DATFileData) curFileNode.getFileData();
					// store current expanded nodes for GDAT and SCAN
					data.setExpandedElements(element_tv_gdat
							.getExpandedElements());
					// store current grayed nodes for GDAT and SCAN
					data.setGrayedElements(element_tv_gdat.getGrayedElements());
				}

				Object[] selections = selection.toArray();
				for (int sel = 0; sel < selections.length; sel++) {
					TreeNode node = (TreeNode) selections[sel];
					openFileItem(node);
				}
			}
		});

		initExplorerMenu();
		// attach menu to explorerFolder
		file_tv.getControl().setMenu(explorerMenu);

	}

	/*
	 * Initialize text tab folder
	 */
	private void initTextFolder() {
		textFolder.setSimple(true);
		textFolder
				.setBackground(new Color(Display.getCurrent(), 240, 240, 240));

		// add listener to maximize the tab
		textFolder.addListener(SWT.MouseDoubleClick, new Listener() {

			public void handleEvent(Event event) {
				// maximize textFolder
				Control curControl = sash_form_bottom.getChildren()[1];
				if (sash_form_bottom.getMaximizedControl() == null) {
					sash_form_bottom.setMaximizedControl(curControl);
				} else {
					sash_form_bottom.setMaximizedControl(null);
				}
			}

		});

		// add selection listener for textFolder
		textFolder.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {

				if (curFileNode == null) {
					return;
				}

				if ((!curFileNode.getName().contains("Compare"))
						&& (curFileNode.getName().endsWith(".gdat") || curFileNode
								.getName().endsWith(".scan"))) {
					DATFileData data = (DATFileData) curFileNode.getFileData();
					// store current expanded nodes for GDAT and SCAN
					data.setExpandedElements(element_tv_gdat
							.getExpandedElements());
					// store current grayed nodes for GDAT and SCAN
					data.setGrayedElements(element_tv_gdat.getGrayedElements());

				}

				// change to new tab item
				CTabItem item = (CTabItem) event.item;
				String fileName = item.getText();
				String filePath = (String) item.getData("path");

				setStatus("File: " + fileName);

				// set the curFieNode be the current selection
				curFileNode = getFileNode(filePath);
				if (fileName.endsWith(".cdat") || fileName.endsWith(".gdat")
						|| fileName.endsWith(".scan")) {
					// CDAT & GDAT & SCAN
					int chartIndex = ((Composite) item.getControl())
							.getChildren().length - 1;
					curChartPanel = (CustomizedChartComposite) ((Composite) item
							.getControl()).getChildren()[chartIndex];

				}

				updateOutline();
			}
		});

		// initialize textFolderMenu
		initTextFolderMenu();
		textFolder.setMenu(textFolderMenu);

		// initialize textMenu;
		initTextMenu();

	}

	/*
	 * Initialize outline tab folder
	 */
	private void initOutlineFolder() {
		outlineFolder.setSimple(true);
		elementOutline = new CTabItem(outlineFolder, SWT.NONE);
		elementOutline.setText("Outline");

		// set default selection on elementOutline tab item
		outlineFolder.setSelection(elementOutline);

		// add listener to maxmize the tab
		outlineFolder.addListener(SWT.MouseDoubleClick, new Listener() {
			public void handleEvent(Event event) {
				// maximize outlineFolder
				Control curControl = sash_form_top.getChildren()[1]; // outlineFolder
				if (sash_form_top.getMaximizedControl() == null) {
					sash_form_top.setMaximizedControl(curControl);
				} else {
					sash_form_top.setMaximizedControl(null);
				}

			}

		});

		createNETOutline();
		createCDATOutline();
		createGDATOutline();
		createCompareOutline();

	}

	/*
	 * Create the outline for NET files
	 */
	private void createNETOutline() {
		// create the tree viewer
		element_tv_net = new TreeViewer(outlineFolder, SWT.FULL_SELECTION);
		element_tv_net.getTree()
				.setLayoutData(new GridData(GridData.FILL_BOTH));
		element_tv_net.setContentProvider(new TreeContentProvider());
		element_tv_net.setLabelProvider(new TreeLabelProvider());

		// nothing in the tree at the beginning
		element_tv_net.setInput(null);

		element_tv_net
				.addSelectionChangedListener(new ISelectionChangedListener() {

					public void selectionChanged(SelectionChangedEvent event) {

						IStructuredSelection selection = (IStructuredSelection) event
								.getSelection();

						// empty selection
						if (selection.isEmpty())
							return;

						NETItemNode node = (NETItemNode) selection
								.getFirstElement();
						NETFileData data = (NETFileData) curFileNode
								.getFileData();

						// reset selection and reveal range
						int offset = node.getOffset();
						int length = node.getLength();
						data.getSourceViewer().revealRange(offset, length);

						// store the selected item
						data.setSelectedItem(node.getName());

						setStatus("Link to the part of \"" + node.getName()
								+ "\"");
					}

				});
	}

	/*
	 * Create outline for CDAT files
	 */
	private void createCDATOutline() {

		outlineCmp_cdat = new Composite(outlineFolder, SWT.NONE);
		outlineCmp_cdat.setLayout(new GridLayout(2, false));

		// element tree viewer
		element_tv_cdat = new CheckboxTreeViewer(outlineCmp_cdat);
		GridData gridData = new GridData(GridData.FILL_BOTH);
		gridData.horizontalSpan = 2;
		element_tv_cdat.getTree().setLayoutData(gridData);
		element_tv_cdat.setContentProvider(new TreeContentProvider());
		element_tv_cdat.setLabelProvider(new TreeLabelProvider());

		// nothing in the tree at the beginning
		element_tv_cdat.setInput(null);

		// select all button

		final Button selectAllBnt = new Button(outlineCmp_cdat, SWT.CHECK);
		selectAllBnt.setText("Check/Uncheck All");
		gridData = new GridData();
		gridData.horizontalSpan = 2;
		selectAllBnt.setLayoutData(gridData);

		chartType = "line";

		// chart type
		new Label(outlineCmp_cdat, SWT.NONE).setText("Chart");

		final Combo chartTypeBnt = new Combo(outlineCmp_cdat, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		chartTypeBnt.add("line");
		chartTypeBnt.add("point");
		chartTypeBnt.add("line & point");
		chartTypeBnt.setText(chartType);

		// add listener
		chartTypeBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {
				chartType = chartTypeBnt.getText();

				DATFileData data = (DATFileData) curFileNode.getFileData(); // plot
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));

				data.setChartType(chartType);
			}
		});

		// add selection listener for clear button
		selectAllBnt.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent arg0) {
				boolean selected = selectAllBnt.getSelection();
				if (selected == true) {
					// select all

					element_tv_cdat.setAllChecked(true);

					Object[] elements = element_tv_cdat.getCheckedElements();

					// GDAT & SCAN
					DATFileData data = (DATFileData) curFileNode.getFileData();

					// check all the ObservableNode
					for (int i = 0; i < elements.length; i++) {
						TreeNode node = (TreeNode) elements[i];
						if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
							data.addCheckedSpecies((SpeciesNode) elements[i]);
						}
					}
					// set allChecked be true
					data.setAllChecked(true);
					// set some nodes be checked
					element_tv_cdat.setCheckedElements(data.getCheckedSpecies());
					// plot the chart
					curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
							yAxisType, chartType));

				} else {
					// remove all

					Object[] elements = element_tv_cdat.getCheckedElements();

					// GDAT & SCAN
					DATFileData data = (DATFileData) curFileNode.getFileData();

					// uncheck all the ObservableNode
					for (int i = 0; i < elements.length; i++) {
						TreeNode node = (TreeNode) elements[i];
						if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
							data.removeCheckedSpecies((SpeciesNode) elements[i]);
						}
					}
					// set allChecked be false
					data.setAllChecked(false);
					// set some nodes be checked
					element_tv_cdat.setCheckedElements(data.getCheckedSpecies());
					curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
							yAxisType, chartType));

					element_tv_cdat.setAllChecked(false);

					data.setSelectedSpeciesName(null);
					element_tv_cdat.setSelection(null);
				}
			}

		});

		// set selection be empty when user click on empty area
		element_tv_cdat.getTree().addMouseListener(new MouseListener() {

			public void mouseDoubleClick(MouseEvent arg0) {

			}

			public void mouseDown(MouseEvent event) {

				Point p = Display.getCurrent().getCursorLocation();
				p = element_tv_cdat.getTree().toControl(p);
				// get the item corresponding the click point
				TreeItem item = element_tv_cdat.getTree().getItem(p);
				if (item == null) {
					element_tv_cdat.setSelection(null);
					DATChart.resetChart(curChartPanel.getChart()); // reset
																	// chart
				}
			}

			public void mouseUp(MouseEvent arg0) {

			}

		});

		// add check listener for element_tv_cdat
		element_tv_cdat.addCheckStateListener(new ICheckStateListener() {

			public void checkStateChanged(CheckStateChangedEvent event) {
				// get data
				DATFileData data = (DATFileData) curFileNode.getFileData();
				// SpeciesNode
				TreeNode node = (TreeNode) event.getElement();

				if (event.getChecked() == true) {
					data.addCheckedSpecies((SpeciesNode) event.getElement());
					setStatus("Checked:" + node.getName());
				}
				// not check
				else if (event.getChecked() == false) {
					data.removeCheckedSpecies((SpeciesNode) event.getElement());
					setStatus("Unchecked:" + node.getName());
				}

				// update chart
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));

				// mark line
				String labelName = data.getSelectedSpeciesName();
				if (labelName != null) {
					String key = labelName.split(" ")[0]; // index
					DATChart.markSelectedLine(curChartPanel.getChart(), key);

					element_tv_cdat.setSelection(new StructuredSelection(
							findSpeciesNode(element_tv_cdat, labelName)), true);
				}
			}
		});

		// add selection listener for element_tv_cdat
		element_tv_cdat
				.addSelectionChangedListener(new ISelectionChangedListener() {

					public void selectionChanged(SelectionChangedEvent event) {

						IStructuredSelection selection = (IStructuredSelection) event
								.getSelection();

						DATFileData data = ((DATFileData) curFileNode
								.getFileData());

						// empty selection
						if (selection.isEmpty()) {
							return;
						}

						String labelName = selection.getFirstElement()
								.toString();

						boolean drawGraph = true;
						if (labelName.equals(data.getSelectedSpeciesName())) {
							// selected species not changed
							drawGraph = false;
						}

						String key = labelName.split(" ")[0]; // index

						// store the name of the selected species
						data.setSelectedSpeciesName(labelName);
						// mark selected line
						DATChart.markSelectedLine(curChartPanel.getChart(), key);

						if (drawGraph && labelName.contains(" ")) {
							// show the species graph in a JFrame
							ArrayList<String> itemList = new ArrayList<String>();
							String item = "species\t" + labelName;
							itemList.add(item);
							showGraph(itemList);
							setStatus("Selected: " + labelName);
						}
					}
				});
	}

	private void createGDATOutline() {
		outlineCmp_gdat = new Composite(outlineFolder, SWT.NONE);
		outlineCmp_gdat.setLayout(new GridLayout(2, false));

		// element tree viewer
		element_tv_gdat = new CheckboxTreeViewer(outlineCmp_gdat);
		GridData gridData = new GridData(GridData.FILL_BOTH);
		gridData.horizontalSpan = 2;
		element_tv_gdat.getTree().setLayoutData(gridData);
		element_tv_gdat.setContentProvider(new TreeContentProvider());
		element_tv_gdat.setLabelProvider(new TreeLabelProvider());

		// nothing in the tree at the beginning
		element_tv_gdat.setInput(null);

		// select all button
		final Button selectAllBnt = new Button(outlineCmp_gdat, SWT.CHECK);
		selectAllBnt.setText("Check/Uncheck All");
		gridData = new GridData();

		selectAllBnt.setLayoutData(gridData);
		gridData.horizontalSpan = 2;
		chartType = "line";

		// chart type
		new Label(outlineCmp_gdat, SWT.NONE).setText("Chart");

		final Combo chartTypeBnt = new Combo(outlineCmp_gdat, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		chartTypeBnt.add("line");
		chartTypeBnt.add("point");
		chartTypeBnt.add("line & point");
		chartTypeBnt.setText(chartType);

		// add listener
		chartTypeBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {
				chartType = chartTypeBnt.getText();

				DATFileData data = (DATFileData) curFileNode.getFileData(); // plot
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));

				data.setChartType(chartType);
			}
		});

		// add listener for selectAllBnt
		selectAllBnt.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent arg0) {
				boolean selected = selectAllBnt.getSelection();
				if (selected == true) {
					// select all

					element_tv_gdat.setAllChecked(true);

					Object[] elements = element_tv_gdat.getCheckedElements();

					// GDAT & SCAN
					DATFileData data = (DATFileData) curFileNode.getFileData();

					// check all the ObservableNode
					for (int i = 0; i < elements.length; i++) {
						TreeNode node = (TreeNode) elements[i];
						if (node.getNodeType().equalsIgnoreCase(
								"ObservableNode")) {
							data.addCheckedObservable((ObservableNode) elements[i]);
						}
					}
					// set allChecked be true
					data.setAllChecked(true);
					// set some nodes be checked
					element_tv_gdat.setCheckedElements(data
							.getCheckedObservable());
					// plot the chart
					curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
							yAxisType, chartType));

				} else {
					// remove all

					Object[] elements = element_tv_gdat.getCheckedElements();

					// GDAT & SCAN
					DATFileData data = (DATFileData) curFileNode.getFileData();

					// uncheck all the ObservableNode
					for (int i = 0; i < elements.length; i++) {
						TreeNode node = (TreeNode) elements[i];
						if (node.getNodeType().equalsIgnoreCase(
								"ObservableNode")) {
							data.removeCheckedObservable((ObservableNode) elements[i]);
						}
					}
					// set allChecked be false
					data.setAllChecked(false);
					// set some nodes be checked
					element_tv_gdat.setCheckedElements(data
							.getCheckedObservable());
					curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
							yAxisType, chartType));

					element_tv_gdat.setAllChecked(false);

					data.setSelectedObservableName(null);
					data.setSelectedSpeciesName(null);
					element_tv_gdat.setSelection(null);
				}
			}

		});

		// set selection be empty when user click on empty area
		element_tv_gdat.getTree().addMouseListener(new MouseListener() {

			public void mouseDoubleClick(MouseEvent arg0) {

			}

			public void mouseDown(MouseEvent event) {

				Point p = Display.getCurrent().getCursorLocation();
				p = element_tv_gdat.getTree().toControl(p);
				// get the item corresponding the click point
				TreeItem item = element_tv_gdat.getTree().getItem(p);

				if (item == null) {
					element_tv_gdat.setSelection(null);
					DATChart.resetChart(curChartPanel.getChart()); // reset
																	// chart
				}
			}

			public void mouseUp(MouseEvent arg0) {

			}

		});

		// add tree listener to disable some checkboxes

		element_tv_gdat.addTreeListener(new ITreeViewerListener() {

			public void treeCollapsed(TreeExpansionEvent arg0) {

			}

			public void treeExpanded(TreeExpansionEvent event) {
				TreeNode node = (TreeNode) event.getElement();
				if (node.getNodeType().equalsIgnoreCase("ObservableNode")
						|| node.getNodeType().equalsIgnoreCase(
								"SpeciesFolderNode")) {
					Object[] children = node.getChildrenArray();
					for (int i = 0; i < children.length; i++) {
						element_tv_gdat.setGrayChecked(children[i], true);
					}
				}

			}

		});

		element_tv_gdat.addCheckStateListener(new ICheckStateListener() {

			public void checkStateChanged(CheckStateChangedEvent event) {
				// get node
				TreeNode node = (TreeNode) event.getElement();
				// get data
				DATFileData data = (DATFileData) curFileNode.getFileData();

				if (event.getChecked() == true) {
					if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
						// SpeciesNode
						element_tv_gdat.setGrayChecked(node, true);
					} else if (node.getNodeType().equalsIgnoreCase(
							"ObservableNode")) {
						// ObservableNode
						data.addCheckedObservable((ObservableNode) event
								.getElement());
						setStatus("Checked:" + node.getName());
					} else if (node.getNodeType().equalsIgnoreCase(
							"SpeciesFolderNode")) {
						// SpeciesFolderNode
						element_tv_gdat.setGrayChecked(node, true);
					}

				}
				// not check
				else if (event.getChecked() == false) {
					if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
						// SpeciesNode
						element_tv_gdat.setGrayChecked(node, true);
					} else if (node.getNodeType().equalsIgnoreCase(
							"ObservableNode")) {
						// ObservableNode
						data.removeCheckedObservable((ObservableNode) event
								.getElement());
						setStatus("Unchecked:" + node.getName());
					} else if (node.getNodeType().equalsIgnoreCase(
							"SpeciesFolderNode")) {
						// SpeciesFolderNode
						element_tv_gdat.setGrayChecked(node, true);
					}
				}

				// plot
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));

				// mark line
				String labelName = data.getSelectedObservableName();
				if (labelName != null) {
					DATChart.markSelectedLine(curChartPanel.getChart(),
							labelName);

					// set selection
					element_tv_gdat.setSelection(new StructuredSelection(
							findObservableNode(element_tv_gdat, labelName)),
							true);
				}
			}
		});

		// add selection changed listener

		element_tv_gdat
				.addSelectionChangedListener(new ISelectionChangedListener() {

					public void selectionChanged(SelectionChangedEvent event) {

						IStructuredSelection selection = (IStructuredSelection) event
								.getSelection();

						DATFileData data = ((DATFileData) curFileNode
								.getFileData());

						TreeNode node = (TreeNode) selection.getFirstElement();

						// empty selection
						if (selection.isEmpty()) {
							return;
						}

						String labelName = node.getName();

						if (node.getNodeType().equalsIgnoreCase(
								"ObservableNode")) {
							// if selected observable changed
							if (!labelName.equals(data
									.getSelectedObservableName())) {
								// store the name of the selected species
								data.setSelectedObservableName(labelName);
							}

							// mark selected line
							DATChart.markSelectedLine(curChartPanel.getChart(),
									labelName);
							setStatus("Selected: " + labelName);
						} else {
							// SpeciesFolderNode or SpeciesNode
							String str = "species\t";
							if (node.getNodeType().equalsIgnoreCase(
									"SpeciesFolderNode")) {
								str = "pattern\t-1 ";
							}

							if (labelName.equals(data.getSelectedSpeciesName())) {
								// selected species not change
								return;
							}

							// store the name of the selected species
							data.setSelectedSpeciesName(labelName);

							// show the species graph in a JFrame
							ArrayList<String> itemList = new ArrayList<String>();
							String item = str + labelName;
							itemList.add(item);

							showGraph(itemList);
							setStatus("Selected: " + labelName);
						}
					}

				});

	}

	private void createCompareOutline() {
		outlineCmp_compare = new Composite(outlineFolder, SWT.NONE);
		outlineCmp_compare.setLayout(new GridLayout(2, false));

		element_tv_compare = new ArrayList<CheckboxTreeViewer>();

		for (int i = 0; i < 2; i++) {

			Text filePath = new Text(outlineCmp_compare, SWT.READ_ONLY
					| SWT.MULTI);
			filePath.setText("");
			GridData gridData = new GridData(GridData.FILL_HORIZONTAL);
			gridData.horizontalSpan = 2;
			filePath.setLayoutData(gridData);

			// element tree viewer
			final CheckboxTreeViewer cur_compare = new CheckboxTreeViewer(
					outlineCmp_compare);
			gridData = new GridData(GridData.FILL_BOTH);
			gridData.horizontalSpan = 2;
			cur_compare.getTree().setLayoutData(gridData);
			cur_compare.setContentProvider(new TreeContentProvider());
			cur_compare.setLabelProvider(new TreeLabelProvider());

			// nothing in the tree at the beginning
			cur_compare.setInput(null);

			// select all button
			final Button selectAllBnt = new Button(outlineCmp_compare,
					SWT.CHECK);
			selectAllBnt.setText("Check/Uncheck All");
			gridData = new GridData();

			selectAllBnt.setLayoutData(gridData);
			gridData.horizontalSpan = 2;
			chartTypeList.add("line");

			// chart type
			new Label(outlineCmp_compare, SWT.NONE).setText("Chart");

			final Combo chartTypeBnt = new Combo(outlineCmp_compare,
					SWT.DROP_DOWN | SWT.READ_ONLY);
			chartTypeBnt.add("line");
			chartTypeBnt.add("point");
			chartTypeBnt.add("line & point");
			chartTypeBnt.setText(chartTypeList.get(i));
			chartTypeBnt.setData("index", i);

			// set index for cur_compare
			cur_compare.setData("index", i);

			element_tv_compare.add(cur_compare);

			// add listener
			chartTypeBnt.addSelectionListener(new SelectionAdapter() {
				public void widgetSelected(SelectionEvent e) {
					chartTypeList.set((Integer) chartTypeBnt.getData("index"),
							chartTypeBnt.getText());

					DATComparisonData data = (DATComparisonData) curFileNode
							.getFileData(); // plot
					curChartPanel.setChart(DATComparisonChart.plotChart(data,
							chartTypeList));
					curChartPanel.setChart(DATComparisonChart.plotChart(
							curChartPanel.getChart(), xAxisType, yAxisType));
				}
			});

			// add listener for selectAllBnt
			selectAllBnt.addSelectionListener(new SelectionAdapter() {

				public void widgetSelected(SelectionEvent arg0) {
					boolean selected = selectAllBnt.getSelection();
					if (selected == true) {
						// select all

						cur_compare.setAllChecked(true);

						Object[] elements = cur_compare.getCheckedElements();

						// Compare
						DATComparisonData data = (DATComparisonData) curFileNode
								.getFileData();

						// check all the ObservableNode
						for (int i = 0; i < elements.length; i++) {
							TreeNode node = (TreeNode) elements[i];
							if (node.getNodeType().equalsIgnoreCase(
									"ObservableNode")) {
								data.addCheckedObservable(
										(Integer) cur_compare.getData("index"),
										(ObservableNode) elements[i]);
							}
							if (node.getNodeType().equalsIgnoreCase(
									"SpeciesNode")) {
								data.addCheckedSpecies(
										(Integer) cur_compare.getData("index"),
										(SpeciesNode) elements[i]);
							}
						}
						// set allChecked be true
						data.setAllChecked(
								(Integer) cur_compare.getData("index"), true);
						// set some nodes be checked
						cur_compare.setCheckedElements(data
								.getCheckedElements((Integer) cur_compare
										.getData("index")));
						// plot the chart
						curChartPanel.setChart(DATComparisonChart.plotChart(
								data, chartTypeList));
						curChartPanel.setChart(DATComparisonChart.plotChart(
								curChartPanel.getChart(), xAxisType, yAxisType));

					} else {
						// remove all

						Object[] elements = cur_compare.getCheckedElements();

						// Compare
						DATComparisonData data = (DATComparisonData) curFileNode
								.getFileData();

						// uncheck all the ObservableNode
						for (int i = 0; i < elements.length; i++) {
							TreeNode node = (TreeNode) elements[i];
							if (node.getNodeType().equalsIgnoreCase(
									"ObservableNode")) {
								data.removeCheckedObservable(
										(Integer) cur_compare.getData("index"),
										(ObservableNode) elements[i]);
							}
							if (node.getNodeType().equalsIgnoreCase(
									"SpeciesNode")) {
								data.removeCheckedSpecies(
										(Integer) cur_compare.getData("index"),
										(SpeciesNode) elements[i]);
							}
						}

						// set allChecked be false
						data.setAllChecked(
								(Integer) cur_compare.getData("index"), false);
						// set some nodes be checked
						cur_compare.setCheckedElements(data
								.getCheckedElements((Integer) cur_compare
										.getData("index")));
						// plot the chart
						curChartPanel.setChart(DATComparisonChart.plotChart(
								data, chartTypeList));
						curChartPanel.setChart(DATComparisonChart.plotChart(
								curChartPanel.getChart(), xAxisType, yAxisType));

						cur_compare.setAllChecked(false);
						cur_compare.setSelection(null);
					}
				}

			});

			// set selection be empty when user click on empty area
			cur_compare.getTree().addMouseListener(new MouseListener() {

				public void mouseDoubleClick(MouseEvent arg0) {

				}

				public void mouseDown(MouseEvent event) {

					Point p = Display.getCurrent().getCursorLocation();
					p = cur_compare.getTree().toControl(p);
					// get the item corresponding the click point
					TreeItem item = cur_compare.getTree().getItem(p);
					if (item == null) {
						int cur_index = (Integer) cur_compare.getData("index");

						cur_compare.setSelection(null);
						DATComparisonChart.resetChart(curChartPanel.getChart(),
								cur_index); // reset chart
					}
				}

				public void mouseUp(MouseEvent arg0) {

				}

			});

			// add tree listener to disable some checkboxes

			cur_compare.addTreeListener(new ITreeViewerListener() {

				public void treeCollapsed(TreeExpansionEvent arg0) {

				}

				public void treeExpanded(TreeExpansionEvent event) {
					TreeNode node = (TreeNode) event.getElement();
					if (node.getNodeType().equalsIgnoreCase("ObservableNode")
							|| node.getNodeType().equalsIgnoreCase(
									"SpeciesFolderNode")) {
						Object[] children = node.getChildrenArray();
						for (int i = 0; i < children.length; i++) {
							cur_compare.setGrayChecked(children[i], true);
						}
					}
				}

			});

			cur_compare.addCheckStateListener(new ICheckStateListener() {

				public void checkStateChanged(CheckStateChangedEvent event) {

					// index for current compare tree viewer
					int cur_index = (Integer) cur_compare.getData("index");
					// get node
					TreeNode node = (TreeNode) event.getElement();
					// get data
					DATComparisonData data = (DATComparisonData) curFileNode
							.getFileData();

					if (event.getChecked() == true) {
						if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
							// SpeciesNode
							if (((TreeNode) node.getParent()).getParent() != null) {
								// GDAT
								cur_compare.setGrayChecked(node, true);

							} else {
								// CDAT
								data.addCheckedSpecies(cur_index,
										(SpeciesNode) event.getElement());
								setStatus("Checked:" + node.getName());
							}

						} else if (node.getNodeType().equalsIgnoreCase(
								"ObservableNode")) {
							// ObservableNode
							data.addCheckedObservable(cur_index,
									(ObservableNode) event.getElement());
							setStatus("Checked:" + node.getName());
						} else if (node.getNodeType().equalsIgnoreCase(
								"SpeciesFolderNode")) {
							// SpeciesFolderNode
							cur_compare.setGrayChecked(node, true);
						}

					}
					// not check
					else if (event.getChecked() == false) {
						if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
							// SpeciesNode
							if (((TreeNode) node.getParent()).getParent() != null) {
								// GDAT
								cur_compare.setGrayChecked(node, true);

							} else {
								// CDAT
								data.removeCheckedSpecies(cur_index,
										(SpeciesNode) event.getElement());
								setStatus("Unchecked:" + node.getName());
							}

						} else if (node.getNodeType().equalsIgnoreCase(
								"ObservableNode")) {
							// ObservableNode
							data.removeCheckedObservable(cur_index,
									(ObservableNode) event.getElement());

							setStatus("Unchecked:" + node.getName());
						} else if (node.getNodeType().equalsIgnoreCase(
								"SpeciesFolderNode")) {
							// SpeciesFolderNode
							cur_compare.setGrayChecked(node, true);

						}
					}
					curChartPanel.setChart(DATComparisonChart.plotChart(data,
							chartTypeList));
					curChartPanel.setChart(DATComparisonChart.plotChart(
							curChartPanel.getChart(), xAxisType, yAxisType));

					// mark line
					if (data.getSelectedSpeciesName(cur_index) != null) {
						String labelName = data
								.getSelectedSpeciesName(cur_index);
						String key = labelName.split(" ")[0];
						if (key != null) {
							DATComparisonChart.markSelectedLine(
									curChartPanel.getChart(), cur_index, key);

							cur_compare.setSelection(new StructuredSelection(
									findSpeciesNode(cur_compare, labelName)),
									true);

						}
					}
				}
			});

			// add selection changed listener

			cur_compare
					.addSelectionChangedListener(new ISelectionChangedListener() {

						public void selectionChanged(SelectionChangedEvent event) {

							IStructuredSelection selection = (IStructuredSelection) event
									.getSelection();

							DATComparisonData data = ((DATComparisonData) curFileNode
									.getFileData());

							TreeNode node = (TreeNode) selection
									.getFirstElement();

							// empty selection
							if (selection.isEmpty()) {
								return;
							}

							String labelName = node.getName();
							int cur_index = (Integer) cur_compare
									.getData("index");

							if (node.getNodeType().equalsIgnoreCase(
									"ObservableNode")) {
								// if selected observable changed
								if (!labelName.equals(data
										.getSelectedObservableName(cur_index))) {
									// store the name of the selected species
									data.setSelectedObservableName(cur_index,
											labelName);
								}

								// mark selected line
								DATComparisonChart.markSelectedLine(
										curChartPanel.getChart(), cur_index,
										labelName);
								setStatus("Selected: "
										+ data.getFileName(cur_index) + " "
										+ labelName);
							} else {
								// SpeciesFolderNode or SpeciesNode
								String str = "species\t";
								if (node.getNodeType().equalsIgnoreCase(
										"SpeciesFolderNode")) {
									str = "pattern\t-1 ";
								}

								if (labelName.equals(data
										.getSelectedSpeciesName(cur_index))) {
									// selected species not change
									return;
								}

								// store the name of the selected species
								data.setSelectedSpeciesName(cur_index,
										labelName);

								if (data.getFileName(cur_index).endsWith(
										".cdat")) {
									// CDAT

									String key = labelName.split(" ")[0]; // index

									// mark selected line
									DATComparisonChart.markSelectedLine(
											curChartPanel.getChart(),
											cur_index, key);
								}

								if (labelName.contains(" ")) {
									// show the species graph in a JFrame
									ArrayList<String> itemList = new ArrayList<String>();
									String item = str + labelName;
									itemList.add(item);

									showGraph(itemList);
									setStatus("Selected: "
											+ data.getFileName(cur_index) + " "
											+ labelName);
								}
							}
						}

					});
		}

	}

	/*
	 * Create a menu to control files in Explorer
	 */
	private void initExplorerMenu() {
		explorerMenu = new Menu(getShell(), SWT.POP_UP);

		final MenuItem openMenuItem = new MenuItem(explorerMenu, SWT.PUSH);
		openMenuItem.setText("Open");

		new MenuItem(explorerMenu, SWT.SEPARATOR);

		final MenuItem compareCurMenuItem = new MenuItem(explorerMenu, SWT.PUSH);
		compareCurMenuItem.setText("Compare With Current");

		final MenuItem compareTwoMenuItem = new MenuItem(explorerMenu, SWT.PUSH);
		compareTwoMenuItem.setText("Compare Two Files");

		new MenuItem(explorerMenu, SWT.SEPARATOR);

		final MenuItem refreshMenuItem = new MenuItem(explorerMenu, SWT.PUSH);
		refreshMenuItem.setText("Refresh");

		final MenuItem deleteMenuItem = new MenuItem(explorerMenu, SWT.PUSH);
		deleteMenuItem.setText("Delete");

		explorerMenu.addMenuListener(new MenuAdapter() {
			public void menuShown(MenuEvent e) {
				Point p = Display.getCurrent().getCursorLocation();
				p = file_tv.getTree().toControl(p);
				// get the item corresponding the click point
				TreeItem item = file_tv.getTree().getItem(p);
				if (item == null) {
					// disable deleteMenuItem
					deleteMenuItem.setEnabled(false);
					openMenuItem.setEnabled(false);
					compareCurMenuItem.setEnabled(false);
					compareTwoMenuItem.setEnabled(false);
				} else {
					// enable deleteMenuItem
					deleteMenuItem.setEnabled(true);
					openMenuItem.setEnabled(true);
					compareCurMenuItem.setEnabled(true);
					compareTwoMenuItem.setEnabled(true);
				}
			}
		});

		// add listener for openMenuItem
		openMenuItem.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent event) {
				IStructuredSelection selection = (IStructuredSelection) file_tv
						.getSelection();

				if (selection.isEmpty()) {
					return;
				}

				if (curFileNode != null
						&& (curFileNode.getName().endsWith(".gdat") || curFileNode
								.getName().endsWith(".scan"))) {
					DATFileData data = (DATFileData) curFileNode.getFileData();
					// store current expanded nodes for GDAT and SCAN
					data.setExpandedElements(element_tv_gdat
							.getExpandedElements());
					// store current grayed nodes for GDAT and SCAN
					data.setGrayedElements(element_tv_gdat.getGrayedElements());
				}

				Object[] selections = selection.toArray();
				for (int sel = 0; sel < selections.length; sel++) {
					TreeNode node = (TreeNode) selections[sel];
					openFileItem(node);
				}
			}

		});

		// add listener for compareCurMenuItem
		compareCurMenuItem.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent event) {
				IStructuredSelection selection = (IStructuredSelection) file_tv
						.getSelection();

				if (curFileNode == null) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("No Opened File");
					msgBox.open();
					return;
				}

				TreeNode node = (TreeNode) selection.getFirstElement();

				String curFileName = curFileNode.getName();
				if (curFileName.contains("Compare")
						|| !(curFileName.endsWith(".cdat")
								|| curFileName.endsWith(".gdat") || curFileName
									.endsWith(".scan"))) {
					// only support compare CDAT GDAT SCAN
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Supported file types: CDAT, GDAT and SCAN");
					msgBox.open();
					return;
				}

				// do nothing for FolderNode
				if (node.getNodeType().equals("FolderNode")) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Cannot compare folder with file");
					msgBox.open();
					return;
				}

				String selectFileName = node.getName();
				if (!(selectFileName.endsWith(".cdat")
						|| selectFileName.endsWith(".gdat") || selectFileName
						.endsWith(".scan"))) {
					// only support compare CDAT GDAT SCAN
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Supported file types: CDAT, GDAT and SCAN");
					msgBox.open();
					return;
				}

				// get file type
				String type1 = curFileNode.getName().substring(
						curFileNode.getName().indexOf(".") + 1);
				String type2 = node.getName().substring(
						node.getName().indexOf(".") + 1);

				// get DATFileData
				DATFileData data1 = (DATFileData) curFileNode.getFileData();
				DATFileData data2 = (DATFileData) ((FileNode) node)
						.getFileData();

				// create a compare data object
				DATComparisonData compData = new DATComparisonData(type1,
						data1, type2, data2);

				if (compData.isComparable() == false) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Different X axis");
					msgBox.open();
					return;
				}

				// create a new compare tab item
				createComparisonItem(curFileNode, (FileNode) node, compData);

			}

		});

		// add listener for compareTwoMenuItem
		compareTwoMenuItem.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent event) {
				IStructuredSelection selection = (IStructuredSelection) file_tv
						.getSelection();

				if (selection.size() < 2) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Please select two files");
					msgBox.open();
					return;
				}

				Object[] nodeArray = selection.toArray();

				TreeNode node1 = (TreeNode) nodeArray[0];
				TreeNode node2 = (TreeNode) nodeArray[1];

				// do nothing for FolderNode
				if (node1.getNodeType().equals("FolderNode")
						|| node2.getNodeType().equals("FolderNode")) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Cannot compare folder with file/folder");
					msgBox.open();
					return;
				}

				String curFileName = node1.getName();
				if (curFileName.contains("Compare")
						|| !(curFileName.endsWith(".cdat")
								|| curFileName.endsWith(".gdat") || curFileName
									.endsWith(".scan"))) {
					// only support compare CDAT GDAT SCAN
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Supported file types: CDAT, GDAT and SCAN");
					msgBox.open();
					return;
				}

				String selectFileName = node2.getName();
				if (!(selectFileName.endsWith(".cdat")
						|| selectFileName.endsWith(".gdat") || selectFileName
						.endsWith(".scan"))) {
					// only support compare CDAT GDAT SCAN
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Supported file types: CDAT, GDAT and SCAN");
					msgBox.open();
					return;
				}

				// get file type
				String type1 = node1.getName().substring(
						node1.getName().indexOf(".") + 1);
				String type2 = node2.getName().substring(
						node2.getName().indexOf(".") + 1);

				// get DATFileData
				DATFileData data1 = (DATFileData) ((FileNode) node1)
						.getFileData();
				DATFileData data2 = (DATFileData) ((FileNode) node2)
						.getFileData();

				// create a compare data object
				DATComparisonData compData = new DATComparisonData(type1,
						data1, type2, data2);

				if (compData.isComparable() == false) {
					MessageBox msgBox = new MessageBox(getShell(),
							SWT.ICON_ERROR | SWT.OK);
					msgBox.setText("Error");
					msgBox.setMessage("Different X axis");
					msgBox.open();
					return;
				}

				sash_form_top.setMaximizedControl(null);
				// create a new compare tab item
				createComparisonItem((FileNode) node1, (FileNode) node2,
						compData);

			}

		});

		// add listener for refreshMenuItem
		refreshMenuItem.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent arg0) {
				refresh();
			}

		});

		deleteMenuItem.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent event) {
				IStructuredSelection selection = (IStructuredSelection) file_tv
						.getSelection();

				// pop up a delte confirm window
				MessageBox deleteBox = new MessageBox(getShell(),
						SWT.ICON_WARNING | SWT.OK | SWT.CANCEL);
				deleteBox.setText("Confirm Delete");
				if (selection.size() > 1) {
					deleteBox.setMessage("Are you sure you want to delete "
							+ selection.size() + " elements?");
				} else if (selection.size() == 1) {
					deleteBox.setMessage("Are you sure you want to delete "
							+ ((TreeNode) selection.getFirstElement())
									.getName());
				}
				int buttonID = deleteBox.open();

				if (buttonID == SWT.CANCEL) {
					// cancel delete
					return;
				}

				// user confirmed delete
				Object[] deleteItems = selection.toArray();
				if (deleteItems != null) {
					for (int i = 0; i < deleteItems.length; i++) {
						TreeNode node = (TreeNode) deleteItems[i];

						// delete files
						if (node.getNodeType().equals("FolderNode")) {
							// FolderNode
							setStatus("Delete Directory: " + node.getName());

							deleteFileFromExplorer(node);

						} else if (node.getNodeType().equals("FileNode")) {
							// FileNode
							setStatus("Delete File: " + node.getName());

							deleteFileFromExplorer(node);
						}

					}
				}
			}

		});
	}

	/*
	 * Delete file or directory from in explorer
	 */
	private void deleteFileFromExplorer(TreeNode node) {
		if (node.getNodeType().equals("FileNode")) {
			// close this file if opened
			String filePath = ((FileNode) node).getPath();
			int indexOfItem = getIndexOfItemByPath(filePath);
			if (indexOfItem != -1) {
				textFolder.getItem(indexOfItem).dispose();
			}

			// delete the file from the tree viewer
			TreeNode parent = (TreeNode) node.getParent();
			parent.removeChild(node);
			file_tv.remove(node);
			file_tv.refresh();

			// delete actual file on the disk
			File curFile = new File(filePath);
			curFile.delete();
		} else if (node.getNodeType().equals("FolderNode")) {
			// deal with all the files or directories in the directory
			while (node.getChildren().size() > 0) {

				TreeNode curChild = (TreeNode) node.getChildren().get(0);
				deleteFileFromExplorer(curChild);
			}

			// deal with the directory itself

			// delete the directory from the tree viewer
			TreeNode parent = (TreeNode) node.getParent();
			parent.removeChild(node);
			file_tv.remove(node);
			file_tv.refresh();

			// delete actual directory on the disk
			File curDir = new File(((FolderNode) node).getPath());
			String[] otherChildren = curDir.list();
			for (int i = 0; i < otherChildren.length; i++) {
				File curF = new File(curDir, otherChildren[i]);
				curF.delete();
			}
			curDir.delete();
		}
	}

	/*
	 * Create a menu to control tab items on textFolder. - Close All
	 */

	private void initTextFolderMenu() {

		textFolderMenu = new Menu(getShell(), SWT.POP_UP);
		final MenuItem closeAllMenuItem = new MenuItem(textFolderMenu, SWT.PUSH);
		closeAllMenuItem.setText("Close All");

		// add listener for textFolderMenu
		textFolderMenu.addMenuListener(new MenuAdapter() {
			public void menuShown(MenuEvent e) {
				Point p = Display.getCurrent().getCursorLocation();
				p = textFolder.toControl(p);
				final CTabItem item = textFolder.getItem(p);
				if (item == null) {
					textFolderMenu.setVisible(false);
					return;
				}
			}
		});

		// add listener for closeAllMenuItem
		closeAllMenuItem.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent arg0) {
				while (textFolder.getItemCount() > 0) {
					textFolder.getItem(0).dispose();
				}
			}

		});
	}

	/*
	 * Create a menu to control text for NET file. Show graph based on selected
	 * Text. - Species ID - Species Expression
	 */

	private void initTextMenu() {
		textMenu = new Menu(getShell(), SWT.POP_UP);

		// draw graph based on species ID
		final MenuItem speciesIDItem = new MenuItem(textMenu, SWT.PUSH);
		speciesIDItem.setText("Species ID");

		// draw graph based on species Expression
		final MenuItem speciesExpItem = new MenuItem(textMenu, SWT.PUSH);
		speciesExpItem.setText("Expression");

		// add listener for speciesIDItem
		speciesIDItem.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent arg0) {
				NETFileData data = (NETFileData) curFileNode.getFileData();
				Point p = data.getSourceViewer().getSelectedRange();
				String idStr = "";

				// get the selected text
				for (int i = p.x; i < p.x + p.y; i++) {
					idStr += Character
							.toString(data.getFileContent().charAt(i));
				}

				try {
					int id = Integer.parseInt(idStr);
					String exp = data.getSpeciesExpByID(id);

					if (exp == null) {
						setStatus("No Correspoding Species: " + idStr);
						return;
					}

					// show the species graph in a JFrame
					ArrayList<String> itemList = new ArrayList<String>();
					String item = "species\t" + idStr + " " + exp;
					itemList.add(item);
					showGraph(itemList);
					setStatus("Species " + id + ": " + exp);
				} catch (NumberFormatException exception) {
					setStatus("Not an Integer Number : " + idStr);
				}

			}

		});

		// add listener for speciesExpItem
		speciesExpItem.addSelectionListener(new SelectionAdapter() {

			public void widgetSelected(SelectionEvent arg0) {
				NETFileData data = (NETFileData) curFileNode.getFileData();
				Point p = data.getSourceViewer().getSelectedRange();
				String expression = "";

				// get the selected text
				for (int i = p.x; i < p.x + p.y; i++) {
					expression += Character.toString(data.getFileContent()
							.charAt(i));
				}

				// empty expression
				if (expression.length() == 0) {
					setStatus("Illegal Expression : " + expression);
					return;
				}
				// no ')' at the end
				if (expression.charAt(expression.length() - 1) != ')') {
					setStatus("Incomplete Expression : " + expression);
					return;
				}
				// contains illegal characters
				if (expression.contains("+") || expression.contains("-")
						|| expression.contains(">") || expression.contains("<")) {
					setStatus("Illegal Expression : " + expression);
					return;
				}

				Integer id = data.getSpeciesIDByExp(expression);
				ArrayList<String> itemList = new ArrayList<String>();
				if (id == null) {

					String item = "pattern\t" + "-1" + " " + expression;
					itemList.add(item);
					if (showGraph(itemList) == true) {
						setStatus("Pattern : " + expression);
					} else {
						// can not be parsed as species
						setStatus("Illegal Expression : " + expression);
					}
				} else {
					// show the graph
					setStatus("Species " + id + ": " + expression);
					String item = "species\t" + id.toString() + " "
							+ expression;
					itemList.add(item);
					showGraph(itemList);
				}
			}

		});
	}

	/*
	 * create a chartItem on textFolder when the corresponding file was double
	 * clicked
	 */
	private void createChartItem(FileNode fNode) {

		CTabItem chartItem = new CTabItem(textFolder, SWT.CLOSE);
		chartItem.setText(fNode.getName());

		// set tool tip
		String tooltip = fNode.getPath().substring(rootDirPath.length());
		chartItem.setToolTipText(tooltip);

		chartItem.setData("path", fNode.getPath());

		Composite chartCmp = new Composite(textFolder, SWT.NONE);
		chartCmp.setLayout(new GridLayout(6, false));

		// control options

		xAxisType = "linear";
		yAxisType = "linear";

		// x axis scale
		new Label(chartCmp, SWT.NONE).setText("\tX Axis");

		final Combo xAxisBnt = new Combo(chartCmp, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		xAxisBnt.add("linear");
		xAxisBnt.add("log");
		xAxisBnt.setText(xAxisType);

		// y axis scale
		new Label(chartCmp, SWT.NONE).setText("\tY Axis");

		final Combo yAxisBnt = new Combo(chartCmp, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		yAxisBnt.add("linear");
		yAxisBnt.add("log");
		yAxisBnt.setText(yAxisType);

		xAxisBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {
				if (xAxisType.equals(xAxisBnt.getText())) {
					return;
				}
				xAxisType = xAxisBnt.getText();

				DATFileData data = (DATFileData) curFileNode.getFileData(); // plot
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));
				// curChartPanel.redraw();
				updateOutline();
			}
		});
		yAxisBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {
				if (yAxisType.equals(yAxisBnt.getText())) {
					return;
				}

				yAxisType = yAxisBnt.getText();

				DATFileData data = (DATFileData) curFileNode.getFileData(); // plot
				curChartPanel.setChart(DATChart.plotChart(data, xAxisType,
						yAxisType, chartType));
				// curChartPanel.redraw();
				updateOutline();
			}
		});

		// create the chart using JFreeChart
		JFreeChart chart = DATChart.plotChart(
				(DATFileData) fNode.getFileData(), xAxisType, yAxisType,
				chartType);
		CustomizedChartComposite chartPanel = new CustomizedChartComposite(
				chartCmp, SWT.NONE, chart, true);
		GridData griddata = new GridData(GridData.FILL_BOTH);
		griddata.horizontalSpan = 6;
		chartPanel.setLayoutData(griddata);
		curChartPanel = chartPanel;

		// set control
		chartItem.setControl(chartCmp);
		textFolder.setSelection(chartItem);

		DATFileData data = (DATFileData) fNode.getFileData();
		data.setSelectedObservableName(null);
		data.setSelectedSpeciesName(null);
		data.setExpandedElements(null);

		// reset chart type
		chartType = "line";
		data.setChartType("line");

		updateOutline();

		if (fNode.getName().endsWith(".gdat")
				|| fNode.getName().endsWith(".scan")) {

			// update the "check/uncheck all" button
			data.setAllChecked(true);
			((Button) outlineCmp_gdat.getChildren()[1]).setSelection(true);

			// update checkbox in the tree
			element_tv_gdat.setAllChecked(true);

			Object[] elements = element_tv_gdat.getCheckedElements();

			for (int i = 0; i < elements.length; i++) {
				TreeNode node = (TreeNode) elements[i];
				if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
					// SpeciesNode
					data.addCheckedSpecies((SpeciesNode) elements[i]);
				} else if (node.getNodeType()
						.equalsIgnoreCase("ObservableNode")) {
					// ObservableNode
					data.addCheckedObservable((ObservableNode) elements[i]);
				} else {
				}
			}

		} else if (fNode.getName().endsWith(".cdat")) {
			// update the "check/uncheck all" button
			data.setAllChecked(true);
			((Button) outlineCmp_cdat.getChildren()[1]).setSelection(true);

			// update checkbox in the tree
			element_tv_cdat.setAllChecked(true);

			Object[] elements = element_tv_cdat.getCheckedElements();

			for (int i = 0; i < elements.length; i++) {
				TreeNode node = (TreeNode) elements[i];
				if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
					// SpeciesNode
					data.addCheckedSpecies((SpeciesNode) elements[i]);
				} else {
				}
			}

		}

		// plot chart
		curChartPanel.setChart(DATChart.plotChart(data, xAxisType, yAxisType,
				chartType));

		// add close listener for tabItem
		chartItem.addDisposeListener(new DisposeListener() {

			public void widgetDisposed(DisposeEvent event) {
				CTabItem item = (CTabItem) event.getSource();

				String filePath = (String) item.getData("path");

				// remove the fileNode from curFileList
				removeFileNode(filePath);

				if (curFileList.size() == 0) {
					curFileNode = null;
					if (elementOutline != null
							&& elementOutline.isDisposed() == false) {
						elementOutline.setControl(null);
						// maximize explorerFolder
						sash_form_top.setMaximizedControl(sash_form_top
								.getChildren()[0]);
					}
				}
			}

		});

	}

	/*
	 * create a netItem on textFolder when the corresponding file was double
	 * clicked
	 */
	private void createNetItem(FileNode fNode) {

		// open the text with TextViewer
		CTabItem netItem = new CTabItem(textFolder, SWT.CLOSE);
		netItem.setText(fNode.getName());

		// set tool tip
		String tooltip = fNode.getPath().substring(rootDirPath.length());
		netItem.setToolTipText(tooltip);

		netItem.setData("path", fNode.getPath());

		// use SourceViewer to control the NET file
		final SourceViewer sv = new SourceViewer(textFolder, null, SWT.BORDER
				| SWT.READ_ONLY | SWT.V_SCROLL | SWT.H_SCROLL);

		if (netConfig == null)
			netConfig = new NETConfiguration();

		final NETFileData data = (NETFileData) fNode.getFileData();
		Document document = netProvider.createDocument(data.getFileContent());
		sv.setDocument(document); // connect sourceViewer with document
		sv.configure(netConfig); // set configuration

		// get the style ranges
		final StyleRange[] styleRanges = sv.getTextWidget().getStyleRanges();

		data.setSourceViewer(sv); // store the sourceViewer in NETFileData

		netItem.setControl(sv.getControl());
		textFolder.setSelection(netItem);

		if (fNode.getName().endsWith(".net")) {
			// set pop up menu
			sv.getControl().setMenu(textMenu);
		}

		data.setSelectedItem(null);

		// add post selection listener
		sv.addPostSelectionChangedListener(new ISelectionChangedListener() {

			public void selectionChanged(SelectionChangedEvent event) {

				// reset all style ranges
				sv.getTextWidget().setStyleRanges(styleRanges);

				// set background color for all the text which is the same as
				// the selected one
				String fileContent = data.getFileContent();
				Point p = sv.getSelectedRange();
				if (p.y == 0) {
					int lineNum = sv.getTextWidget().getLineAtOffset(p.x) + 1;
					setStatus("Line: " + Integer.toString(lineNum));
					return;
				}

				String selected = "";

				// get the selected string
				for (int i = p.x; i < p.x + p.y; i++) {
					selected += fileContent.charAt(i);
				}

				// whitespace
				if (selected.equals(" ")) {
					return;
				}

				// multiple line
				if (selected.contains("\n")) {
					return;
				}

				// set status line
				setStatus("Select Text: " + selected);

				int selectOffset = 0;
				int subStringOffset = 0;
				while (selectOffset != -1) {
					// find the new text position
					selectOffset = fileContent.substring(subStringOffset)
							.indexOf(selected);

					if (selectOffset != -1) {
						// create a style range
						final StyleRange sr = new StyleRange();
						sr.background = color_DarkGoldenrod1;
						sr.start = subStringOffset + selectOffset;
						sr.length = p.y;
						sv.getTextWidget().setStyleRange(sr);
					}

					// update the substring offset
					subStringOffset += selectOffset + p.y;
				}

			}

		});

		updateOutline();

		// add close listener for tabItem
		netItem.addDisposeListener(new DisposeListener() {

			public void widgetDisposed(DisposeEvent event) {
				CTabItem item = (CTabItem) event.getSource();
				String filePath = (String) item.getData("path");

				// remove the fileNode from curFileList
				removeFileNode(filePath);

				if (curFileList.size() == 0) {
					curFileNode = null;
					if (elementOutline != null
							&& elementOutline.isDisposed() == false) {
						elementOutline.setControl(null);
						// maximize explorerFolder
						sash_form_top.setMaximizedControl(sash_form_top
								.getChildren()[0]);
					}
				}
			}

		});

	}

	private void createLOGItem(FileNode fNode) {
		// open the text with TextViewer
		CTabItem LOGItem = new CTabItem(textFolder, SWT.CLOSE);
		LOGItem.setText(fNode.getName());

		// set tool tip
		String tooltip = fNode.getPath().substring(rootDirPath.length());
		LOGItem.setToolTipText(tooltip);

		LOGItem.setData("path", fNode.getPath());

		// use SourceViewer to control the NET file
		final SourceViewer sv = new SourceViewer(textFolder, null,
				SWT.READ_ONLY | SWT.V_SCROLL | SWT.H_SCROLL);

		final LogFileData data = (LogFileData) fNode.getFileData();
		Document document = new Document(data.getFileContent());
		sv.setDocument(document); // connect sourceViewer with document

		LOGItem.setControl(sv.getControl());
		textFolder.setSelection(LOGItem);

		// add close listener for tabItem
		LOGItem.addDisposeListener(new DisposeListener() {

			public void widgetDisposed(DisposeEvent event) {
				CTabItem item = (CTabItem) event.getSource();
				String filePath = (String) item.getData("path");

				// remove the fileNode from curFileList
				removeFileNode(filePath);

				if (curFileList.size() == 0) {
					curFileNode = null;
					if (elementOutline != null
							&& elementOutline.isDisposed() == false) {
						elementOutline.setControl(null);
						// maximize explorerFolder
						sash_form_top.setMaximizedControl(sash_form_top
								.getChildren()[0]);
					}
				}
			}

		});

	}

	private void createComparisonItem(FileNode fNode1, FileNode fNode2,
			DATComparisonData data) {
		curFileNode = new FileNode(null, null);
		curFileNode.setfData(data);
		curFileList.add(curFileNode);

		// tab item
		CTabItem compItem = new CTabItem(textFolder, SWT.CLOSE);
		String fileName1 = fNode1.getName().substring(
				fNode1.getName().indexOf(":") + 2);
		String fileName2 = fNode2.getName().substring(
				fNode2.getName().indexOf(":") + 2);
		String fileName = "Compare " + fileName1 + " with " + fileName2;
		compItem.setText(fileName);
		curFileNode.setName(fileName);
		data.setFileName(fileName);

		// set tool tip
		String filePath1 = fNode1.getPath().substring(rootDirPath.length());
		String filePath2 = fNode2.getPath().substring(rootDirPath.length());
		String filePath = "Compare " + filePath1 + " with " + filePath2;
		compItem.setToolTipText(filePath);
		curFileNode.setPath(filePath);

		compItem.setData("path", filePath);

		Composite chartCmp = new Composite(textFolder, SWT.NONE);
		chartCmp.setLayout(new GridLayout(6, false));

		// control options

		xAxisType = "linear";
		yAxisType = "linear";

		// x axis scale
		new Label(chartCmp, SWT.NONE).setText("\tX Axis");

		final Combo xAxisBnt = new Combo(chartCmp, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		xAxisBnt.add("linear");
		xAxisBnt.add("log");
		xAxisBnt.setText(xAxisType);

		// y axis scale
		new Label(chartCmp, SWT.NONE).setText("\tY Axis");

		final Combo yAxisBnt = new Combo(chartCmp, SWT.DROP_DOWN
				| SWT.READ_ONLY);
		yAxisBnt.add("linear");
		yAxisBnt.add("log");
		yAxisBnt.setText(yAxisType);

		xAxisBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {
				xAxisType = xAxisBnt.getText();

				DATComparisonData data = (DATComparisonData) curFileNode
						.getFileData(); // plot
				curChartPanel.setChart(DATComparisonChart.plotChart(data,
						chartTypeList));
				curChartPanel.setChart(DATComparisonChart.plotChart(
						curChartPanel.getChart(), xAxisType, yAxisType));
				updateOutline();
			}
		});
		yAxisBnt.addSelectionListener(new SelectionAdapter() {
			public void widgetSelected(SelectionEvent e) {

				yAxisType = yAxisBnt.getText();

				DATComparisonData data = (DATComparisonData) curFileNode
						.getFileData(); // plot
				curChartPanel.setChart(DATComparisonChart.plotChart(data,
						chartTypeList));
				curChartPanel.setChart(DATComparisonChart.plotChart(
						curChartPanel.getChart(), xAxisType, yAxisType));
				updateOutline();
			}
		});

		// create the chart using JFreeChart
		JFreeChart chart = DATComparisonChart.plotChart(data, chartTypeList);
		CustomizedChartComposite chartPanel = new CustomizedChartComposite(
				chartCmp, SWT.NONE, chart, true);
		GridData griddata = new GridData(GridData.FILL_BOTH);
		griddata.horizontalSpan = 6;
		chartPanel.setLayoutData(griddata);
		curChartPanel = chartPanel;

		// set control
		compItem.setControl(chartCmp);
		textFolder.setSelection(compItem);

		updateOutline();

		for (int i = 0; i < data.getDATDataCount(); i++) {
			// update the "check/uncheck all" button
			data.setAllChecked(i, true);
			((Button) outlineCmp_compare.getChildren()[2 + 5 * i])
					.setSelection(true);

			// update checkbox in the tree
			element_tv_compare.get(i).setAllChecked(true);

			Object[] elements = element_tv_compare.get(i).getCheckedElements();

			for (int j = 0; j < elements.length; j++) {
				TreeNode node = (TreeNode) elements[j];
				if (node.getNodeType().equalsIgnoreCase("SpeciesNode")) {
					// SpeciesNode
					data.addCheckedSpecies(i, (SpeciesNode) elements[j]);
				} else if (node.getNodeType()
						.equalsIgnoreCase("ObservableNode")) {
					// ObservableNode
					data.addCheckedObservable(i, (ObservableNode) elements[j]);
				} else {
				}
			}
		}

		// set file path for each tree
		((Text) outlineCmp_compare.getChildren()[0]).setText(fileName1);
		((Text) outlineCmp_compare.getChildren()[0]).setToolTipText(filePath1);
		((Text) outlineCmp_compare.getChildren()[5]).setText(fileName2);
		((Text) outlineCmp_compare.getChildren()[5]).setToolTipText(filePath2);

		// plot chart
		curChartPanel.setChart(DATComparisonChart
				.plotChart(data, chartTypeList));
		curChartPanel.setChart(DATComparisonChart.plotChart(
				curChartPanel.getChart(), xAxisType, yAxisType));

		// add close listener for tabItem
		compItem.addDisposeListener(new DisposeListener() {

			public void widgetDisposed(DisposeEvent event) {
				CTabItem item = (CTabItem) event.getSource();

				String filePath = (String) item.getData("path");

				// remove the fileNode from curFileList
				removeFileNode(filePath);

				if (curFileList.size() == 0) {
					curFileNode = null;
					if (elementOutline != null
							&& elementOutline.isDisposed() == false) {
						elementOutline.setControl(null);
						// maximize explorerFolder
						sash_form_top.setMaximizedControl(sash_form_top
								.getChildren()[0]);
					}
				}
			}

		});

		setStatus(fileName);

	}

	private void openFileItem(TreeNode node) {
		if (node.getNodeType().equalsIgnoreCase("FolderNode")) {
			return;
		}

		sash_form_top.setMaximizedControl(null);

		setStatus("Opened file " + node.getName());
		// convert TreeNode to FileNode
		curFileNode = (FileNode) node;

		// add the curFileNode to curFileList
		int nodeIndex = curFileList.indexOf(curFileNode);
		if (nodeIndex == -1) {
			curFileList.add(curFileNode);
		} else {
			curFileNode = curFileList.get(nodeIndex);
		}

		// If the file has not opened, create corresponding chart or
		// text, and then open it.

		if (curFileNode.getName().endsWith(".net")
				|| curFileNode.getName().endsWith(".bngl")
				|| curFileNode.getName().endsWith(".log")
				|| curFileNode.getName().endsWith(".pl")
				|| curFileNode.getName().endsWith(".m")
				|| curFileNode.getName().endsWith(".xml")
				|| curFileNode.getName().endsWith(".rxn")
				|| curFileNode.getName().endsWith(".cfg")) {
			// NET
			// check if the file has already opened
			boolean opened = false;
			for (int i = 0; i < textFolder.getItemCount(); i++) {
				CTabItem item = textFolder.getItem(i);
				String path = (String) item.getData("path");
				if (path.equals(curFileNode.getPath())) {
					// set selection on this matched item
					textFolder.setSelection(item);

					updateOutline();
					opened = true;
					break;
				}
			}
			if (opened == false) {

				if (curFileNode.getName().endsWith(".log")
						|| curFileNode.getName().endsWith(".pl")
						|| curFileNode.getName().endsWith(".m")
						|| curFileNode.getName().endsWith(".xml")
						|| curFileNode.getName().endsWith(".rxn")
						|| curFileNode.getName().endsWith(".cfg")) {
					// create a new LOGItem
					createLOGItem(curFileNode);
				} else {
					// create a new netItem
					createNetItem(curFileNode);
				}

				updateOutline();
			}

		} else if (curFileNode.getName().endsWith(".cdat")
				|| curFileNode.getName().endsWith(".gdat")
				|| curFileNode.getName().endsWith(".scan")) {
			// CDAT & GDAT & SCAN

			// check if the file has already opened
			boolean opened = false;
			for (int i = 0; i < textFolder.getItemCount(); i++) {
				CTabItem item = textFolder.getItem(i);
				String path = (String) item.getData("path");
				if (path.equals(curFileNode.getPath())) {
					// set selection on this matched item
					textFolder.setSelection(item);
					int chartIndex = ((Composite) item.getControl())
							.getChildren().length - 1;
					curChartPanel = (CustomizedChartComposite) ((Composite) item
							.getControl()).getChildren()[chartIndex];
					DATChart.resetChart(curChartPanel.getChart()); // reset

					updateOutline();
					opened = true;
					break;
				}
			}
			if (opened == false) {
				// create a new chartItem
				createChartItem(curFileNode);
			}
		}

	}

	/* update element_tv be the treeViewer of the current selected file */
	private void updateOutline() {

		if (curFileNode == null) {
			elementOutline.setControl(null);
			return;
		}

		if (curFileNode.getName().contains("Compare")) {
			// Compare
			elementOutline.setControl(outlineCmp_compare);

			DATComparisonData data = (DATComparisonData) curFileNode
					.getFileData();
			for (int i = 0; i < element_tv_compare.size(); i++) {
				CheckboxTreeViewer cur_compare = element_tv_compare.get(i);

				// set input
				cur_compare.setInput(data.getFolderNode(i));

				// set selection on element_tv
				if (data.getFileName(i).endsWith(".cdat")) {
					String selectedSpeciesName = data.getSelectedSpeciesName(i);
					if (selectedSpeciesName != null) {
						cur_compare.setSelection(
								new StructuredSelection(findSpeciesNode(
										cur_compare, selectedSpeciesName)),
								true);
					} else {
						cur_compare.setSelection(null);
					}
				} else {
					String selectedObservableName = data
							.getSelectedObservableName(i);
					if (selectedObservableName != null) {
						cur_compare.setSelection(
								new StructuredSelection(findObservableNode(
										cur_compare, selectedObservableName)),
								true);
					} else {
						cur_compare.setSelection(null);
					}
				}

				// set some nodes be checked
				cur_compare.setCheckedElements(data.getCheckedElements(i));
			}
			return;
		}

		// create the tree in the outline
		if (curFileNode.getName().endsWith(".cdat")) {

			elementOutline.setControl(outlineCmp_cdat);
			// CDAT

			DATFileData data = (DATFileData) curFileNode.getFileData();
			element_tv_cdat.setInput(data.getSpeciesFolder());

			// set selection on element_tv
			String selectedSpeciesName = data.getSelectedSpeciesName();
			if (selectedSpeciesName != null) {
				element_tv_cdat.setSelection(new StructuredSelection(
						findSpeciesNode(element_tv_cdat, selectedSpeciesName)),
						true);
			} else {
				element_tv_cdat.setSelection(null);
			}

			// set some nodes be checked
			element_tv_cdat.setCheckedElements(data.getCheckedSpecies());

			// set chart type
			int index = outlineCmp_cdat.getChildren().length - 1;
			((Combo) outlineCmp_cdat.getChildren()[index]).setText(data
					.getChartType());

		} else if (curFileNode.getName().endsWith(".gdat")
				|| curFileNode.getName().endsWith(".scan")) {
			// GDAT & SCAN
			elementOutline.setControl(outlineCmp_gdat);

			DATFileData data = (DATFileData) curFileNode.getFileData();
			element_tv_gdat.setInput(data.getObservableFolder());

			// set selection on element_tv
			String selectedObservableName = data.getSelectedObservableName();
			if (selectedObservableName != null) {
				element_tv_gdat
						.setSelection(
								new StructuredSelection(
										findObservableNode(element_tv_gdat,
												selectedObservableName)), true);
			} else {
				element_tv_gdat.setSelection(null);
			}

			// set some nodes be checked
			element_tv_gdat.setCheckedElements(data.getCheckedObservable());

			((Button) outlineCmp_gdat.getChildren()[1]).setSelection(data
					.isAllChecked());

			// expand nodes
			if (data.getExpandedElements() != null) {
				element_tv_gdat.setExpandedElements(data.getExpandedElements());
			}

			// set grayed nodes
			Object[] toSetGray = data.getGrayedElements();
			if (toSetGray != null) {
				for (int i = 0; i < toSetGray.length; i++) {
					element_tv_gdat.setGrayChecked(toSetGray[i], true);
				}
			}

			// set chart type
			int index = outlineCmp_gdat.getChildren().length - 1;
			((Combo) outlineCmp_gdat.getChildren()[index]).setText(data
					.getChartType());

		} else if (curFileNode.getName().endsWith(".net")
				|| curFileNode.getName().endsWith(".bngl")) {
			// NET

			NETFileData data = (NETFileData) curFileNode.getFileData();
			element_tv_net.setInput(data.getNETFolderNode());
			elementOutline.setControl(element_tv_net.getControl());

			// set selection on selected item
			String selectedItem = data.getSelectedItem();
			if (selectedItem != null) {
				element_tv_net.setSelection(new StructuredSelection(
						findNETItemNode(selectedItem)), true);
			} else {
				element_tv_net.setSelection(null);
			}

		} else if (curFileNode.getName().endsWith(".log")
				|| curFileNode.getName().endsWith(".pl")
				|| curFileNode.getName().endsWith(".m")
				|| curFileNode.getName().endsWith(".xml")
				|| curFileNode.getName().endsWith(".rxn")
				|| curFileNode.getName().endsWith(".cfg")) {
			elementOutline.setControl(null);
		}

	}

	/*
	 * Return speciesNode based on index
	 */
	private SpeciesNode findSpeciesNode(CheckboxTreeViewer tv,
			String speciesName) {
		Tree tree = tv.getTree();
		for (int i = 0; i < tree.getItemCount(); i++) {
			if (tree.getItem(i).getText().equalsIgnoreCase(speciesName)) {
				return (SpeciesNode) tree.getItem(i).getData();
			}
		}
		return null;
	}

	/*
	 * Return ObservableNode based on index
	 */
	private ObservableNode findObservableNode(CheckboxTreeViewer tv,
			String observableName) {
		Tree tree = tv.getTree();
		for (int i = 0; i < tree.getItemCount(); i++) {
			if (tree.getItem(i).getText().equalsIgnoreCase(observableName)) {
				return (ObservableNode) tree.getItem(i).getData();
			}
		}
		return null;
	}

	/*
	 * Return NETItemNode based on name
	 */
	private NETItemNode findNETItemNode(String itemName) {
		Tree tree = element_tv_net.getTree();
		for (int i = 0; i < tree.getItemCount(); i++) {
			if (tree.getItem(i).getText().equals(itemName)) {
				return (NETItemNode) tree.getItem(i).getData();
			}
		}
		return null;
	}

	/*
	 * Return file node from curFileList by name.
	 */
	private FileNode getFileNode(String text) {
		for (int i = 0; i < curFileList.size(); i++) {
			if (curFileList.get(i).getPath().equals(text))
				return curFileList.get(i);
		}
		return null;
	}

	/*
	 * Remove file node from curFileList by name.
	 */
	private void removeFileNode(String text) {
		for (int i = 0; i < curFileList.size(); i++) {
			if (curFileList.get(i).getPath().equals(text)) {
				curFileList.remove(i);
				return;
			}
		}
	}

	/*
	 * Return item id in textFolder based on its path
	 */
	private int getIndexOfItemByPath(String path) {
		for (int i = 0; i < textFolder.getItemCount(); i++) {
			if (textFolder.getItem(i).getData("path").equals(path)) {
				return i;
			}
		}
		return -1;
	}

	/*
	 * Initialize the graph, set location and size
	 */
	private void initGraph() {
		jf = new JFrame();
		jf.setBackground(java.awt.Color.WHITE);
		jf.setTitle("Graph");
		jf.setVisible(true);

		// set size and position of the JFrame
		Rectangle displayRec = Display.getCurrent().getBounds();
		Rectangle shellRec = getShell().getBounds();
		int graphWidth = displayRec.width - shellRec.width - shellRec.x;
		if (graphWidth >= 340) {
			if (graphWidth > shellRec.width) {
				graphWidth = shellRec.width;
			}
			jf.setLocation(shellRec.x + shellRec.width, shellRec.y);
			jf.setPreferredSize(new Dimension(graphWidth, shellRec.height));
		} else if (graphWidth < 340) {
			graphWidth = 500;
			jf.setLocation(0, 0);
			jf.setPreferredSize(new Dimension(graphWidth, shellRec.height));
		}

	}

	/*
	 * Show the graph for itemList
	 */
	// TODO Switch this to using the NetworkViewer
	private boolean showGraph(ArrayList<String> itemList) {
		/*
		 * if (jf == null) { initGraph();
		 * 
		 * } else { if (jf.isShowing() == false) { jf.setVisible(true); }
		 * jf.getContentPane().removeAll(); jf.setPreferredSize(new
		 * Dimension(jf.getBounds().width, jf .getBounds().height)); }
		 * 
		 * panel = new JPanel(); panel.setLayout(new BoxLayout(panel,
		 * BoxLayout.PAGE_AXIS));
		 * 
		 * // scroll panel JScrollPane jscrollP = new JScrollPane(panel); //
		 * jscrollP
		 * .setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
		 * jf.add(jscrollP);
		 */
		// add items to graph
		for (int i = 0; i < itemList.size(); i++) {
			String curItem = itemList.get(i);
			String[] tmp = curItem.split("\t");
			String type = tmp[0];
			String itemExp = tmp[1];
			if (addItemToGraph(type, itemExp) == false) {
				/*
				 * jf.dispose(); jf = null;
				 */
				return false;
			}
		}

		// jf.pack();
		// getShell().setFocus();
		return true;

	}

	/*
	 * Add one item to the graph
	 */
	private boolean addItemToGraph(String type, String itemExp) {
		if (type.equals("species") || type.equals("pattern")) {
			// species
			String[] tmp = itemExp.split(" ");
			int id = Integer.parseInt(tmp[0]);
			String expression = "";
			if (tmp.length > 1) {
				expression = tmp[1];
			} else {
				return false;
			}

			// TODO Add this label to the window somewhere.
			/*
			 * // label JLabel label = new JLabel(type + ": " +
			 * itemExp.replaceFirst("-1", "")); panel.add(label);
			 */

			// display
			try {
				SpeciesGraph sg = new SpeciesGraph(id, expression,
						VisualizationViewerController
								.loadVisualizationViewController()
								.getSpeciesBrowserSize(),
						VisualizationViewerController
								.loadVisualizationViewController()
								.getSpeciesBrowserOverviewSize());

				prefuse.Display dis = sg.getDisplay();

				prefuse.Display oDis = sg.getOverviewDisplay();
				// panel.add(dis);
				VisualizationViewerController.loadVisualizationViewController()
						.updateSpeciesBrowser(dis);
				VisualizationViewerController.loadVisualizationViewController()
						.updateSpeciesBrowserOverview(oDis);
				// must be twice because some values are unavailable for the
				// first time
				VisualizationViewerController.loadVisualizationViewController()
						.updateSpeciesBrowserOverview(null);

			} catch (Exception e) {
				e.printStackTrace();
				return false;
			}

		} else if (type.equals("rule")) {

		}
		return true;
	}

	/*
	 * Open default file in explorer SCAN or GDAT
	 */
	public void openDefaultFile(String expandFilePath, String expandFileType) {

		System.out.println("EFP: " + expandFilePath);
		System.out.println("EFT: " + expandFileType);

		if (expandFilePath.equals("") && expandFileType.equals("")) {
			return;
		}

		sash_form_top.setMaximizedControl(null);

		String tmp[] = expandFilePath.split("\t");
		String modelName = tmp[0];
		String curTime = tmp[1];
		String prefix = "";
		if (tmp.length == 3) {
			prefix = tmp[2];
		}

		Object[] expandedElements = file_tv.getExpandedElements();

		file_tv.expandAll();
		Object[] firstLevel = ((TreeNode) file_tv.getInput())
				.getChildrenArray();
		for (int i = 0; i < firstLevel.length; i++) {
			// match model name
			TreeNode curFirst = (TreeNode) firstLevel[i];
			if (curFirst.getName().equals(modelName)) {
				// found model
				Object[] secondLevel = ((TreeNode) curFirst).getChildrenArray();

				for (int j = 0; j < secondLevel.length; j++) {
					// match time label
					// "para_scan" for SCAN file
					TreeNode curSecond = (TreeNode) secondLevel[j];
					if (curSecond.getName().equals(curTime)) {
						// find time label
						Object[] thirdLevel = ((TreeNode) curSecond)
								.getChildrenArray();

						for (int k = 0; k < thirdLevel.length; k++) {
							// match file
							TreeNode curThird = (TreeNode) thirdLevel[k];
							boolean found = false;

							if (expandFileType.equals(".gdat")
									&& curThird.getName().endsWith(
											expandFileType)) {
								found = true;
							} else if (expandFileType.equals(".scan")
									&& curThird.getName().equals(
											"SCAN: " + prefix + expandFileType)) {
								found = true;
							}

							if (found == true) {
								// found the file
								// update curFileNode
								curFileNode = (FileNode) curThird;
								curFileList.add(curFileNode);

								// create new chart item
								createChartItem(curFileNode);

								// expand
								file_tv.collapseAll();
								file_tv.setExpandedElements(expandedElements);
								file_tv.expandToLevel(curFirst, 1);
								file_tv.expandToLevel(curSecond, 1);

								// set selection
								file_tv.setSelection(new StructuredSelection(
										curThird), true);

								// set status line
								setStatus("Opened file "
										+ curFileNode.getName());

								break;
							} else {
								// expand
								file_tv.collapseAll();
								file_tv.setExpandedElements(expandedElements);
								file_tv.expandToLevel(curFirst, 1);
								file_tv.expandToLevel(curSecond, 1);
							}
						}
					}
				}
			}
		}
	}

	/*
	 * Return the graph frame.
	 */

	public JFrame getGraphFrame() {
		return this.jf;
	}

	/*
	 * Return the bounds of window
	 */
	public Rectangle getBounds() {
		this.windowBounds = getShell().getBounds();
		return this.windowBounds;
	}

	public void refresh() {
		// store all the elements that have been expanded
		Object[] elements = file_tv.getExpandedElements();
		// create a new rootNode
		rootNode = new FolderNode(new File(rootDirPath));
		// set input to file_tv again
		file_tv.setInput(rootNode);
		// expand elements
		// the equals() and hashCode() methods have been override for
		// FileNode and FolderNode
		file_tv.setExpandedElements(elements);

		// TODO deal with the opened files that have been deleted in the
		// file systems

	}
}
